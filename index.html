<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>SUCH IS LIFE - Kelly Gang Survival</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        /* --- Base Styles & Variables --- */
        :root {
            /* Dark/Green Scheme */
            --dark-bg: #1e2a28;
            --container-bg: #2a3d45;
            --container-border: #111a18;
            --top-bar-bg: rgba(0, 0, 0, 0.2);
            --dusty-green: #7a8c79;
            --dark-text: #d0d8d7;
            --accent-gold: #FFD700;
            --title-red: #a00000;

            /* Mappings */
            --bg-color: var(--dark-bg);
            --primary-color: var(--dusty-green);
            --secondary-color: var(--container-bg);
            --accent-color: var(--accent-gold);
            --text-color: var(--dark-text);

            /* Other Colors */
            --player-color: #DC143C;
            --other-player-color: #4682B4;
            --enemy-color: #556B2F;
            --bullet-player-color: #FFEB3B;
            --bullet-enemy-color: #C0C0C0;
            --health-bar-bg: #444;
            --health-bar-high: #66bb6a;
            --health-bar-medium: var(--accent-gold);
            --health-bar-low: var(--player-color);
            --powerup-health: #81c784;
            --powerup-gun: #ba68c8;
            --powerup-speed: #4dd0e1;
            --powerup-armor: #9e9e9e;
            --night-overlay: rgba(0, 0, 10, 0.3);

            /* Other variables */
            --font-family: 'Courier New', monospace;
            --reconciliation-threshold: 15;
            --lerp-factor: 0.1;
            --damage-text-color: #FFFFFF;
            --damage-text-crit-color: var(--accent-gold);
            --damage-text-font-size: 14px;
            --damage-text-crit-font-size: 18px;
            --campfire-aura-color: rgba(255, 165, 0, 0.15);
        }

        /* --- General Body/Container --- */
        body {
            margin: 0; display: flex; flex-direction: column; justify-content: center;
            align-items: center; min-height: 100vh; background-color: var(--bg-color);
            font-family: var(--font-family); color: var(--text-color);
        }
        #game-container {
            background-color: var(--secondary-color);
            border: 5px solid var(--container-border);
            border-radius: 15px; padding: 20px; padding-top: 15px; /* Keep padding */
            text-align: center; max-width: 1980px; /* Increased max-width for wider layout */
            width: calc(100% - 40px); position: relative; box-shadow: 0 0 20px rgba(0,0,0,0.7);
            overflow: hidden;
        }

        /* --- Top Bar Styling (Simplified) --- */
        #top-bar {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center; /* Center title */
            padding: 5px 10px;
            margin-bottom: 5px;
            border-bottom: 2px solid var(--primary-color);
            background-color: var(--top-bar-bg);
            border-radius: 10px 10px 0 0;
            box-sizing: border-box;
            width: 100%;
        }

        /* Title Styling */
        #top-bar h1 {
            color: var(--text-color);
            margin: 5px 0 10px 0;
            padding: 0;
            line-height: 1.1;
            text-shadow: 2px 2px 5px black;
            font-size: 2.5em;
            font-weight: bold;
        }

        /* Game Status (Below Top Bar) */
        #game-status {
            min-height: 25px;
            color: var(--accent-color);
            font-weight: bold;
            margin-bottom: 15px; /* Space below status */
            text-align: center;
        }


        /* --- Visibility Control --- */
        #main-menu-section,
        #multiplayer-menu-section,
        #host-wait-section,
        #join-code-section,
        #game-area, /* Initially hidden, shown via JS */
        #game-over-screen {
            display: none;
        }

        /* --- Game Area Layout --- */
        #game-area {
            display: flex;
            flex-direction: row; 
            align-items: stretch;    
            width: 100%;
        }
        /* --- Left Panel Styling --- */
        #left-panel {
            width: 360px;
            max-height: 910px;
            flex-shrink: 0;
            background-color: var(--container-bg);
            padding: 15px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            color: var(--text-color);
            font-size: 13px;
            overflow-y: auto;
            overflow-x: hidden;
        }


        #left-panel .left-panel-top-group {
            flex-grow: 1;
            flex-shrink: 1;
            display: flex;
            flex-direction: column;
        }

        #left-panel .left-panel-bottom-group {
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
        }

        #player-stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            width: 100%;
            box-sizing: border-box;
            margin-bottom: 15px;
            flex-shrink: 0;
        }

        /* Individual Player Stat Box Styling */
        .player-stats-box {
            display: block;
            color: var(--text-color);
            font-size: 14px;
            background: rgba(10, 20, 25, 0.6);
            padding: 8px 10px;
            border-radius: 4px;
            text-align: left;
            border: 1px solid var(--dusty-green);
            box-sizing: border-box;
            box-shadow: inset 0 0 4px rgba(0,0,0,0.4);
            overflow: hidden; /* Prevents content bleed */
        }
        .player-stats-box .stats-header {
            font-size: 15px;
            font-weight: bold;
            color: var(--accent-color);
            text-align: center;
            padding-bottom: 4px;
            margin-bottom: 5px;
            border-bottom: 1px dashed var(--primary-color);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis; /* Prevent long headers breaking layout */
            box-sizing: border-box;
        }
        .player-stats-box .stats-content {
            line-height: 1.5;
            overflow-wrap: break-word; /* Wrap long stat values */
            word-wrap: break-word;
        }
        .player-stats-box .stats-content span {
            display: inline-block;
            min-width: 40px; /* Align stat values */
            font-weight: bold;
            color: var(--dusty-green);
            vertical-align: top;
        }

        /* --- Day/Night Indicator Styling --- */
        #left-panel #day-night-indicator {
            display: none; /* Shown by JS */
            text-align: center;
            margin: 0 0 15px 0; /* Space below indicator */
            font-size: 1.1em;
            padding: 5px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            box-sizing: border-box;
            width: 100%;
            color: var(--text-color);
            flex-shrink: 0;
        }

        /* --- Leave Button Styling (Moved Position) --- */
        #left-panel #leaveGameBtn {
            display: block;
            width: 100%;
            margin-top: auto;      
            margin-bottom: 15px;   
            padding: 12px 10px; 
            font-size: 1rem;    
            box-sizing: border-box;
            flex-shrink: 0;
        }

        /* --- Chat Log Styling (Height Increased Again) --- */
        #left-panel #chat-log {
            height: 190px;
            overflow-y: scroll;
            border: 1px solid var(--primary-color);
            margin-bottom: 8px;
            padding: 5px;
            text-align: left;
            background: rgba(10, 20, 25, 0.5);
            font-size: 13px;
            border-radius: 5px;
            width: 100%;
            transition: background-color 0.5s ease, border-color 0.5s ease;
            color: var(--dark-text);
            box-sizing: border-box;
            flex-shrink: 0;
        }
        #left-panel #chat-log div { margin-bottom: 3px; word-wrap: break-word; }
        #left-panel #chat-log .my-message { color: var(--bullet-player-color); }
        #left-panel #chat-log .other-message { color: var(--text-color); }
        #left-panel #chat-log .system-message { color: var(--accent-color); font-style: italic; }

        /* Night Mode Chat Log Styling */
        #game-container.night-mode #left-panel #chat-log {
            background-color: rgba(10, 20, 25, 0.7);
            border-color: var(--accent-color);
        }
        #game-container.night-mode #left-panel #chat-log .my-message { color: #FFFF99; }
        #game-container.night-mode #left-panel #chat-log .other-message { color: #C0C0FF; }
        #game-container.night-mode #left-panel #chat-log .system-message { color: var(--accent-color); }

        /* Chat Input Styling (Now Block Element) */
        #left-panel #chatInput {
            display: block;
            width: 100%;
            padding: 12px 8px;
            font-size: 0.9rem;
            box-sizing: border-box;
            margin-bottom: 8px;
        }

        #left-panel #sendChatBtn {
            display: block;
            width: 100%;
            padding: 12px 10px;
            font-size: 1rem;
            box-sizing: border-box;
            flex-shrink: 0;
        }


        /* --- Canvas Container Styling --- */
        #canvas-container {
            flex-grow: 1; /* Take remaining horizontal space */
            display: flex;
            justify-content: center; /* Center canvas wrapper horizontally */
            align-items: flex-start; /* Align canvas wrapper to the top */
            min-width: 0; /* Important for flex item sizing */
        }

        /* Canvas Styling */
        #gameCanvas {
            border: 3px solid var(--primary-color);
            background-color: #a0522d; /* Default background, JS changes */
            display: block; /* Remove extra space below canvas */
            width: 1600px; /* Target size */
            height: 900px;
            max-width: 100%; /* Prevent overflow on smaller canvas containers */
            margin: 0;
            box-sizing: border-box;
        }

        /* Countdown Overlay Styling */
        #countdown {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 72px;
            color: var(--player-color);
            text-shadow: 3px 3px 6px black;
            z-index: 10;
            pointer-events: none; /* Allow clicks through */
            display: none; /* Shown by JS */
        }

        /* --- Common Elements (Unchanged) --- */
        button { background-color: var(--primary-color); color: var(--dark-bg); border: 2px solid var(--container-border); padding: 10px 20px; margin: 10px 5px; cursor: pointer; font-family: var(--font-family); font-size: 1rem; transition: background-color 0.2s ease, color 0.2s ease; border-radius: 5px; font-weight: bold; box-sizing: border-box; }
        button:hover:not(:disabled) { background-color: #9cb49a; color: #000; }
        button:disabled { background-color: #555; color: #aaa; cursor: not-allowed; border-color: #444; }
        input[type="text"] { padding: 10px; margin: 10px 5px; font-family: var(--font-family); font-size: 1rem; border: 2px solid var(--primary-color); border-radius: 5px; background-color: var(--dark-text); color: var(--dark-bg); text-transform: uppercase; box-sizing: border-box; }

        /* --- Menu Sections (Unchanged) --- */
        .menu-section { padding: 30px; text-align: center; box-sizing: border-box; width: 100%; color: var(--text-color); }
        .menu-section h2 { color: var(--accent-color); margin-bottom: 20px; }
        .menu-section button { display: block; width: 80%; max-width: 300px; margin: 15px auto; padding: 15px 20px; font-size: 1.2rem; }
        .menu-section input[type="text"] { display: inline-block; width: auto; min-width: 180px; }

        /* --- Host/Join Specific (Unchanged) --- */
        #host-wait-section p, #join-code-section p { font-size: 1.1rem; margin-bottom: 10px; }
        #game-code-display { font-size: 1.8rem; font-weight: bold; color: var(--accent-color); background-color: var(--dark-bg); padding: 5px 15px; border-radius: 5px; display: inline-block; margin: 10px 0; user-select: all; border: 1px solid var(--primary-color); }
        #waiting-message { margin-top: 15px; font-style: italic;}

        /* --- Game Over Screen  --- */
        #game-over-screen {
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background-color: rgba(10, 20, 25, 0.9);
                    padding: 25px;
                    border: 3px solid var(--player-color);
                    border-radius: 10px;
                    /* color: var(--accent-color); /* Base text color is often inherited */
                    text-align: center; /* Centers text *within* block elements like h2/p */
                    z-index: 20;
                    width: 80%;
                    max-width: 350px; /* Keeps it from getting too wide */
                    box-sizing: border-box;
                    display: none; /* Keep initially hidden */

                    /* --- ADD THESE LINES --- */
                    display: flex;          /* Use flexbox for layout */
                    flex-direction: column; /* Stack children vertically */
                    align-items: center;    /* Center children horizontally */
                    /* --- END ADDED LINES --- */
                }
                /* Other game over styles remain the same */
                #game-over-screen h2 { color: var(--player-color); margin-top: 0; margin-bottom: 20px; font-size: 1.8em; }
                #final-stats { margin-bottom: 25px; text-align: center; color: var(--text-color); font-size: 1.3em; line-height: 1.6; width: 100%; /* Ensure stats block can take width */ }
                .final-stat-item strong { color: var(--accent-color); margin-right: 8px; display: inline-block; min-width: 70px; text-align: right; }
                #game-over-screen button { margin-top: 10px; padding: 12px 25px; font-size: 1.1rem; }

    </style>
</head>
<body>
    <div id="game-container">
        <!-- Top Bar (Just Title) -->
        <div id="top-bar">
            <h1>SUCH IS LIFE</h1>
        </div>
        <!-- Game Status (Below Top Bar) -->
        <div id="game-status">Initializing...</div>

        <!-- Menu Sections -->
        <div id="main-menu-section" class="menu-section">
            <h2>Main Menu</h2>
            <button id="singlePlayerBtn">Single Player</button>
            <button id="multiplayerBtn">Multiplayer</button>
        </div>
        <div id="multiplayer-menu-section" class="menu-section">
            <h2>Multiplayer</h2>
            <p style="margin-bottom: 5px;">Choose number of players:</p>
            <button id="hostGameBtn2">Host 2 Player Game</button>
            <button id="hostGameBtn3">Host 3 Player Game</button>
            <button id="hostGameBtn4">Host 4 Player Game</button>
            <hr style="margin: 20px auto; width: 80%; border-color: var(--primary-color);">
            <button id="showJoinUIBtn">Join Game (Enter Code)</button>
            <button class="back-button" onclick="showSection('main-menu-section')">Back</button>
       </div>
        <div id="host-wait-section" class="menu-section">
             <h2>Hosting Game</h2>
             <p>Share this code with your mate:</p>
             <div id="game-code-display">------</div>
             <p id="waiting-message">Waiting for opponent to connect...</p>
             <button id="cancelHostBtn">Cancel Hosting</button>
        </div>
        <div id="join-code-section" class="menu-section">
             <h2>Join Game</h2>
             <p>Enter the 6-character game code:</p>
             <input type="text" id="gameIdInput" placeholder="ABCDEF" maxlength="6">
             <button id="joinGameSubmitBtn">Join Game</button>
             <button class="back-button" onclick="showSection('multiplayer-menu-section')">Back</button>
        </div>

        <!-- Game Area -->
        <div id="game-area">
            <!-- Left Panel -->
            <div id="left-panel">

                <div class="left-panel-top-group">
                    <div id="player-stats-grid">
                        Loading Stats...
                    </div>
                    <div id="day-night-indicator" style="display: none;">Day --:--</div>
                </div>
            
                <div class="left-panel-bottom-group">
                    <button id="leaveGameBtn">Leave Game</button>
                    <div id="chat-log"></div>
                    <input type="text" id="chatInput" placeholder="Say somethin', mate..." maxlength="100">
                    <button id="sendChatBtn">Send</button>
                </div>
            
            </div>

            <!-- Canvas Container (Takes remaining width) -->
            <div id="canvas-container">
                <div style="position: relative;"> <!-- Wrapper for countdown -->
                    <canvas id="gameCanvas" width="1600" height="900"></canvas>
                    <div id="countdown"></div>
                </div>
            </div>

        </div> <!-- End game-area -->

        <!-- Game Over Screen -->
        <div id="game-over-screen">
            <h2>Game Over, Mate!</h2>
            <div id="final-stats"></div>
            <button id="gameOverBackBtn">Back to Menu</button>
        </div>

    </div>

    <script>
        // --- Constants (Defined First) ---
        const WEBSOCKET_URL = 'wss://such-is-life.glitch.me/ws'; // UPDATE IF YOUR GLITCH URL CHANGES
        const CANVAS_WIDTH = 1600;
        const CANVAS_HEIGHT = 900;
        const PLAYER_WIDTH = 32; const PLAYER_HEIGHT = 32;
        const ENEMY_WIDTH = 15; const ENEMY_HEIGHT = 25; const BULLET_RADIUS = 4; const POWERUP_SIZE = 12;
        const SHOOT_COOLDOWN = 750; // ms
        const RAPID_FIRE_COOLDOWN_MULTIPLIER = 0.4;
        const INPUT_SEND_INTERVAL = 50; // ms
        const MAX_PLAYERS = 4;
        const RECONNECT_DELAY = 3000; // ms
        // Default player state values needed for rendering/prediction before server state arrives
        const PLAYER_DEFAULTS = { width: 25, height: 48, max_health: 100, base_speed: 150 }; // Added base_speed
        const ENEMY_DEFAULTS = { width: 25, height: 25, max_health: 50 };
        const BULLET_DEFAULTS = { radius: 4 };
        const POWERUP_DEFAULTS = { size: 20 }; // Added powerup defaults
        const ENEMY_TYPE_CHASER = 'chaser';
        const ENEMY_TYPE_SHOOTER = 'shooter';
        const BULLET_TYPE_STANDARD = 'standard';
        const BULLET_TYPE_STANDARD_ENEMY = 'standard_enemy';
        const PLAYER_STATUS_ALIVE = 'alive';
        const PLAYER_STATUS_DOWN = 'down';
        const PLAYER_STATUS_DEAD = 'dead';
        // --- End Constants ---

        // --- Utility Functions ---
        function getCssVar(varName) { return getComputedStyle(document.documentElement).getPropertyValue(varName).trim() || ''; }
        function lerp(start, end, amount) { return start + (end - start) * amount; }
        function distance(x1, y1, x2, y2) { const dx = x1 - x2; const dy = y1 - y2; return Math.sqrt(dx * dx + dy * dy); }

        // --- DOM Elements ---
        const DOM = {
            gameContainer: document.getElementById('game-container'),
            gameStatus: document.getElementById('game-status'),
            // Sections
            mainMenuSection: document.getElementById('main-menu-section'),
            multiplayerMenuSection: document.getElementById('multiplayer-menu-section'),
            hostWaitSection: document.getElementById('host-wait-section'),
            joinCodeSection: document.getElementById('join-code-section'),
            gameArea: document.getElementById('game-area'),
            gameOverScreen: document.getElementById('game-over-screen'),
            // Specific elements
            gameCodeDisplay: document.getElementById('game-code-display'),
            waitingMessage: document.getElementById('waiting-message'),
            gameIdInput: document.getElementById('gameIdInput'),
            canvas: document.getElementById('gameCanvas'),
            ctx: document.getElementById('gameCanvas').getContext('2d'),
            // gameScoreDiv: document.getElementById('game-score'), // Obsolete?
            dayNightIndicator: document.getElementById('day-night-indicator'),
            countdownDiv: document.getElementById('countdown'),
            finalStatsDiv: document.getElementById('final-stats'),
            chatInput: document.getElementById('chatInput'),
            chatLog: document.getElementById('chat-log'),
            // Buttons (listeners assigned in Game.initListeners)
            singlePlayerBtn: document.getElementById('singlePlayerBtn'),
            multiplayerBtn: document.getElementById('multiplayerBtn'),
            hostGameBtn2: document.getElementById('hostGameBtn2'),
            hostGameBtn3: document.getElementById('hostGameBtn3'),
            hostGameBtn4: document.getElementById('hostGameBtn4'),
            showJoinUIBtn: document.getElementById('showJoinUIBtn'),
            cancelHostBtn: document.getElementById('cancelHostBtn'),
            joinGameSubmitBtn: document.getElementById('joinGameSubmitBtn'),
            sendChatBtn: document.getElementById('sendChatBtn'),
            leaveGameBtn: document.getElementById('leaveGameBtn'),
            gameOverBackBtn: document.getElementById('gameOverBackBtn'),
        };

        // --- Global Client State ---
        let appState = {
            mode: 'menu', // Start in menu
            localPlayerId: null,
            maxPlayersInGame: null,
            currentGameId: null,
            serverState: null,
            animationFrameId: null,
            isConnected: false,
            // Interpolation/Prediction State
            renderedPlayerPos: { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 },
            predictedPlayerPos: { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 },
            lastServerState: null,     // State before latest
            previousServerState: null, // State before that
            lastLoopTime: null, // Changed from performance.now() to null
            lastStateReceiveTime: performance.now(), // Initialize with current time

        };
        let localPlayerMuzzleFlash = { active: false, endTime: 0, aimDx: 0, aimDy: 0 };
        let hitPauseFrames = 0;
        let activeSpeechBubbles = {}; // { playerId: { text: "Hi!", endTime: 123456789 } }
        let activeEnemyBubbles = {};  // { enemyId: { text: "Grrr!", endTime: 123456789 } }
        let socket = null; // Single WebSocket connection reference

        // --- ADD SNAKE STATE HERE ---

        // --- SNAKE STATE ---
        let snake = {
            active: false,
            x: -50,
            y: 0,
            segmentLength: 1,   // Reduced from 2 to 1 (50% smaller)
            segments: [],
            maxSegments: 50,     
            baseY: 0,
            direction: 1,
            speed: 85,           
            frequency: 0.1,     // Increased frequency for tighter curves
            amplitude: 25,      // Reduced from 50 to 25 (50% smaller)
            
            update: function(currentTime) {
                // Update head position
                snake.x += snake.direction * snake.speed * 0.05;
                
                // Calculate realistic serpentine motion with time-based wave
                const waveTime = currentTime * 0.005;
                snake.y = snake.baseY + Math.sin(snake.x * snake.frequency + waveTime) * snake.amplitude;
                
                // Add new segment at current head position
                if (snake.segments.length === 0 || 
                    Math.hypot(snake.x - snake.segments[0].x, snake.y - snake.segments[0].y) > snake.segmentLength) {
                    snake.segments.unshift({x: snake.x, y: snake.y, time: currentTime});
                    
                    // Trim excess segments
                    if (snake.segments.length > snake.maxSegments) {
                        snake.segments.pop();
                    }
                }
                
                // Update existing segments for a propagating wave effect
                for (let i = 1; i < snake.segments.length; i++) {
                    const segment = snake.segments[i];
                    const timeOffset = (currentTime - segment.time) * 0.001;
                    const segmentWave = Math.sin(segment.x * snake.frequency + waveTime - timeOffset * 3);
                    
                    // Wave that moves from head to tail
                    snake.segments[i].y = snake.baseY + segmentWave * snake.amplitude * (1 - (i / snake.segments.length) * 0.2);
                }
            }
        };
                    function initSnake() {
                        snake.x = -50;
                        snake.y = snake.baseY;
                        snake.segments = [];
                        
                        // Add a few initial segments
                        for (let i = 1; i <= 10; i++) {
                            snake.segments.push({
                                x: snake.x - (i * snake.segmentLength),
                                y: snake.baseY
                            });
                        }
                        
                        snake.active = true;
                    }

        // --- Spawn timers remain the same ---
        let snakeSpawnTimer = 5 + Math.random() * 10;
        const SNAKE_SPAWN_INTERVAL_MIN = 15;
        const SNAKE_SPAWN_INTERVAL_MAX = 35;
        // --------------------------

        // --- Logging Wrapper ---
        function log(...args) { console.log("[Client]", ...args); }
        function error(...args) { console.error("[Client]", ...args); }

// --- UI Management "Module" ---
        const UI = (() => {
            const allSections = [
                DOM.mainMenuSection, DOM.multiplayerMenuSection, DOM.hostWaitSection,
                DOM.joinCodeSection, DOM.gameArea, DOM.gameOverScreen
            ];
            const gameSections = ['game-area'];

            function showSection(sectionId) {
                allSections.forEach(s => { if(s) s.style.display = 'none'; });
                const sectionToShow = DOM[sectionId] || document.getElementById(sectionId);
                if (sectionToShow) {
                    sectionToShow.style.display = (sectionId === 'game-area') ? 'flex' : 'block';
                    log(`UI: Showing section: ${sectionId}`);
                    if (gameSections.includes(sectionId)) {
                        DOM.gameContainer.classList.add('in-game');
                    } else {
                        DOM.gameContainer.classList.remove('in-game');
                    }
                } else {
                     error(`UI: Section not found: ${sectionId}`);
                }
            }

            function updateStatus(message, isError = false) {
                 if (DOM.gameStatus) {
                     DOM.gameStatus.textContent = message;
                     DOM.gameStatus.style.color = isError ? (getCssVar('--player-color') || 'red') : (getCssVar('--accent-color') || 'yellow');
                     if(isError) console.error("Status Update:", message);
                     else console.log("Status Update:", message);
                 } else {
                     error("DOM.gameStatus not found for update:", message);
                 }
            }

            function formatTime(totalSeconds) {
                if (totalSeconds < 0) totalSeconds = 0;
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = Math.floor(totalSeconds % 60);
                const paddedSeconds = seconds < 10 ? '0' + seconds : seconds;
                return `${minutes}:${paddedSeconds}`;
            }

            function updateHUD(serverState) {
                const gridContainer = document.getElementById('player-stats-grid');
                if (!gridContainer) {
                    error("UI Error: #player-stats-grid container not found!");
                    return;
                }

                const players = serverState?.players;
                const localPlayerId = appState.localPlayerId;

                gridContainer.innerHTML = '';

                if (!players || Object.keys(players).length === 0) {
                     gridContainer.innerHTML = '<span>Waiting for players...</span>';
                     return;
                }

                const sortedPlayerIds = Object.keys(players).sort((a, b) => {
                     if (a === localPlayerId) return -1;
                     if (b === localPlayerId) return 1;
                     return a.localeCompare(b);
                 });

                sortedPlayerIds.forEach(playerId => {
                    const playerData = players[playerId];
                    if (!playerData) return;

                    const isSelf = (playerId === localPlayerId);
                    const headerText = isSelf ? "YOU" : `P:${playerId.substring(0, 4)}`;
                    const status = playerData.player_status || PLAYER_STATUS_ALIVE;
                    const healthValue = playerData.health ?? 0;
                    const maxHealth = playerData.max_health ?? PLAYER_DEFAULTS.max_health;
                    const armorValue = playerData.armor ?? 0;

                    let healthDisplay;
                     if (status === PLAYER_STATUS_DOWN) {
                         healthDisplay = `<span style='color: var(--health-bar-medium);'>DOWN</span>`;
                     } else if (status === PLAYER_STATUS_DEAD || healthValue <= 0) {
                         healthDisplay = `<span style='color: var(--health-bar-low);'>DEAD</span>`;
                     } else {
                        healthDisplay = `${healthValue.toFixed(3)}`;
                    }

                    const armorDisplay = Math.round(armorValue);

                    const statsBoxHTML = `
                        <div class="player-stats-box">
                            <div class="stats-header">${headerText}</div>
                            <div class="stats-content">
                                <span>HP:</span> ${healthDisplay}<br>
                                <span>Armor:</span> ${armorDisplay}<br>
                                <span>Gun:</span> ${playerData.gun ?? 1}<br>
                                <span>Speed:</span> ${playerData.speed ?? PLAYER_DEFAULTS.base_speed}<br>
                                <span>Kills:</span> ${playerData.kills ?? 0}<br>
                                <span>Score:</span> ${playerData.score ?? 0}
                            </div>
                        </div>
                    `;
                    gridContainer.innerHTML += statsBoxHTML;
                });

            }

            function addChatMessage(sender, message, isSelf, isSystem = false) {
                if (!DOM.chatLog) { error("DOM.chatLog not found for chat message."); return; }
                const div = document.createElement('div');
                if (isSystem) {
                    div.className = 'system-message'; div.textContent = message;
                } else {
                    div.className = isSelf ? 'my-message' : 'other-message';
                    div.textContent = `${sender ? `P:${sender.substring(0,4)}` : '???'}: ${message}`;
                }
                DOM.chatLog.appendChild(div);
                DOM.chatLog.scrollTop = DOM.chatLog.scrollHeight;
            }

            function updateCountdown(serverState) {
                 if (DOM.countdownDiv && DOM.dayNightIndicator) {
                    if (serverState?.status === 'countdown' && serverState?.countdown >= 0) {
                        DOM.countdownDiv.textContent = Math.ceil(serverState.countdown);
                        DOM.countdownDiv.style.display = 'block';
                        DOM.dayNightIndicator.style.display = 'none';
                    } else {
                        DOM.countdownDiv.style.display = 'none';
                        DOM.dayNightIndicator.style.display = (serverState?.status === 'active') ? 'block' : 'none';
                    }
                } else {
                    error("DOM.countdownDiv or DOM.dayNightIndicator not found.");
                }
             }

             function updateDayNight(serverState) {
                 // Check if necessary DOM elements exist
                 if (!DOM.dayNightIndicator || !DOM.canvas || !DOM.gameContainer) {
                     error("DOM.dayNightIndicator, DOM.canvas, or DOM.gameContainer not found for day/night update.");
                     return;
                 }

                 // Only process if the game status is active
                 if (serverState?.status === 'active') {
                     const isNight = serverState.is_night; // Determine if it's night from server state

                     // Update the text indicator
                     DOM.dayNightIndicator.textContent = isNight ? 'Night' : 'Day';
                     DOM.dayNightIndicator.style.display = 'block'; // Make sure indicator is visible

                     // ---- Trigger the background update in the Renderer ----
                     // This function (exposed from Renderer) handles regeneration/transition
                     Renderer.updateGeneratedBackground(isNight);
                     // -----------------------------------------------------

                     // Add/Remove CSS class for potential night-mode specific styling (e.g., chat colors)
                     if (isNight) {
                         DOM.gameContainer.classList.add('night-mode');
                     } else {
                         DOM.gameContainer.classList.remove('night-mode');
                     }
                 } else {
                     // If game status is not 'active' (e.g., waiting, countdown, finished)
                     // Hide the day/night indicator and remove night-mode class
                     DOM.dayNightIndicator.style.display = 'none';
                     DOM.gameContainer.classList.remove('night-mode');

                     // Optional: You might want to ensure a default background state (e.g., day)
                     // is generated if the game resets or goes to a non-active state,
                     // although the initial generation triggers should handle most cases.
                     // If needed, uncomment the line below:
                     // Renderer.updateGeneratedBackground(false); // Force day background if not active?
                 }
             }

            function showGameOver(finalState) {
                if (!DOM.finalStatsDiv || !DOM.gameOverScreen) {
                     error("DOM.finalStatsDiv or DOM.gameOverScreen not found."); return;
                }
                const player = finalState?.players?.[appState.localPlayerId];
                let statsHtml = "Stats Unavailable";
                if (player) {
                     statsHtml = `
                        <div class="final-stat-item">
                             <strong>Score:</strong> ${player.score ?? 0}
                        </div>
                        <div class="final-stat-item">
                             <strong>Kills:</strong> ${player.kills ?? 0}
                        </div>
                     `;
                }
                DOM.finalStatsDiv.innerHTML = statsHtml;
                log("UI: Attempting to show simple game over screen.");
                 [DOM.mainMenuSection, DOM.multiplayerMenuSection, DOM.hostWaitSection,
                  DOM.joinCodeSection, DOM.gameArea].forEach(s => { if (s) s.style.display = 'none'; });
                DOM.gameOverScreen.style.display = 'block';
            }

            // Expose necessary UI functions
            return {
                showSection,
                updateStatus,
                updateHUD,
                addChatMessage,
                updateCountdown,
                updateDayNight,
                showGameOver
            };
        })(); // <-- This closes the UI IIFE

        // --- Network "Module" ---
        const Network = (() => {
            let reconnectTimer = null;

            function connect(onOpenCallback) {
                // Prevent multiple connections
                if (socket && socket.readyState !== WebSocket.CLOSED) {
                    log("Connect called but socket exists, state:", socket.readyState);
                    if (socket.readyState === WebSocket.OPEN && onOpenCallback) {
                        onOpenCallback(); // Call callback if already open
                    }
                    return;
                }
                clearTimeout(reconnectTimer); // Clear any pending reconnect attempts
                UI.updateStatus('Connecting...');
                log("Attempting WebSocket connection to:", WEBSOCKET_URL);

                try {
                    socket = new WebSocket(WEBSOCKET_URL);
                } catch (err) {
                    error("WebSocket creation failed:", err);
                    UI.updateStatus('Connection failed (WebSocket Error). Please refresh.', true);
                    return; // Stop connection attempt
                }


                socket.onopen = () => {
                    log('WebSocket connection established.');
                    appState.isConnected = true;
                    UI.updateStatus('Connected.');
                    // Ensure menu is shown only after connection
                    UI.showSection('main-menu-section');
                    if (onOpenCallback) onOpenCallback();
                };

                socket.onmessage = handleServerMessage; // Use the global handler

                socket.onerror = (event) => {
                    // Browsers often don't provide detailed error info here,
                    // rely on onclose for failure/reconnect logic.
                    error('WebSocket Error Event:', event);
                };

                socket.onclose = (event) => {
                    error(`WebSocket Closed: Code=${event.code}, Reason='${event.reason || 'N/A'}'`);
                    const wasConnected = appState.isConnected;
                    appState.isConnected = false;
                    socket = null; // Clear socket reference
                    // Reset game state but keep UI showing error/reconnecting message
                    Game.resetClientState(false);

                    if (event.code === 1000) { // Normal closure (e.g., user left game)
                        UI.updateStatus('Disconnected.');
                        UI.showSection('main-menu-section'); // Back to main menu
                    } else if (wasConnected) { // Abnormal closure after successful connection
                         UI.updateStatus('Connection lost. Reconnecting...', true);
                         scheduleReconnect();
                    } else { // Failed initial connection attempt
                         UI.updateStatus('Connection failed. Please check console and refresh.', true);
                         // Consider disabling buttons here?
                    }
                    // Stop game loop if it was running
                     if (appState.animationFrameId) {
                         cancelAnimationFrame(appState.animationFrameId);
                         appState.animationFrameId = null;
                         Input.cleanup(); // Clean input listeners if loop stops
                         log("Game loop stopped due to connection close.");
                     }
                };
            }

            function scheduleReconnect() {
                 clearTimeout(reconnectTimer);
                 log(`Scheduling reconnect in ${RECONNECT_DELAY}ms`);
                 reconnectTimer = setTimeout(() => {
                     log("Attempting reconnect...");
                     // Pass a callback to handle UI on successful reconnect
                     connect(() => {
                          UI.updateStatus('Reconnected.');
                          UI.showSection('main-menu-section'); // Go back to menu after reconnect
                     });
                 }, RECONNECT_DELAY);
            }

            function sendMessage(payload) {
                if (socket && socket.readyState === WebSocket.OPEN) {
                    try {
                        const msg = JSON.stringify(payload);
                        // log("Sending:", msg.substring(0, 150)); // Optional: Log sent message snippet
                        socket.send(msg);
                    } catch (err) {
                        error("Error sending message:", err, payload);
                    }
                } else {
                    error('Cannot send message, WebSocket not open or null.', payload);
                    // Maybe trigger reconnect attempt if socket is unexpectedly closed?
                    if (!socket || socket.readyState === WebSocket.CLOSED) {
                         // scheduleReconnect(); // Be careful not to spam reconnects
                    }
                }
            }

             function closeConnection(code = 1000, reason = "User action") {
                 clearTimeout(reconnectTimer); // Stop reconnect attempts on manual close
                 if (socket && socket.readyState === WebSocket.OPEN) {
                     log(`Closing WebSocket explicitly: ${reason} (Code: ${code})`);
                     socket.close(code, reason);
                 } else {
                    log("closeConnection called but socket not open or null.");
                 }
                 // Clear refs and state immediately, onclose handler will confirm
                 socket = null;
                 appState.isConnected = false;
             }

            return { connect, sendMessage, closeConnection };
        })();
        
        // --- Input Handling "Module" ---
        const Input = (() => {
             let keys = {};
             let lastShotTime = 0;
             let movementInterval = null;
             let mouseCanvasPos = { x: 0, y: 0 };
             let isMouseDown = false; // <<< ADDED: Tracks left mouse button state

             function setup() {
                cleanup(); // Ensure no duplicate listeners
                document.addEventListener('keydown', handleKeyDown);
                document.addEventListener('keyup', handleKeyUp);
                DOM.chatInput.addEventListener('keydown', handleChatEnter);

                if (DOM.canvas) { // Ensure canvas exists
                     DOM.canvas.addEventListener('mousemove', handleMouseMove);
                     DOM.canvas.addEventListener('mousedown', handleMouseDown); // Keep canvas listener for starting hold
                } else {
                     error("Input setup failed: Canvas element not found.");
                }
                // --- ADDED global mouseup listener ---
                document.addEventListener('mouseup', handleMouseUp);
                // -----------------------------------

                movementInterval = setInterval(sendMovementInput, INPUT_SEND_INTERVAL);
                log("Input listeners setup.");
             }

             function cleanup() {
                 document.removeEventListener('keydown', handleKeyDown);
                 document.removeEventListener('keyup', handleKeyUp);
                 DOM.chatInput.removeEventListener('keydown', handleChatEnter);

                 if (DOM.canvas) { // Check if canvas exists before removing
                      DOM.canvas.removeEventListener('mousemove', handleMouseMove);
                      DOM.canvas.removeEventListener('mousedown', handleMouseDown);
                 }
                 // --- REMOVE global mouseup listener ---
                 document.removeEventListener('mouseup', handleMouseUp);
                 // ------------------------------------

                 clearInterval(movementInterval);
                 movementInterval = null;
                 keys = {};
                 isMouseDown = false; // <<< ADDED: Reset mouse state on cleanup
                 mouseCanvasPos = { x: 0, y: 0 };
                 log("Input listeners cleaned up.");
             }


             function handleMouseMove(event) {
                 if (!DOM.canvas) return;
                 const rect = DOM.canvas.getBoundingClientRect();

                 // 1. Get Raw Mouse Position relative to the visual canvas element
                 const rawMouseX = event.clientX - rect.left;
                 const rawMouseY = event.clientY - rect.top;

                 // 2. Get Visual and Internal Dimensions
                 const visualWidth = rect.width;
                 const visualHeight = rect.height;
                 const internalWidth = DOM.canvas.width;  // The fixed 1600
                 const internalHeight = DOM.canvas.height; // The fixed 900

                 // 3. Calculate Scaling Factors (Avoid division by zero if canvas is hidden/tiny)
                 const scaleX = (visualWidth > 0) ? internalWidth / visualWidth : 1;
                 const scaleY = (visualHeight > 0) ? internalHeight / visualHeight : 1;

                 // 4. Calculate and Store Scaled Coordinates
                 mouseCanvasPos.x = rawMouseX * scaleX;
                 mouseCanvasPos.y = rawMouseY * scaleY;
             }
  

            // --- MODIFIED handleMouseDown: Set flag, don't call handleShooting ---
            function handleMouseDown(event) {
                if (document.activeElement === DOM.chatInput) return; // Ignore if typing chat
                if (event.button === 0) { // Check if left mouse button
                    isMouseDown = true; // Set the flag
                    // REMOVED: handleShooting();
                    event.preventDefault(); // Prevent text selection etc.
                }
            }
            // --- End modification ---

            // --- ADDED handleMouseUp function ---
            // Needs to listen globally in case mouse is released outside canvas
            function handleMouseUp(event) {
                // Check if left mouse button (button === 0) was released
                if (event.button === 0) {
                    isMouseDown = false; // Clear the flag
                }
            }
            // --- End added function ---

// --- MODIFIED handleKeyDown: Includes 'E' pushback and checks chat focus ---
             function handleKeyDown(e) {
                 // --- CRITICAL: Check if typing in chat FIRST ---
                 if (document.activeElement === DOM.chatInput) {
                     // If typing in chat, we DON'T want to process global game keys like movement, space, or 'e'.
                     // The 'Enter' key press for chat submission is handled by the specific 'handleChatEnter'
                     // listener attached directly to the chat input element. So, just return here.
                     return;
                 }
                 // --- END Chat Focus Check ---

                 // If not typing in chat, process game keys:
                 const key = e.key.toLowerCase();

                 // Track movement keys & spacebar flag (set flag only)
                 if (['w','a','s','d','arrowup','arrowdown','arrowleft','arrowright',' '].includes(key)) {
                    // Set flag if not already set (prevents repeated actions if needed later)
                    if (!keys[key]) {
                        keys[key] = true;
                    }
                    e.preventDefault(); // Prevent default browser scroll/actions for these keys
                    return; // Handled movement/space flag setting, no need to check 'e' below
                 }

                 // Handle 'E' key for pushback (Only if NOT typing in chat)
                 if (key === 'e') {
                     // Check game state and send message
                     if (appState.serverState?.status === 'active' && appState.isConnected) {
                         log("Sending player_pushback message."); // Log the action
                         Network.sendMessage({ type: 'player_pushback' });
                         e.preventDefault(); // Prevent default browser action for 'e' (e.g., find)
                     } else {
                         log("Pushback ('e') ignored: Game not active or not connected.");
                     }
                     return; // Handled 'e', done with this keydown event
                 }

                 // If the key wasn't a movement key, space, or 'e',
                 // no further game-specific action needed in this global handler.
             }
             // --- End modification ---

             // handleKeyUp remains unchanged - only clears movement/space flags
             function handleKeyUp(e) {
                 const key = e.key.toLowerCase();
                 // Clear flags for keys that represent a HOLD state
                 if (['w','a','s','d','arrowup','arrowdown','arrowleft','arrowright',' '].includes(key)) {
                     // Check if flag was actually set before clearing (optional but good practice)
                     if (keys[key]) {
                         keys[key] = false;
                     }
                 }
                 // 'e' is an event, not a state, so no need to clear a flag here.
             }

             // handleChatEnter remains unchanged - ADDED LOGGING
             // This listener is attached specifically to DOM.chatInput in Input.setup()
             function handleChatEnter(e) {
                 if (e.key === 'Enter') {
                     e.preventDefault(); // Prevent submitting a form if one existed or line break
                     log("Enter key detected in chat input."); // <<< ADDED LOGGING
                     Game.sendChatMessage(); // Attempt to send the chat message
                 }
             }

             // getMovementInputVector remains unchanged
             function getMovementInputVector() {
                 let dx = 0, dy = 0;
                 if (keys['w'] || keys['arrowup']) dy -= 1;
                 if (keys['s'] || keys['arrowdown']) dy += 1;
                 if (keys['a'] || keys['arrowleft']) dx -= 1;
                 if (keys['d'] || keys['arrowright']) dx += 1;

                 // Normalize diagonal movement (existing logic)
                 if (dx !== 0 && dy !== 0) {
                     const factor = 1 / Math.sqrt(2);
                     dx *= factor;
                     dy *= factor;
                 }
                 return { dx, dy };
             }

             // sendMovementInput remains unchanged
             function sendMovementInput() {
                 // Check game status before sending (existing logic)
                 // Ensure player is connected and game is active before sending movement
                 if (appState.mode !== 'menu' && appState.serverState?.status === 'active' && appState.isConnected) {
                    const moveVector = getMovementInputVector();
                    // It's okay to send {dx:0, dy:0} - server handles it.
                    Network.sendMessage({ type: 'player_move', direction: moveVector });
                 }
             }
            // handleShooting function remains UNCHANGED from your provided code
            // (It correctly handles cooldowns and sends target coords)
            function handleShooting() {
                // 1. Check Game Status
                if (appState.serverState?.status !== 'active') return;

                // 2. Calculate Actual Cooldown based on Ammo Type
                const playerState = appState.serverState?.players?.[appState.localPlayerId];
                const currentAmmo = playerState?.active_ammo_type || 'standard';
                let actualShootCooldown = SHOOT_COOLDOWN; // Base cooldown
                if (currentAmmo === 'ammo_rapid_fire') {
                    actualShootCooldown = SHOOT_COOLDOWN * RAPID_FIRE_COOLDOWN_MULTIPLIER;
                }

                // 3. Check Cooldown Timer
                const now = Date.now();
                if (now - lastShotTime < actualShootCooldown) {
                    return; // Cooldown active
                }
                lastShotTime = now; // Update shot time ONLY if allowed to fire

                // 4. --- AIM DIRECTION CALCULATION REMOVED FROM CLIENT ---

                // 5. Trigger Local Effects (Muzzle Flash)
                const playerRenderX = appState.renderedPlayerPos.x;
                const playerRenderY = appState.renderedPlayerPos.y;
                let flashDx = mouseCanvasPos.x - playerRenderX;
                let flashDy = mouseCanvasPos.y - playerRenderY;
                const flashMag = Math.sqrt(flashDx*flashDx + flashDy*flashDy);
                if (flashMag > 0.01) {
                    flashDx /= flashMag;
                    flashDy /= flashMag;
                } else {
                    flashDx = 0; flashDy = -1;
                }
                localPlayerMuzzleFlash.active = true;
                localPlayerMuzzleFlash.endTime = performance.now() + 75;
                localPlayerMuzzleFlash.aimDx = flashDx;
                localPlayerMuzzleFlash.aimDy = flashDy;

                // 6. Send Shoot Message with TARGET COORDINATES
                log("Sending shoot message with Target Coords:", mouseCanvasPos);
                Network.sendMessage({
                    type: 'player_shoot',
                    target: { x: mouseCanvasPos.x, y: mouseCanvasPos.y }
                });

                // Optional: Play shoot sound locally
                // Game.playSound('shoot');
            }

            // --- ADDED helper function ---
            function isShootHeld() {
                return keys[' '] || isMouseDown; // Return true if Space or Left Mouse is down
            }
            // -----------------------------

            // --- ADDED functions to the return statement ---
            return {
                setup,
                cleanup,
                getMovementInputVector,
                handleShooting, // Expose the shooting function itself
                isShootHeld     // Expose the state check helper
            };

        })(); // End Input IIFE

        // --- Rendering "Module" ---
        const Renderer = (() => {
            const ctx = DOM.ctx;
            const lerpFactor = parseFloat(getCssVar('--lerp-factor')) || 0.2;

             // --- Offscreen Canvas Setup ---
            const offscreenCanvas = document.createElement('canvas');
            offscreenCanvas.width = CANVAS_WIDTH;
            offscreenCanvas.height = CANVAS_HEIGHT;
            const offscreenCtx = offscreenCanvas.getContext('2d', { alpha: false }); // Use its context
            let isBackgroundReady = false; // Flag: Has the initial background been generated?
            let currentBackgroundIsNight = null; // Track what the offscreenCanvas currently holds (null, true for night, false for day)

            // --- Transition State ---
            let isTransitioningBackground = false;
            let transitionStartTime = 0;
            const BACKGROUND_FADE_DURATION_MS = 1000; // 1 second fade
            const oldOffscreenCanvas = document.createElement('canvas'); // Temp canvas for fade
            oldOffscreenCanvas.width = CANVAS_WIDTH;
            oldOffscreenCanvas.height = CANVAS_HEIGHT;
            const oldOffscreenCtx = oldOffscreenCanvas.getContext('2d', { alpha: false });
            // -------------------------

            // Base background colors for generation
            const dayBaseColor = '#8FBC8F'; // DarkSeaGreen (or your choice)
            const nightBaseColor = '#3E2723'; // Dark Brown/Grey (or getCssVar('--bg-color'))

            // --- CACHE ALL CSS Variables Used for Drawing ---
            const fontFamily = getCssVar('--font-family') || 'monospace';
            // Damage Text
            const damageTextColor = getCssVar('--damage-text-color') || '#FFFFFF';
            const damageTextCritColor = getCssVar('--damage-text-crit-color') || '#FFD700';
            const damageTextFontSize = parseInt(getCssVar('--damage-text-font-size'), 10) || 14;
            const damageTextCritFontSize = parseInt(getCssVar('--damage-text-crit-font-size'), 10) || 18;
            // Player / Enemy Colors (base character)
            const playerColor = getCssVar('--player-color') || '#DC143C'; // Used for health bar low, maybe torso
            const otherPlayerColor = getCssVar('--other-player-color') || '#4682B4'; // Maybe torso
            const playerHeadColor = '#D2B48C'; // Assuming constant
            const playerHelmetColor = '#CCCCCC'; // Assuming constant
            const playerSlitColor = '#222222'; // Assuming constant
            const playerCoatColor = '#8B4513'; // Assuming constant
            const playerBootColor = '#222222'; // Assuming constant
            const playerGunColor = '#444444'; // Assuming constant
            const playerTorsoSelfColor = '#A00000'; // Specific for self
            const playerTorsoOtherColor = '#004488'; // Specific for other
            const enemyColor = getCssVar('--enemy-color') || '#556B2F'; // Fallback if needed
            const enemySkinColor = '#D2B48C'; // Assuming constant
            const enemyCoatColor = '#8B4513'; // Assuming constant
            const enemyTorsoChaserColor = '#2F4F4F'; // Assuming constant
            const enemyTorsoShooterColor = '#4682B4'; // Assuming constant
            const enemyBootColor = '#222222'; // Assuming constant
            const enemyCapColor = '#111111'; // Assuming constant
            const enemyHitFlashColor = 'rgba(255, 255, 255, 0.7)'; // Assuming constant
            // Bullets
            const bulletPlayerColor = getCssVar('--bullet-player-color') || '#FFEB3B';
            const bulletEnemyColor = getCssVar('--bullet-enemy-color') || '#C0C0C0';
            // Health & Armor Bars
            const healthBarBg = getCssVar('--health-bar-bg') || '#444';
            const healthBarHigh = getCssVar('--health-bar-high') || '#66bb6a';
            const healthBarMedium = getCssVar('--health-bar-medium') || '#FFD700';
            const healthBarLow = playerColor; // Use cached playerColor '#DC143C'
            const armorBarColor = getCssVar('--powerup-armor') || '#C0C0C0'; // Use powerup color
            // Powerups
            const powerupHealthColor = getCssVar('--powerup-health') || 'lime';
            const powerupGunColor = getCssVar('--powerup-gun') || 'fuchsia';
            const powerupSpeedColor = getCssVar('--powerup-speed') || 'aqua';
            const powerupArmorColor = armorBarColor; // Use same cached color '#C0C0C0';
            const powerupShotgunColor = '#FFA500'; // Specific colors
            const powerupSlugColor = '#A0522D';
            const powerupRapidColor = '#FFFF00';
            const powerupScoreColor = '#FFD700';
            const powerupDefaultColor = '#888'; // Fallback
            // Speech Bubbles
            const playerSpeechBubbleColor = getCssVar('--text-color') || '#FFF8DC';
            const playerSpeechBubbleBg = 'rgba(0, 0, 0, 0.7)';
            const playerSpeechBubbleOutline = 'rgba(200, 200, 200, 0.5)';
            const enemySpeechBubbleColor = '#FFAAAA';
            const enemySpeechBubbleBg = 'rgba(70, 0, 0, 0.7)';
            const enemySpeechBubbleOutline = 'rgba(200, 150, 150, 0.5)';
            // Campfire
            const campfireAuraColor = getCssVar('--campfire-aura-color') || 'rgba(255, 255, 0, 0.15)';
            const campfireStickColor = '#8B4513'; // Constant
            const campfireFlameOuterColor = 'rgba(255, 165, 0, 0.6)'; // Constant
            const campfireFlameInnerColor = 'rgba(255, 255, 0, 0.7)'; // Constant
            // Muzzle Flash
            const muzzleFlashColor = 'rgba(255, 220, 50, 0.9)'; // Constant
            const IDLE_BOB_SPEED = 600; // Divisor for performance.now() - Higher is slower
            const IDLE_BOB_AMPLITUDE = 3; // Max pixels to move up/down

            const dustyPlayerSelfColor = '#8B4513';    // Saddle Brown (like worn leather/dusty coat)
            const dustyPlayerOtherColor = '#556B2F';   // Dark Olive Green (like a drabber, dusty uniform/coat)
            const dustyHitFlashColor = 'rgba(255, 215, 0, 0.6)'; // Dusty Gold/Yellow Flash
            // --- Screen Shake State ---
            let currentShakeMagnitude = 0;
            let shakeEndTime = 0;

            function triggerShake(magnitude, durationMs) {
                const now = performance.now();
                const newEndTime = now + durationMs;
                if (magnitude >= currentShakeMagnitude || newEndTime >= shakeEndTime) {
                     currentShakeMagnitude = Math.max(magnitude, currentShakeMagnitude);
                     shakeEndTime = Math.max(newEndTime, shakeEndTime);
                }
            }

            // --- Helper to draw rounded rectangles ---
            function drawRoundedRect(x, y, width, height, radius) {
                if (width < 2 * radius) radius = width / 2;
                if (height < 2 * radius) radius = height / 2;
                ctx.beginPath();
                ctx.moveTo(x + radius, y);
                ctx.arcTo(x + width, y, x + width, y + height, radius);
                ctx.arcTo(x + width, y + height, x, y + height, radius);
                ctx.arcTo(x, y + height, x, y, radius);
                ctx.arcTo(x, y, x + width, y, radius);
                ctx.closePath();
            }

            const ENEMY_TYPE_CHASER = 'chaser';
            const ENEMY_TYPE_SHOOTER = 'shooter';
            const BULLET_TYPE_STANDARD = 'standard';
            const BULLET_TYPE_STANDARD_ENEMY = 'standard_enemy';
            const PLAYER_STATUS_ALIVE = 'alive'; // Assuming these constants exist globally
            const PLAYER_STATUS_DOWN = 'down';
            const PLAYER_STATUS_DEAD = 'dead';
            const PLAYER_DEFAULTS = { width: 25, height: 48, max_health: 100, base_speed: 150 }; // From global
            const ENEMY_DEFAULTS = { width: 25, height: 25, max_health: 50 }; // From global
            const BULLET_DEFAULTS = { radius: 4 }; // From global
            const POWERUP_DEFAULTS = { size: 20 }; // From global


            function drawDamageTexts(damageTexts) {
                if (!damageTexts) return;
                const now = performance.now();
                const normalColor = damageTextColor; // Use cached
                const critColor = damageTextCritColor; // Use cached
                const pulseDuration = 250;
                const pulseMaxSizeIncrease = 4;
                const normalFontSize = damageTextFontSize; // Use cached
                const critFontSize = damageTextCritFontSize; // Use cached

                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';

                Object.values(damageTexts).forEach(dmgText => {
                    if (!dmgText) return;
                    const x = dmgText.x ?? 0; const y = dmgText.y ?? 0;
                    const text = dmgText.text ?? '?'; const isCrit = dmgText.is_crit ?? false;
                    const spawnTime = dmgText.spawn_time ? dmgText.spawn_time * 1000 : now;
                    const timeSinceSpawn = now - spawnTime;
                    let currentFontSize = isCrit ? critFontSize : normalFontSize;
                    let currentFillColor = isCrit ? critColor : normalColor;

                    if (isCrit && timeSinceSpawn < pulseDuration) {
                        const pulseProgress = Math.sin((timeSinceSpawn / pulseDuration) * Math.PI);
                        currentFontSize += pulseProgress * pulseMaxSizeIncrease;
                    }
                    ctx.font = `bold ${Math.round(currentFontSize)}px ${fontFamily}`; // Use cached font
                    ctx.fillStyle = currentFillColor;
                    ctx.fillText(text, x, y); // Removed shadows
                });
            }

            function drawCampfire(campfireData) {
                if (!campfireData || !campfireData.active) return;
                const x = campfireData.x ?? CANVAS_WIDTH / 2;
                const y = campfireData.y ?? CANVAS_HEIGHT / 2;
                const radius = campfireData.radius ?? 0;
                if (radius <= 0) return;

                const auraColor = campfireAuraColor; // Use cached
                const stickColor = campfireStickColor; // Use cached
                const stickWidth = 20; const stickHeight = 4;
                const flameColorOuter = campfireFlameOuterColor; // Use cached
                const flameColorInner = campfireFlameInnerColor; // Use cached
                const flameWidth = 15; const flameHeight = 25;

                ctx.save();
                ctx.fillStyle = auraColor;
                ctx.beginPath(); ctx.arc(x, y, radius, 0, Math.PI * 2); ctx.fill();
                const stickOffsetY = 5;
                ctx.fillStyle = stickColor;
                ctx.translate(x, y + stickOffsetY);
                ctx.rotate(Math.PI / 5); ctx.fillRect(-stickWidth / 2, -stickHeight / 2, stickWidth, stickHeight); ctx.rotate(-Math.PI / 5);
                ctx.rotate(-Math.PI / 6); ctx.fillRect(-stickWidth / 2, -stickHeight / 2, stickWidth, stickHeight); ctx.rotate(Math.PI / 6);
                ctx.translate(-x, -(y + stickOffsetY));
                const flameOffsetY = -10; const flameCenterX = x; const flameCenterY = y + flameOffsetY;
                ctx.fillStyle = flameColorOuter;
                ctx.beginPath(); ctx.ellipse(flameCenterX, flameCenterY, flameWidth / 2, flameHeight / 2, 0, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = flameColorInner;
                ctx.beginPath(); ctx.ellipse(flameCenterX, flameCenterY - 3, flameWidth / 3, flameHeight / 3, 0, 0, Math.PI * 2); ctx.fill();
                ctx.restore();
            }

            function drawMuzzleFlash(playerX, playerY, aimDx, aimDy) {
                const flashSizeBase = 10; const flashSizeVariation = 5;
                const flashColor = muzzleFlashColor; // Use cached
                const offsetDistance = 12;
                const flashX = playerX + aimDx * offsetDistance;
                const flashY = playerY + aimDy * offsetDistance;
                const flashSize = flashSizeBase + Math.random() * flashSizeVariation;
                ctx.fillStyle = flashColor;
                ctx.beginPath(); ctx.arc(flashX, flashY, flashSize / 2, 0, Math.PI * 2); ctx.fill();
            }

            function drawDamageVignette(intensity) {
                if (intensity <= 0) return;
                ctx.save();
                const outerRadius = Math.sqrt(CANVAS_WIDTH * CANVAS_WIDTH + CANVAS_HEIGHT * CANVAS_HEIGHT) / 2;
                const gradient = ctx.createRadialGradient(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, 0, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, outerRadius);
                const redAlpha = 0.4 * intensity;
                gradient.addColorStop(0, 'rgba(255, 0, 0, 0)');
                gradient.addColorStop(0.75, 'rgba(255, 0, 0, 0)');
                gradient.addColorStop(1, `rgba(255, 0, 0, ${redAlpha.toFixed(2)})`); // playerColor could potentially be used here if desired theme
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                ctx.restore();
            }

            function drawEnemySpeechBubbles(enemiesToRender) {
                const now = performance.now();
                const bubbleFont = 'italic 11px ' + fontFamily; // Use cached
                const bubbleColor = enemySpeechBubbleColor; // Use cached
                const bubbleBgColor = enemySpeechBubbleBg; // Use cached
                const bubbleOutlineColor = enemySpeechBubbleOutline; // Use cached
                const cornerRadius = 4; const textPadding = 3; const bubbleOffset = 20;
                ctx.font = bubbleFont; ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
                const enemyIdsToRemove = [];

                for (const enemyId in activeEnemyBubbles) {
                    const bubble = activeEnemyBubbles[enemyId];
                    if (now >= bubble.endTime) { enemyIdsToRemove.push(enemyId); continue; }
                    const enemy = enemiesToRender?.[enemyId];
                    if (enemy && enemy.health > 0) {
                        const enemyDrawX = enemy.x; const enemyDrawY = enemy.y;
                        const enemyHeight = enemy.height ?? ENEMY_DEFAULTS.height;
                        const bubbleY = enemyDrawY - (enemyHeight / 2) - bubbleOffset;
                        const textMetrics = ctx.measureText(bubble.text);
                        const textWidth = textMetrics.width; const boxWidth = textWidth + textPadding * 2;
                        const approxFontHeight = 11; const boxHeight = approxFontHeight + textPadding * 2;
                        const boxX = enemyDrawX - boxWidth / 2; const boxY = bubbleY - boxHeight;

                        ctx.fillStyle = bubbleBgColor; drawRoundedRect(boxX, boxY, boxWidth, boxHeight, cornerRadius); ctx.fill();
                        ctx.strokeStyle = bubbleOutlineColor; ctx.lineWidth = 1; ctx.stroke();
                        ctx.fillStyle = bubbleColor; ctx.fillText(bubble.text, enemyDrawX, bubbleY - textPadding);
                    } else { enemyIdsToRemove.push(enemyId); }
                }
                enemyIdsToRemove.forEach(id => { delete activeEnemyBubbles[id]; });
            }

            function drawSpeechBubbles(playersToRender) {
                const now = performance.now();
                const bubbleFont = 'bold 12px ' + fontFamily; // Use cached
                const bubbleColor = playerSpeechBubbleColor; // Use cached
                const bubbleBgColor = playerSpeechBubbleBg; // Use cached
                const bubbleOutlineColor = playerSpeechBubbleOutline; // Use cached
                const cornerRadius = 5; const textPadding = 4; const bubbleOffset = 30;
                ctx.font = bubbleFont; ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
                const playerIdsToRemove = [];

                for (const playerId in activeSpeechBubbles) {
                    const bubble = activeSpeechBubbles[playerId];
                    if (now >= bubble.endTime) { playerIdsToRemove.push(playerId); continue; }
                    const player = playersToRender?.[playerId];
                    if (player && player.player_status !== PLAYER_STATUS_DEAD && player.health > 0) {
                        const playerDrawX = (playerId === appState.localPlayerId) ? appState.renderedPlayerPos.x : player.x;
                        const playerDrawY = (playerId === appState.localPlayerId) ? appState.renderedPlayerPos.y : player.y;
                        const playerHeight = player.height ?? PLAYER_DEFAULTS.height;
                        const bubbleY = playerDrawY - (playerHeight / 2) - bubbleOffset;
                        const textMetrics = ctx.measureText(bubble.text);
                        const textWidth = textMetrics.width; const boxWidth = textWidth + textPadding * 2;
                        const approxFontHeight = 12; const boxHeight = approxFontHeight + textPadding * 2;
                        const boxX = playerDrawX - boxWidth / 2; const boxY = bubbleY - boxHeight;

                        ctx.fillStyle = bubbleBgColor; drawRoundedRect(boxX, boxY, boxWidth, boxHeight, cornerRadius); ctx.fill();
                        ctx.strokeStyle = bubbleOutlineColor; ctx.lineWidth = 1; ctx.stroke();
                        ctx.fillStyle = bubbleColor; ctx.fillText(bubble.text, playerDrawX, bubbleY - textPadding);
                    }
                }
                playerIdsToRemove.forEach(id => { delete activeSpeechBubbles[id]; });
            }

            // --- REWRITTEN drawSnake function ---
            function drawSnake() {
                // Check if the snake has any segments first
                if (snake.segments.length === 0) return;

                const snakeLineColor = '#261a0d'; // Dark brown

                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.strokeStyle = snakeLineColor;
                ctx.lineWidth = 1.5; // Reduced from 3 to 1.5 (50% smaller)

                ctx.beginPath();

                // --- Calculate Tail Position with Max Amplitude ---
                const tailSegment = snake.segments[snake.segments.length - 1];
                const tailAmplitudeFactor = 1.2;
                const tailY = snake.baseY + Math.sin(tailSegment.x * snake.frequency) * (snake.amplitude * tailAmplitudeFactor);
                ctx.moveTo(tailSegment.x, tailY);

                // --- Draw Segments with Decreasing Amplitude Towards Head ---
                for (let i = snake.segments.length - 2; i >= 0; i--) {
                    const segment = snake.segments[i];
                    const progress = i / (snake.segments.length - 1);
                    const segmentAmplitudeFactor = 1.0 + (progress * progress * 0.5);
                    const segmentY = snake.baseY + Math.sin(segment.x * snake.frequency) * (snake.amplitude * segmentAmplitudeFactor);
                    ctx.lineTo(segment.x, segmentY);
                }

                // --- End at the Current Head Position ---
                ctx.lineTo(snake.x, snake.y);

                // --- Draw the entire path ---
                ctx.stroke();
            }
            

            // --- Drawing Entities ---
            function drawPlayers(players) {
                 // This function remains the same - it calls the updated drawPlayerCharacter
                 if (!players) return;
                 Object.values(players).forEach(player => {
                     if (!player || player.player_status === PLAYER_STATUS_DEAD) return; // Use constant
                     const isSelf = player.id === appState.localPlayerId;
                     const playerStatus = player.player_status || PLAYER_STATUS_ALIVE; // Use constant
                     const drawX = isSelf ? appState.renderedPlayerPos.x : player.x;
                     const drawY = isSelf ? appState.renderedPlayerPos.y : player.y;
                     const width = player.width ?? PLAYER_DEFAULTS.width;
                     const height = player.height ?? PLAYER_DEFAULTS.height;
                     const maxHealth = player.max_health ?? PLAYER_DEFAULTS.max_health;
                     const currentArmor = player.armor ?? 0;
                     let isDown = (playerStatus === PLAYER_STATUS_DOWN); // Use constant
                     let alpha = isDown ? 0.4 : 1.0;

                     ctx.save();
                     ctx.globalAlpha = alpha;
                     // Get aim direction for local player muzzle flash/gun angle
                     const aimDx = isSelf ? localPlayerMuzzleFlash.aimDx : 0;
                     const aimDy = isSelf ? localPlayerMuzzleFlash.aimDy : 0;
                     // Call the updated drawing function below
                     drawPlayerCharacter(drawX, drawY, width, height, isSelf, player, aimDx, aimDy);
                     ctx.restore();

                     // Only draw bars if alive
                     if (playerStatus === PLAYER_STATUS_ALIVE) {
                         drawHealthBar(drawX, drawY, width, player.health, maxHealth);
                         if (currentArmor > 0) drawArmorBar(drawX, drawY, width, currentArmor);
                     }
                 });
             }

            function generateBackground(targetIsNight) {
                console.log(`[Renderer] Generating background for ${targetIsNight ? 'Night' : 'Day'}`);
                const baseColor = targetIsNight ? nightBaseColor : dayBaseColor;

                // 1. Fill base color
                offscreenCtx.fillStyle = baseColor;
                offscreenCtx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                // 2. Draw details (Patches, Grass Tufts, etc.)
                if (!targetIsNight) {
                    // Draw Day Details (MAKE MORE OBVIOUS)
                    // Patches
                    const numPatches = 100; // Fewer, but make them bigger/more opaque
                    for (let i = 0; i < numPatches; i++) {
                        const x = Math.random() * CANVAS_WIDTH;
                        const y = Math.random() * CANVAS_HEIGHT;
                        const radius = Math.random() * 40 + 15; // Larger: 15 to 55 radius
                        // Darker Brown - More Contrast
                        const r = 101 + Math.random() * 20 - 10;
                        const g = 67 + Math.random() * 20 - 10;
                        const b = 33 + Math.random() * 20 - 10;
                        const alpha = Math.random() * 0.25 + 0.20; // More Opaque: 20% to 45%
                        offscreenCtx.fillStyle = `rgba(${r.toFixed(0)}, ${g.toFixed(0)}, ${b.toFixed(0)}, ${alpha.toFixed(2)})`;
                        offscreenCtx.beginPath();
                        offscreenCtx.arc(x, y, radius, 0, Math.PI * 2);
                        offscreenCtx.fill();
                    }
                    // Grass Tufts
                    const numTufts = 150; // Fewer but thicker/brighter
                    offscreenCtx.lineWidth = 3; // Thicker
                    offscreenCtx.strokeStyle = 'rgba(34, 139, 34, 0.6)'; // Brighter ForestGreen, More Opaque (60%)
                    for (let i = 0; i < numTufts; i++) {
                        const x = Math.random() * CANVAS_WIDTH;
                        const y = Math.random() * CANVAS_HEIGHT;
                        offscreenCtx.beginPath();
                        offscreenCtx.moveTo(x, y);
                        offscreenCtx.lineTo(x + (Math.random()*6-3), y - (Math.random()*6 + 5)); // Slightly longer tufts
                        offscreenCtx.stroke();
                    }

                } else {
                    // Draw Night Details (MAKE MORE OBVIOUS)
                    // Darker Patches
                    const numPatches = 60; // Fewer, larger, more opaque
                    for (let i = 0; i < numPatches; i++) {
                        const x = Math.random() * CANVAS_WIDTH;
                        const y = Math.random() * CANVAS_HEIGHT;
                        const radius = Math.random() * 50 + 20; // Larger: 20 to 70 radius
                        const alpha = Math.random() * 0.15 + 0.1; // More Opaque: 10% to 25%
                        offscreenCtx.fillStyle = `rgba(5, 2, 2, ${alpha.toFixed(2)})`; // Very dark near-black patches
                        offscreenCtx.beginPath();
                        offscreenCtx.arc(x, y, radius, 0, Math.PI * 2);
                        offscreenCtx.fill();
                    }
                    // Stars
                    const numStars = 150; // More stars
                    offscreenCtx.fillStyle = 'rgba(255, 255, 240, 0.8)'; // Brighter Ivory, More Opaque (80%)
                    for (let i = 0; i < numStars; i++) {
                        const starX = Math.random() * CANVAS_WIDTH;
                        const starY = Math.random() * CANVAS_HEIGHT; // Allow stars lower down too
                        const starR = Math.random() * 1.5 + 0.5; // Slightly larger stars (0.5 to 2.0)
                        offscreenCtx.fillRect(starX, starY, starR, starR);
                    }
                }

                console.log("[Renderer] Background generation complete.");
                currentBackgroundIsNight = targetIsNight;
            }

            // --- Trigger Background Update Function ---
            // This needs to be called from outside the Renderer when needed
            function updateGeneratedBackground(targetIsNight) {
                // Only regenerate if the desired state is different from the current one
                if (targetIsNight === currentBackgroundIsNight && isBackgroundReady) {
                    // console.log("[Renderer] Background update skipped, already correct state.");
                    return;
                }

                console.log(`[Renderer] Received request to update background to ${targetIsNight ? 'Night' : 'Day'}.`);

                // --- Handle Transition ---
                if (isBackgroundReady) { // Only transition if we have a previous background
                    console.log("[Renderer] Starting background transition...");
                    isTransitioningBackground = true;
                    transitionStartTime = performance.now();
                    // Copy the *current* offscreenCanvas to the *old* one
                    oldOffscreenCtx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT); // Clear old canvas first
                    oldOffscreenCtx.drawImage(offscreenCanvas, 0, 0);
                    // Now, generate the *new* background onto the main offscreenCanvas
                    generateBackground(targetIsNight);
                } else {
                    // First time generation, no transition needed
                    console.log("[Renderer] First background generation.");
                    generateBackground(targetIsNight);
                    isBackgroundReady = true; // Mark background as ready AFTER first generation
                    console.log("[Renderer] isBackgroundReady set to true.");
                }
            }


             // --- UPDATED drawPlayerCharacter Function ---
             function drawPlayerCharacter(x, y, w, h, isSelf, playerState, aimDx, aimDy) {
                 // --- Color Definitions ---
                 const ironHelmetColor = '#3d3d3d';
                 const ironHelmetHighlight = '#666666';
                 const ironHelmetShadow = '#1a1a1a';
                 const beltColor = '#412a19';    // Dark Brown Belt
                 const bootColor = '#241c1c';    // Very Dark Brown/Black Boots
                 const backgroundShadowColor = 'rgba(0,0,0,0.3)';
                 const simpleChestPlateColor = '#777777'; // Grey Chest plate
                 const chestPlateHighlight = '#999999';
                 const slitColor = '#000000';
                 const gunColor = '#444444';     // Grey Gun
                 // Note: hitFlashOverlayColor is replaced by dustyHitFlashColor later
                 const sparkColors = ['rgba(255, 100, 0, 0.8)', 'rgba(255, 165, 0, 0.9)', 'rgba(255, 220, 50, 0.7)']; // Keep sparks orange/yellow

                 // --- State variables ---
                 const justHit = playerState?.hit_flash_this_tick ?? false;
                 const isIdle = (playerState?.input_vector?.dx ?? 0) === 0 && (playerState?.input_vector?.dy ?? 0) === 0;
                 const isMoving = !isIdle;

                 // --- Bobbing/Breathing ---
                 const IDLE_BOB_SPEED = 800;
                 const IDLE_BOB_AMPLITUDE = 1.2;
                 const time = performance.now();
                 const bobOffset = isIdle ? Math.sin(time / IDLE_BOB_SPEED) * IDLE_BOB_AMPLITUDE : 0;

                 // --- Dimensions ---
                 const helmetHeight = h * 0.30;
                 const helmetWidth = w * 0.95;
                 const slitHeight = helmetHeight * 0.15;
                 const slitWidth = helmetWidth * 0.8;
                 const neckGuardHeight = h * 0.06;
                 const shoulderPlateWidth = w * 1.25;
                 const shoulderPlateHeight = h * 0.10;
                 const chestPlateHeight = h * 0.30;
                 const chestPlateWidth = w * 0.9;
                 const armWidth = w * 0.2;
                 const armLength = h * 0.4;
                 const coatHeight = h * 0.50;
                 const coatWidthVisual = shoulderPlateWidth * 1.1;
                 const beltHeight = h * 0.05;
                 const pantsHeight = h * 0.35;
                 const bootHeight = h * 0.10;
                 const bootWidth = w * 0.32;
                 const bootSpacing = w * 0.4;

                 // --- Y Position Calculation ---
                 const totalDrawHeight = helmetHeight + neckGuardHeight + chestPlateHeight + pantsHeight + bootHeight;
                 const topOffset = h * 0.5;
                 const helmetTopY = y - topOffset + bobOffset;
                 const helmetBottomY = helmetTopY + helmetHeight;
                 const slitY = helmetTopY + helmetHeight * 0.4;
                 const neckGuardTopY = helmetBottomY - 3;
                 const neckGuardBottomY = neckGuardTopY + neckGuardHeight;
                 const shoulderTopY = neckGuardBottomY - 2;
                 const shoulderBottomY = shoulderTopY + shoulderPlateHeight;
                 const chestPlateTopY = shoulderTopY + shoulderPlateHeight * 0.15;
                 const chestPlateBottomY = chestPlateTopY + chestPlateHeight;
                 const armTopY = shoulderTopY + shoulderPlateHeight * 0.2;
                 const coatTopY = shoulderTopY + 2;
                 const coatBottomY = coatTopY + coatHeight;
                 const beltY = coatTopY + coatHeight * 0.55;
                 const pantsTopY = beltY + beltHeight * 0.4;
                 const pantsBottomY = pantsTopY + pantsHeight;
                 const bootTopY = pantsBottomY - 5;
                 const bootBottomY = bootTopY + bootHeight;

                 // --- Define the Distinguishing Dusty Color based on isSelf ---
                 // Uses the 'dusty' color variables assumed to be defined in Renderer scope
                 const distinguishingColor = isSelf ? dustyPlayerSelfColor : dustyPlayerOtherColor;

                 // --- Start Drawing (Order matters for layering) ---
                 ctx.save();

                 // 1. Shadow
                 ctx.beginPath();
                 const shadowY = bootBottomY + 5;
                 ctx.ellipse(x, shadowY, w * 0.45, h * 0.05, 0, 0, Math.PI * 2);
                 ctx.fillStyle = backgroundShadowColor;
                 ctx.fill();

                 // 2. Pants --- USE DUSTY COLOR ---
                 ctx.fillStyle = distinguishingColor;
                 const legWidth = w * 0.4;
                 ctx.fillRect(x - w * 0.45, pantsTopY, legWidth, pantsHeight);
                 ctx.fillRect(x + w * 0.05, pantsTopY, legWidth, pantsHeight);

                 // 3. Boots (with Stepping)
                 ctx.fillStyle = bootColor; // Keep boots dark
                 if (isMoving) {
                     const stepDuration = 250;
                     const stepPhase = Math.floor(time / stepDuration) % 2;
                     if (stepPhase === 0) { // Left boot steps
                         ctx.fillRect(x - bootSpacing - bootWidth/2, bootTopY - 1, bootWidth, bootHeight);
                         ctx.fillRect(x + bootSpacing - bootWidth/2, bootTopY, bootWidth, bootHeight);
                     } else { // Right boot steps
                         ctx.fillRect(x - bootSpacing - bootWidth/2, bootTopY, bootWidth, bootHeight);
                         ctx.fillRect(x + bootSpacing - bootWidth/2, bootTopY - 1, bootWidth, bootHeight);
                     }
                 } else { // Idle
                     ctx.fillRect(x - bootSpacing - bootWidth/2, bootTopY, bootWidth, bootHeight);
                     ctx.fillRect(x + bootSpacing - bootWidth/2, bootTopY, bootWidth, bootHeight);
                 }

                 // 4. Coat --- USE DUSTY COLOR ---
                 ctx.fillStyle = distinguishingColor;
                 ctx.beginPath();
                 ctx.moveTo(x - coatWidthVisual / 2, coatTopY);
                 ctx.lineTo(x + coatWidthVisual / 2, coatTopY);
                 ctx.lineTo(x + w * 0.70, coatBottomY);
                 ctx.lineTo(x - w * 0.70, coatBottomY);
                 ctx.closePath();
                 ctx.fill();

                 // 5. Belt
                 ctx.fillStyle = beltColor; // Keep belt brown
                 ctx.fillRect(x - w * 0.65, beltY - beltHeight/2, w * 1.3, beltHeight);

                 // 6. Chest Plate
                 ctx.fillStyle = simpleChestPlateColor; // Keep chest plate grey
                 ctx.fillRect(x - chestPlateWidth/2, chestPlateTopY, chestPlateWidth, chestPlateHeight);
                 // Highlight
                 ctx.fillStyle = chestPlateHighlight;
                 ctx.fillRect(x - chestPlateWidth/2 + 5, chestPlateTopY + 5, chestPlateWidth - 10, 3);

                 // 7. Shoulder Plates
                 ctx.fillStyle = ironHelmetColor; // Keep shoulders metallic
                 ctx.fillRect(x - shoulderPlateWidth/2, shoulderTopY, shoulderPlateWidth, shoulderPlateHeight);
                 // Highlight
                 ctx.fillStyle = ironHelmetHighlight;
                 ctx.fillRect(x - shoulderPlateWidth/2 + 3, shoulderTopY + 2, shoulderPlateWidth - 6, 2);

                 // 8. Arms --- USE DUSTY COLOR ---
                 ctx.fillStyle = distinguishingColor;
                 ctx.fillRect(x - shoulderPlateWidth * 0.45, armTopY, armWidth, armLength);
                 ctx.fillRect(x + shoulderPlateWidth * 0.45 - armWidth, armTopY, armWidth, armLength);

                 // 9. Neck Guard
                 ctx.fillStyle = ironHelmetColor; // Keep neck guard metallic
                 ctx.fillRect(x - helmetWidth * 0.4, neckGuardTopY, helmetWidth * 0.8, neckGuardHeight);

                 // 10. Helmet
                 ctx.fillStyle = ironHelmetColor; // Keep helmet metallic
                 ctx.fillRect(x - helmetWidth/2, helmetTopY, helmetWidth, helmetHeight);
                 // Highlight
                 ctx.fillStyle = ironHelmetHighlight;
                 ctx.fillRect(x - helmetWidth/2, helmetTopY, helmetWidth, 3);
                 // Shadow
                 ctx.fillStyle = ironHelmetShadow;
                 ctx.fillRect(x - helmetWidth / 2 + 1, helmetTopY + 3, helmetWidth - 2, 2);

                 // 11. Slit
                 ctx.fillStyle = slitColor; // Keep slit black
                 ctx.fillRect(x - slitWidth/2, slitY, slitWidth, slitHeight);

                 // 12. Gun
                 if (isSelf && aimDx !== 0 && aimDy !== 0) {
                     const gunLevel = playerState?.gun ?? 1;
                     const gunLengthBase = 12;
                     const gunLengthBonus = (gunLevel - 1) * 3;
                     const gunLength = gunLengthBase + gunLengthBonus;
                     const gunThickness = 5 + (gunLevel - 1) * 0.5;
                     const gunOriginY = armTopY + armLength * 0.4;
                     const gunOriginXOffset = w * 0.1;

                     ctx.save();
                     ctx.translate(x, gunOriginY);
                     const angle = Math.atan2(aimDy, aimDx);
                     ctx.rotate(angle);
                     ctx.fillStyle = gunColor; // Keep gun grey
                     ctx.fillRect(gunOriginXOffset, -gunThickness / 2, gunLength, gunThickness);
                     ctx.restore();
                 }

                 // 13. Hit Feedback --- USE DUSTY FLASH COLOR ---
                 if (justHit) {
                     // Overlay Flash using the dusty gold color
                     ctx.fillStyle = dustyHitFlashColor; // USE DUSTY FLASH
                     ctx.fillRect(x - shoulderPlateWidth / 2, helmetTopY - 5, shoulderPlateWidth, h * 0.9);

                     // Spark Particles (Keep as they are - orange/yellow)
                     ctx.save();
                     const numSparks = 15 + Math.random() * 10;
                     for (let i = 0; i < numSparks; i++) {
                         const angle = Math.random() * Math.PI * 2;
                         const radius = Math.random() * w * 0.8 + w*0.2;
                         const particleX = x + Math.cos(angle) * radius;
                         const particleY = y + Math.sin(angle) * radius * 0.7 - h * 0.1;
                         const particleSize = Math.random() * 3.5 + 1.5;
                         ctx.fillStyle = sparkColors[Math.floor(Math.random() * sparkColors.length)];
                         ctx.beginPath();
                         ctx.arc(particleX, particleY, particleSize / 2, 0, Math.PI * 2);
                         ctx.fill();
                     }
                     ctx.restore();
                 }

                 // --- Restore initial context save ---
                 ctx.restore();
             }
             // --- END OF UPDATED drawPlayerCharacter ---


            function drawEnemies(enemies) {
                if (!enemies) return;
                const now = performance.now() / 1000; const FADE_DURATION = 0.5;

                Object.values(enemies).forEach(enemy => {
                    if (!enemy) return;
                    const width = enemy.width ?? ENEMY_DEFAULTS.width; const height = enemy.height ?? ENEMY_DEFAULTS.height;
                    const maxHealth = enemy.max_health ?? ENEMY_DEFAULTS.max_health;
                    let alpha = 1.0; let shouldDraw = true; let isDying = false;

                    if (enemy.health <= 0 && enemy.death_timestamp) {
                        isDying = true; const elapsed = now - enemy.death_timestamp;
                        if (elapsed < FADE_DURATION) alpha = 0.4; // Fade slightly before disappearing
                        else shouldDraw = false;
                    }

                    if (shouldDraw) {
                        ctx.save(); ctx.globalAlpha = alpha;
                        drawEnemyRect(enemy.x, enemy.y, width, height, enemy.type, enemy);
                        ctx.restore();
                    }
                    // Only draw health bar if not dying and visible health > 0
                    if (!isDying && enemy.health > 0 && shouldDraw) {
                         drawHealthBar(enemy.x, enemy.y, width, enemy.health, maxHealth);
                    }
                });
            }

            function drawEnemyRect(x, y, w, h, type, enemyState) {
                 // Use cached colors
                const skinColor = enemySkinColor; const coatColor = enemyCoatColor;
                const torsoColor = type === ENEMY_TYPE_SHOOTER ? enemyTorsoShooterColor : enemyTorsoChaserColor;
                const bootColor = enemyBootColor; const capColor = enemyCapColor;
                const hitFlashColor = enemyHitFlashColor;
                const bobOffset = Math.sin(performance.now() / IDLE_BOB_SPEED) * IDLE_BOB_AMPLITUDE;

                // Geometry 
                const headRadius = h * 0.18; const bodyHeight = h * 0.5; const coatLengthBonus = h * 0.15;
                const bodyWidthTop = w * 0.9; const bodyWidthBottom = w * 0.7; const coatWidth = w * 1.1;
                const armWidth = w * 0.2; const armLength = h * 0.4; const capHeight = headRadius * 0.8;
                const capWidth = headRadius * 2.2; const bootSize = 5; const bootSpacing = w * 0.3;

                // --- APPLY bobOffset to calculated Y positions ---
                const headCenterY = y - (h / 2) + headRadius + bobOffset;
                const bodyTopY = headCenterY + headRadius * 0.8; // Inherits offset
                const bodyBottomY = bodyTopY + bodyHeight;
                const coatTopY = bodyTopY + bodyHeight * 0.1;
                const coatBottomY = bodyBottomY + coatLengthBonus;
                const armTopY = bodyTopY + bodyHeight * 0.05;
                const capTopY = headCenterY - headRadius; // Inherits offset
                const bootOffsetY = coatBottomY + 2; // Inherits offset

                // Drawing with cached colors
                ctx.save();
                ctx.fillStyle = coatColor; ctx.fillRect(x - coatWidth / 2, coatTopY, coatWidth, coatBottomY - coatTopY);
                ctx.fillStyle = torsoColor;
                ctx.beginPath(); ctx.moveTo(x - bodyWidthTop / 2, bodyTopY); ctx.lineTo(x + bodyWidthTop / 2, bodyTopY);
                ctx.lineTo(x + bodyWidthBottom / 2, bodyBottomY); ctx.lineTo(x - bodyWidthBottom / 2, bodyBottomY); ctx.closePath(); ctx.fill();
                ctx.fillStyle = coatColor; ctx.fillRect(x - bodyWidthTop / 2 - armWidth, armTopY, armWidth, armLength);
                ctx.fillRect(x + bodyWidthTop / 2, armTopY, armWidth, armLength);
                ctx.fillStyle = skinColor; ctx.beginPath(); ctx.arc(x, headCenterY, headRadius, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = capColor; ctx.fillRect(x - capWidth / 2, capTopY, capWidth, capHeight);
                ctx.fillStyle = bootColor; ctx.fillRect(x - bootSpacing - bootSize / 2, bootOffsetY, bootSize, bootSize);
                ctx.fillRect(x + bootSpacing - bootSize / 2, bootOffsetY, bootSize, bootSize);
                ctx.restore();

                if (enemyState?.hit_flash_this_tick) {
                    ctx.fillStyle = hitFlashColor; const flashMargin = 2;
                    ctx.fillRect(x - w / 2 - flashMargin, y - h / 2 - flashMargin, w + flashMargin * 2, h + flashMargin * 2);
                }
            }

            function drawBullets(bullets) {
                if (!bullets) return;
                Object.values(bullets).forEach(bullet => {
                    if (!bullet) return;
                    const x = bullet.x ?? 0; const y = bullet.y ?? 0;
                    const vx = bullet.vx ?? 0; const vy = bullet.vy ?? 0;
                    const radius = bullet.radius ?? BULLET_DEFAULTS.radius;
                    const bulletType = bullet.bullet_type || 'standard';
                    const ownerType = bullet.owner_type;
                    const hasVelocity = Math.abs(vx) > 0.01 || Math.abs(vy) > 0.01;

                    if (bulletType === 'ammo_heavy_slug' || bulletType === 'standard' || bulletType === 'ammo_rapid_fire' || bulletType === 'standard_enemy') {
                        if (hasVelocity) drawShapedBullet(bullet);
                        else drawBulletCircle(x, y, radius, ownerType === 'player');
                    } else if (bulletType === 'ammo_shotgun') {
                        drawBulletCircle(x, y, radius, ownerType === 'player');
                    } else {
                        drawBulletCircle(x, y, radius, ownerType === 'player');
                    }
                });
            }

            function drawBulletCircle(x, y, r, isPlayerBullet) {
                ctx.fillStyle = isPlayerBullet ? bulletPlayerColor : bulletEnemyColor; // Use cached
                ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fill();
            }

            function drawShapedBullet(bullet) {
                const x = bullet.x; const y = bullet.y; const vx = bullet.vx; const vy = bullet.vy;
                const ownerType = bullet.owner_type; const radius = bullet.radius || BULLET_DEFAULTS.radius;
                const baseLength = 8; const baseWidth = 4; const scaleFactor = radius / BULLET_DEFAULTS.radius;
                const length = baseLength * scaleFactor; const width = baseWidth * scaleFactor;
                const color = (ownerType === 'player') ? bulletPlayerColor : bulletEnemyColor; // Use cached
                const angle = Math.atan2(vy, vx);

                ctx.save(); ctx.translate(x, y); ctx.rotate(angle);
                ctx.fillStyle = color; ctx.fillRect(-length / 2, -width / 2, length, width);
                const noseLength = length * 0.4;
                ctx.beginPath(); ctx.moveTo(length / 2, 0); ctx.lineTo(length / 2 - noseLength, -width / 2);
                ctx.lineTo(length / 2 - noseLength, width / 2); ctx.closePath(); ctx.fill();
                ctx.restore();
            }

            function drawPowerups(powerups) {
                if (!powerups) return;
                Object.values(powerups).forEach(powerup => {
                    if (!powerup) return;
                    const size = powerup.size ?? POWERUP_DEFAULTS.size;
                    const type = powerup.type;
                    drawPowerupSquare(powerup.x, powerup.y, size, type);
                });
            }

            function drawPowerupSquare(x, y, size, type) {
                 // Use cached colors
                 let fillColor = powerupDefaultColor; let symbol = '?';
                 if (type === 'health') { symbol = '+'; fillColor = powerupHealthColor; }
                 else if (type === 'gun_upgrade') { symbol = 'G'; fillColor = powerupGunColor; }
                 else if (type === 'speed_boost') { symbol = 'S'; fillColor = powerupSpeedColor; }
                 else if (type === 'armor') { symbol = '#'; fillColor = powerupArmorColor; }
                 else if (type === 'ammo_shotgun') { symbol = '::'; fillColor = powerupShotgunColor; }
                 else if (type === 'ammo_heavy_slug') { symbol = ''; fillColor = powerupSlugColor; }
                 else if (type === 'ammo_rapid_fire') { symbol = '>'; fillColor = powerupRapidColor; }
                 else if (type === 'bonus_score') { symbol = '$'; fillColor = powerupScoreColor; }

                 ctx.fillStyle = fillColor; ctx.fillRect(x - size / 2, y - size / 2, size, size);
                 ctx.fillStyle = '#000'; // Symbol color (assuming black is ok)
                 let fontSize = Math.round(size * 0.7);
                 ctx.font = `bold ${fontSize}px ${fontFamily}`; // Use cached font
                 ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                 ctx.fillText(symbol, x, y + (size * 0.05)); // Slight offset for better centering
            }

            function drawHealthBar(x, y, width, currentHealth, maxHealth) {
                if (maxHealth <= 0) return;
                const barHeight = 5;
                // Adjust Y offset based on entity width/height (assuming width is more representative for placement)
                const yOffset = -( (width / 2) + 18 ); // Place above entity
                const barWidth = Math.max(20, width * 0.8);
                const currentWidth = Math.max(0, (currentHealth / maxHealth) * barWidth);
                const healthPercentage = currentHealth / maxHealth;
                const barX = x - barWidth / 2;
                const barY = y + yOffset; // Use consistent Y position

                // Use cached colors
                ctx.fillStyle = healthBarBg;
                ctx.fillRect(barX, barY, barWidth, barHeight);
                let barColor = healthBarLow; // Default to low
                if (healthPercentage > 0.66) barColor = healthBarHigh;
                else if (healthPercentage > 0.33) barColor = healthBarMedium;
                ctx.fillStyle = barColor;
                ctx.fillRect(barX, barY, currentWidth, barHeight);
            }

            function drawArmorBar(x, y, width, currentArmor) {
                const maxArmor = 100; // Assuming max armor is 100
                if (currentArmor <= 0) return;
                const armorBarHeight = 4; const healthBarHeight = 5; const barSpacing = 1;
                // Calculate Y position relative to the health bar's position
                const healthBarYOffset = -( (width / 2) + 18 );
                const healthBarTopY = y + healthBarYOffset;
                const armorBarTopY = healthBarTopY + healthBarHeight + barSpacing; // Position below health bar

                const barWidth = Math.max(20, width * 0.8); // Match health bar width
                const currentWidth = Math.max(0, (currentArmor / maxArmor) * barWidth);
                const barX = x - barWidth / 2;
                const barY = armorBarTopY; // Use calculated Y

                // Use cached colors
                ctx.fillStyle = healthBarBg; // Use same background as health bar
                ctx.fillRect(barX, barY, barWidth, armorBarHeight);
                ctx.fillStyle = armorBarColor; // Use cached armor color
                ctx.fillRect(barX, barY, currentWidth, armorBarHeight);
            }
            // --- Main Draw Call ---
            function drawGame() {
                // Keep now calculation at the top
                const now = performance.now();

                // 1. --- Draw Background (Replaces clearRect) ---
                if (!isBackgroundReady) {
                     // Draw a fallback solid color if background isn't generated yet
                     // Use the main ctx here
                     ctx.fillStyle = dayBaseColor; // Or some loading color
                     ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                     // console.log("Waiting for background generation...");
                } else if (isTransitioningBackground) {
                     // Handle the fade transition
                     const elapsed = now - transitionStartTime;
                     const progress = Math.min(1.0, elapsed / BACKGROUND_FADE_DURATION_MS);

                     // Draw the OLD background (fully opaque) onto main canvas
                     ctx.globalAlpha = 1.0;
                     ctx.drawImage(oldOffscreenCanvas, 0, 0);

                     // Draw the NEW background on top, fading it in
                     ctx.globalAlpha = progress; // Alpha goes from 0 to 1
                     ctx.drawImage(offscreenCanvas, 0, 0); // Draw NEW onto main canvas

                     // Reset alpha for subsequent drawing this frame
                     ctx.globalAlpha = 1.0;

                     // Check if transition finished
                     if (progress >= 1.0) {
                         console.log("[Renderer] Background transition finished.");
                         isTransitioningBackground = false;
                     }
                } else {
                     // Normal state: Just draw the current offscreen background onto the main canvas
                     // No need to clearRect first, drawImage covers the whole canvas
                     ctx.drawImage(offscreenCanvas, 0, 0);
                }
                // --- END Background Drawing ---
                drawSnake();
                // 2. --- Screen Shake (Apply *after* background is drawn) ---
                let shakeOffsetX = 0, shakeOffsetY = 0, shakeApplied = false;
                if (now < shakeEndTime && currentShakeMagnitude > 0) {
                    const remainingTime = shakeEndTime - now;
                    const estimatedTotalDuration = Math.max(1, shakeEndTime - (now - 300)); // Estimate based on potential remaining time
                    const decay = Math.max(0, remainingTime / estimatedTotalDuration);
                    const currentMagnitude = currentShakeMagnitude * decay * decay;
                    if (currentMagnitude > 0.5) {
                        shakeOffsetX = (Math.random() * 2 - 1) * currentMagnitude;
                        shakeOffsetY = (Math.random() * 2 - 1) * currentMagnitude;
                        // Apply the translation *before* drawing entities
                        ctx.save();
                        ctx.translate(shakeOffsetX, shakeOffsetY);
                        shakeApplied = true;
                    } else {
                        currentShakeMagnitude = 0; shakeEndTime = 0;
                     }
                } else {
                     currentShakeMagnitude = 0; shakeEndTime = 0;
                 }
                // --- END Screen Shake Setup ---


                // 3. --- Get State to Render (Your existing logic) ---
                let stateToRender;
                if (appState.mode === 'singleplayer') {
                    stateToRender = appState.serverState;
                     const spPlayer = stateToRender?.players[appState.localPlayerId];
                     if (spPlayer) { appState.renderedPlayerPos.x = spPlayer.x; appState.renderedPlayerPos.y = spPlayer.y; }
                } else {
                    stateToRender = Game.getInterpolatedState(now); // Call via the Game module
                }

                // 4. --- Guard Clause (Your existing logic + alpha reset) ---
                if (!stateToRender || !appState.localPlayerId || !stateToRender.players) {
                    // Reset alpha before returning if shake was applied
                    ctx.globalAlpha = 1.0; // Ensure alpha is reset
                    if (shakeApplied) { ctx.restore(); } // Restore if transform was applied
                    return;
                }

                // 5. --- Muzzle Flash Check (Your existing logic) ---
                let shouldDrawMuzzleFlash = false;
                if (localPlayerMuzzleFlash.active) {
                    if (now < localPlayerMuzzleFlash.endTime) { shouldDrawMuzzleFlash = true; }
                    else { localPlayerMuzzleFlash.active = false; }
                }

                // 6. --- DRAWING ORDER (Your existing logic) ---
                // These are now drawn *after* the background and *with* the shake transform applied (if active)
                drawCampfire(stateToRender.campfire);

                if (shouldDrawMuzzleFlash) {
                    drawMuzzleFlash( appState.renderedPlayerPos.x, appState.renderedPlayerPos.y, localPlayerMuzzleFlash.aimDx, localPlayerMuzzleFlash.aimDy );
                }

                drawPowerups(stateToRender.powerups);
                drawBullets(stateToRender.bullets);
                drawEnemies(stateToRender.enemies);
                drawPlayers(stateToRender.players); // Includes health/armor bars

                drawSpeechBubbles(stateToRender.players);
                drawEnemySpeechBubbles(stateToRender.enemies);

                drawDamageTexts(stateToRender.damage_texts);

                // 7. --- Vignette (Your existing logic) ---
                // Drawn last, potentially over everything else
                let vignetteIntensity = 0;
                const localPlayer = stateToRender.players[appState.localPlayerId];
                if (localPlayer && localPlayer.max_health > 0) {
                    const healthPercentage = localPlayer.health / localPlayer.max_health;
                    if (healthPercentage <= 0.33) { vignetteIntensity = Math.min(1.0, Math.max(0, 0.6 + (0.4 * (1 - (healthPercentage / 0.33))))); }
                    else if (healthPercentage <= 0.66) { vignetteIntensity = Math.max(0, 0.4 * (1 - ((healthPercentage - 0.33) / (0.66 - 0.33)))); }
                }
                // Vignette should probably be drawn *after* restoring the shake transform
                // Let's move drawDamageVignette after the ctx.restore()

                // 8. --- Restore Shake Transform (Your existing logic) ---
                if (shakeApplied) {
                     ctx.restore(); // Restore the translation back to normal
                 }

                // --- Draw Vignette AFTER restoring shake ---
                drawDamageVignette(vignetteIntensity);
                // -------------------------------------------

                // Final safety alpha reset
                ctx.globalAlpha = 1.0;
            }

             return {
                 drawGame,
                 triggerShake,
                 updateGeneratedBackground: updateGeneratedBackground
             };
        })(); // End Renderer module IIFE

        const Game = (() => {

            // --- Game Actions ---
            function startSinglePlayer() {
                log("Requesting Single Player game...");
                appState.mode = 'singleplayer';
                resetClientState(false);
                UI.updateStatus("Starting Single Player...");
                Network.sendMessage({ type: 'start_single_player' });
                // Loop starts on server confirmation ('sp_game_started')
            }

            function joinMultiplayer() {
                const gameId = DOM.gameIdInput.value.trim().toUpperCase();
                if (!gameId || gameId.length !== 6) {
                    UI.updateStatus('Invalid Game ID format.', true); return;
                 }
                log(`Attempting to join game: ${gameId}`);
                appState.mode = 'multiplayer-client';
                resetClientState(false);
                UI.updateStatus(`Joining game ${gameId}...`);
                Network.sendMessage({ type: 'join_game', game_id: gameId });
                 // Loop starts on server confirmation ('game_joined')
            }

            function leaveGame() {
                log("Leaving current game / Cancelling host...");
                Network.closeConnection(1000, "User action (leave/cancel)");
                resetClientState(true); // Show menu immediately
            }

            function sendChatMessage() {
                const message = DOM.chatInput.value.trim();
                if (message && appState.isConnected && appState.currentGameId && appState.localPlayerId) {
                    Network.sendMessage({ type: 'player_chat', message: message });
                    DOM.chatInput.value = '';
                } else {
                    log("Cannot send chat: Not connected or not in a game.");
                }
            }

            function resetClientState(showMenu = true) {
                 log(`Resetting client state. Show Menu: ${showMenu}`);
                 cleanupLoop(); // Stop game loop if running first

                 // --- DO NOT RESET appState.mode here ---
                 // Mode is set by the initiating action (startSP, hostMP, joinMP)
                 // or when explicitly returning to menu.

                 appState.localPlayerId = null;
                 appState.currentGameId = null;
                 appState.serverState = null;
                 appState.lastServerState = null;
                 appState.maxPlayersInGame = null; 
                 appState.previousServerState = null;
                 appState.predictedPlayerPos = { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 };
                 appState.renderedPlayerPos = { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 };
                 appState.lastLoopTime = null; // Reset timer

                 // Clear UI elements related to game state
                 DOM.chatLog.innerHTML = '';
                 DOM.gameCodeDisplay.textContent = '------';
                 DOM.gameIdInput.value = '';
                 DOM.countdownDiv.style.display = 'none';
                 DOM.dayNightIndicator.style.display = 'none';
                 DOM.gameOverScreen.style.display = 'none';
                 // Optional: Clear HUD?
                 // DOM.playerStatsDiv.textContent = 'Loading...';
                 // DOM.gameInfoDiv.textContent = 'Score: 0 | Level: 1';


                 // Update UI section and mode only if explicitly returning to menu
                 if (showMenu) {
                     appState.mode = 'menu'; // Set mode to 'menu' ONLY when showing the menu
                     UI.showSection('main-menu-section');
                     UI.updateStatus(appState.isConnected ? "Connected. Select Mode." : "Disconnected.");
                 }
                 // If showMenu is false, we assume we are resetting state *before*
                 // entering a game, and the correct mode ('singleplayer', 'multiplayer-host', etc.)
                 // has already been set by the function that called resetClientState(false).
             }

             // --- Game Loop Management ---

             // Define the main loop function at this scope level
            function gameLoop(currentTime) {
                // Check for active hit pause
                if (hitPauseFrames > 0) {
                    hitPauseFrames--;
                    if (appState.mode !== 'menu' && appState.isConnected && !appState.serverState?.game_over) {
                        appState.animationFrameId = requestAnimationFrame(gameLoop);
                    }
                    return; // Skip rendering and logic this frame
                }

                // Original game loop logic continues if not paused
                if (appState.mode === 'menu' || !appState.isConnected || appState.serverState?.game_over) {
                    const finalStateForDisplay = appState.serverState;
                    if (finalStateForDisplay?.game_over) {
                        UI.updateStatus("Game Over!");
                        UI.showGameOver(finalStateForDisplay); // Show game over screen here
                    } else if (appState.mode === 'menu') {
                        UI.updateStatus(appState.isConnected ? "Connected. Select Mode." : "Disconnected.");
                    }
                    cleanupLoop();
                    return;
                }

                // Wait for initial server state in multiplayer before proceeding
                if (!appState.serverState && appState.mode !== 'singleplayer') {
                    appState.animationFrameId = requestAnimationFrame(gameLoop);
                    return;
                }

                // Calculate delta time
                if (appState.lastLoopTime === null) { appState.lastLoopTime = currentTime; }
                const deltaTime = Math.min(0.1, (currentTime - appState.lastLoopTime) / 1000);
                appState.lastLoopTime = currentTime;

                // --- SNAKE TIMER & SPAWN LOGIC (Run only during Day and if game is active) ---
                if (appState.serverState?.status === 'active' && appState.serverState && !appState.serverState.is_night) {
                    if (!snake.active) {
                        snakeSpawnTimer -= deltaTime;
                        if (snakeSpawnTimer <= 0) {
                            // Activate the snake!
                            snake.active = true;
                            snake.segments = []; // Clear old segments
                            // Choose starting side and Y
                            const startLeft = Math.random() < 0.5;
                            snake.direction = startLeft ? 1 : -1;
                            snake.x = startLeft ? -snake.segmentLength * snake.maxSegments : CANVAS_WIDTH + snake.segmentLength * snake.maxSegments; // Start off-screen
                            snake.baseY = Math.random() * (CANVAS_HEIGHT - 40) + 20; // Random Y, avoiding very top/bottom
                            snake.y = snake.baseY; // Initial Y
                            log("[Effect] Snake activated!");
                            // Reset timer for next spawn
                            snakeSpawnTimer = SNAKE_SPAWN_INTERVAL_MIN + Math.random() * (SNAKE_SPAWN_INTERVAL_MAX - SNAKE_SPAWN_INTERVAL_MIN);
                        }
                    }
                } else if (snake.active && appState.serverState?.is_night) {
                     // If it becomes night while snake is active, deactivate it (optional refinement)
                     // snake.active = false; // Or let it finish its current run
                }
                // --- END SNAKE TIMER LOGIC ---


                // --- SNAKE MOVEMENT LOGIC (Run only if snake is active) ---
                if (snake.active) {
                    // Calculate target X for this frame
                    const targetX = snake.x + snake.direction * snake.speed * deltaTime;

                    // Store current head position before moving, add to front for correct drawing order
                    snake.segments.unshift({ x: snake.x, y: snake.y }); // Add to beginning
                    // Keep segment array length limited
                    while (snake.segments.length > snake.maxSegments) {
                        snake.segments.pop(); // Remove the oldest segment from the end
                    }

                    // Update head position
                    snake.x = targetX;
                    snake.y = snake.baseY + Math.sin(snake.x * snake.frequency) * snake.amplitude;

                    // Check if snake head is fully off-screen
                    const offscreenMargin = snake.segmentLength * snake.maxSegments * 1.5; // Generous margin
                    if ((snake.direction === 1 && snake.x > CANVAS_WIDTH + offscreenMargin) ||
                        (snake.direction === -1 && snake.x < -offscreenMargin))
                    {
                        snake.active = false;
                        log("[Effect] Snake deactivated (off-screen).");
                    }
                }
                // --- END SNAKE MOVEMENT LOGIC ---

                // --- Existing Game Logic ---
                // Handle shooting input
                if (appState.serverState?.status === 'active' && Input.isShootHeld()) {
                    Input.handleShooting();
                }

                // Handle prediction & reconciliation for multiplayer
                if (appState.mode !== 'singleplayer' && appState.serverState?.status === 'active') {
                    updatePredictedPosition(deltaTime);
                    reconcileWithServer();
                }

                // --- Render the frame ---
                Renderer.drawGame(); // This will now draw the snake if snake.active is true

                // --- Request next frame ---
                if (appState.mode !== 'menu' && appState.isConnected && !appState.serverState?.game_over) {
                    appState.animationFrameId = requestAnimationFrame(gameLoop);
                } else {
                    // Cleanup if loop should stop
                    if(appState.animationFrameId) cleanupLoop();
                }
            } // End gameLoop

            function startGameLoop() {
                // --- Initial Checks ---
                // Don't start if explicitly in menu mode
                if (appState.mode === 'menu') {
                    log("StartGameLoop called but client is in menu mode.");
                    return;
                }
                // Don't start if loop is already running
                if (appState.animationFrameId) {
                    log("StartGameLoop called but loop already running.");
                    return;
                }
                // Don't start multiplayer if initial state hasn't arrived
                // (SP gets state immediately with sp_game_started)
                if (!appState.serverState && appState.mode !== 'singleplayer') {
                     log("StartGameLoop: Waiting for initial server state in multiplayer... (Loop will start via state update)");
                     return;
                }

                // --- Setup & Start ---
                Input.setup(); // <<< SETUP INPUT LISTENERS FIRST
                log("Starting game loop..."); // <<< THEN LOG
                appState.lastLoopTime = null; // Reset last time for accurate delta calculation on the first frame

                // Make the initial call to request the first frame of the game loop
                appState.animationFrameId = requestAnimationFrame(gameLoop);
            }

    // --- Interpolation Function ---
            function getInterpolatedState(renderTime) {
                const INTERPOLATION_BUFFER_MS = 100; // Target delay behind server time (e.g., 2 ticks at 30Hz)
                const serverTime = appState.serverState?.timestamp * 1000; // Convert server seconds to ms
                const lastServerTime = appState.lastServerState?.timestamp * 1000;

                // Can't interpolate without two states or valid times
                if (!appState.serverState || !appState.lastServerState || !serverTime || !lastServerTime || serverTime <= lastServerTime) {
                    // console.warn("Interpolation skipped: Not enough valid state history."); // Can be noisy
                    return appState.serverState; // Return latest known state directly
                }

                // Calculate the time point we want to render (slightly behind current time)
                const renderTargetTime = renderTime - INTERPOLATION_BUFFER_MS;

                // Calculate interpolation factor (t) between lastServerTime and serverTime
                const timeBetweenStates = serverTime - lastServerTime;
                const timeSinceLastState = renderTargetTime - lastServerTime;

                // Clamp t between 0 and 1
                let t = Math.max(0, Math.min(1, timeSinceLastState / timeBetweenStates));

                // Create a new state object to hold interpolated data
                // Start by cloning the latest state, then overwrite interpolated values
                // Note: A deep clone might be safer, but shallow is often sufficient here
                let interpolatedState = { ...appState.serverState };
                interpolatedState.players = {}; // Clear players, will repopulate
                interpolatedState.enemies = {}; // Clear enemies
                interpolatedState.bullets = {}; // Clear bullets

                // --- Interpolate Players ---
                if (appState.serverState.players) {
                    for (const pId in appState.serverState.players) {
                        const currentState = appState.serverState.players[pId];
                        const lastState = appState.lastServerState.players?.[pId];

                        // Use local predicted/rendered position for OUR player
                        if (pId === appState.localPlayerId) {
                            interpolatedState.players[pId] = {
                                ...currentState, // Copy latest non-positional data
                                x: appState.renderedPlayerPos.x, // Use smoothed local render position
                                y: appState.renderedPlayerPos.y
                            };
                        }
                        // Interpolate OTHER players if possible
                        else if (lastState && typeof currentState.x === 'number' && typeof lastState.x === 'number') {
                            interpolatedState.players[pId] = {
                                ...currentState, // Copy latest non-positional data
                                x: lerp(lastState.x, currentState.x, t),
                                y: lerp(lastState.y, currentState.y, t)
                            };
                        }
                        // Otherwise, just use the latest known state for the other player
                        else {
                            interpolatedState.players[pId] = { ...currentState };
                        }
                    }
                }

                // --- Interpolate Enemies (Example) ---
                if (appState.serverState.enemies) {
                    for (const eId in appState.serverState.enemies) {
                        const currentState = appState.serverState.enemies[eId];
                        const lastState = appState.lastServerState.enemies?.[eId];

                        // Interpolate if possible and not dead/dying
                        if (lastState && typeof currentState.x === 'number' && typeof lastState.x === 'number' && currentState.health > 0) {
                            interpolatedState.enemies[eId] = {
                                ...currentState,
                                x: lerp(lastState.x, currentState.x, t),
                                y: lerp(lastState.y, currentState.y, t)
                            };
                        }
                        // Otherwise, use latest state (handles dead/newly spawned enemies)
                        else {
                            interpolatedState.enemies[eId] = { ...currentState };
                        }
                    }
                }

                // --- Interpolate Bullets (Example) ---
                if (appState.serverState.bullets) {
                    for (const bId in appState.serverState.bullets) {
                        const currentState = appState.serverState.bullets[bId];
                        const lastState = appState.lastServerState.bullets?.[bId];

                        // Interpolate if possible
                        if (lastState && typeof currentState.x === 'number' && typeof lastState.x === 'number') {
                            interpolatedState.bullets[bId] = {
                                ...currentState,
                                x: lerp(lastState.x, currentState.x, t),
                                y: lerp(lastState.y, currentState.y, t)
                            };
                        }
                        // Otherwise, use latest state
                        else {
                            interpolatedState.bullets[bId] = { ...currentState };
                        }
                    }
                }

                // Copy non-interpolated parts from the latest state
                interpolatedState.powerups = appState.serverState.powerups;
                interpolatedState.damage_texts = appState.serverState.damage_texts;
                // Keep score, status, etc., from the latest state
                interpolatedState.score = appState.serverState.score;
                interpolatedState.status = appState.serverState.status;
                interpolatedState.is_night = appState.serverState.is_night;
                interpolatedState.game_over = appState.serverState.game_over;
                interpolatedState.countdown = appState.serverState.countdown;
                interpolatedState.day_night_timer_remaining = appState.serverState.day_night_timer_remaining;
                interpolatedState.campfire = appState.serverState.campfire;
                interpolatedState.enemy_speaker_id = appState.serverState.enemy_speaker_id;
                interpolatedState.enemy_speech_text = appState.serverState.enemy_speech_text;
                // Add any other non-positional state fields here


                return interpolatedState;
            }

            function cleanupLoop() {
                 if (appState.animationFrameId) {
                     cancelAnimationFrame(appState.animationFrameId);
                     appState.animationFrameId = null;
                     log("Game loop stopped and cleaned up.");
                 } else {
                     // log("CleanupLoop called but no active loop found."); // Can be noisy
                 }
                 Input.cleanup(); // Deactivate input listeners
                 appState.lastLoopTime = null; // Reset timer
             }

             // --- Prediction & Reconciliation Functions ---
             function updatePredictedPosition(deltaTime) {
                if (!appState.localPlayerId || !appState.serverState?.players?.[appState.localPlayerId]) return; // Safety check

                const moveVector = Input.getMovementInputVector();
                const playerState = appState.serverState.players[appState.localPlayerId];
                // Use default speed if player state or speed property is missing
                const playerSpeed = playerState?.speed ?? PLAYER_DEFAULTS.base_speed;

                // Only update prediction if moving
                if (moveVector.dx === 0 && moveVector.dy === 0) return;

                appState.predictedPlayerPos.x += moveVector.dx * playerSpeed * deltaTime;
                appState.predictedPlayerPos.y += moveVector.dy * playerSpeed * deltaTime;

                // Use default dimensions if player state or dimensions are missing
                const w_half = (playerState?.width ?? PLAYER_DEFAULTS.width) / 2;
                const h_half = (playerState?.height ?? PLAYER_DEFAULTS.height) / 2;

                // Clamp prediction to canvas bounds
                appState.predictedPlayerPos.x = Math.max(w_half, Math.min(CANVAS_WIDTH - w_half, appState.predictedPlayerPos.x));
                appState.predictedPlayerPos.y = Math.max(h_half, Math.min(CANVAS_HEIGHT - h_half, appState.predictedPlayerPos.y));
             }

             function reconcileWithServer() {
                if (!appState.localPlayerId || !appState.serverState?.players?.[appState.localPlayerId]) return;

                const serverPos = appState.serverState.players[appState.localPlayerId];
                if (typeof serverPos.x !== 'number' || typeof serverPos.y !== 'number') {
                    // log("Reconciliation skipped: Invalid server position data."); // Keep logging minimal
                    return;
                }

                const predictedPos = appState.predictedPlayerPos;
                const renderedPos = appState.renderedPlayerPos;
                const dist = distance(predictedPos.x, predictedPos.y, serverPos.x, serverPos.y);

                const threshold = parseFloat(getCssVar('--reconciliation-threshold')) || 5; // This threshold is for SNAPPING
                const lerpFactor = parseFloat(getCssVar('--lerp-factor')) || 0.2; // This is for VISIBLE smoothing

                if (dist > threshold * 2) { // Large error -> Snap
                    // log(`Reconciliation SNAP! Dist: ${dist.toFixed(1)}`);
                    predictedPos.x = serverPos.x;
                    predictedPos.y = serverPos.y;
                    renderedPos.x = serverPos.x;
                    renderedPos.y = serverPos.y;
                } else {
                    // Smooth visible position towards prediction
                    renderedPos.x = lerp(renderedPos.x, predictedPos.x, lerpFactor);
                    renderedPos.y = lerp(renderedPos.y, predictedPos.y, lerpFactor);

                    // Gentle Nudge: Only correct prediction if error is > 4.0 pixels
                    // --- CHANGE HERE: Increased threshold ---
                    if (dist > 4.0) { // Was 2.0
                         // Use the halved nudge factor
                         predictedPos.x = lerp(predictedPos.x, serverPos.x, lerpFactor * 0.05);
                         predictedPos.y = lerp(predictedPos.y, serverPos.y, lerpFactor * 0.05);
                         // log(`Reconciliation Nudge: Dist=${dist.toFixed(1)}`); // Optional debug
                    }
                    // --- End Change ---
                }
             }

             // Accessor not strictly needed if SP uses server state directly
             function getLocalGameState() { return appState.serverState; }

             // Setup button listeners (called once on load)
             function initListeners() {
                 log("Initializing button listeners...");
                 DOM.singlePlayerBtn.onclick = startSinglePlayer;
                 DOM.multiplayerBtn.onclick = () => UI.showSection('multiplayer-menu-section');
                 DOM.hostGameBtn2.onclick = () => hostMultiplayer(2);
                 DOM.hostGameBtn3.onclick = () => hostMultiplayer(3);
                 DOM.hostGameBtn4.onclick = () => hostMultiplayer(4);
                 DOM.showJoinUIBtn.onclick = () => UI.showSection('join-code-section');
                 DOM.cancelHostBtn.onclick = leaveGame;
                 DOM.joinGameSubmitBtn.onclick = joinMultiplayer;
                 DOM.sendChatBtn.onclick = sendChatMessage;
                 DOM.leaveGameBtn.onclick = leaveGame;
                 DOM.gameOverBackBtn.onclick = () => resetClientState(true);

                 // Back buttons using class
                 DOM.gameContainer.querySelectorAll('.back-button').forEach(btn => {
                     const targetSectionMatch = btn.getAttribute('onclick')?.match(/'([^']+)'/);
                     if (targetSectionMatch && targetSectionMatch[1]) {
                         const targetSectionId = targetSectionMatch[1];
                         // Ensure valid section ID before overriding
                         if (DOM[targetSectionId] || document.getElementById(targetSectionId)) {
                              btn.onclick = (e) => { e.preventDefault(); UI.showSection(targetSectionId); }; // Override inline
                         } else {
                              log(`Warning: Back button target section invalid: ${targetSectionId}`);
                         }
                     } else {
                         log("Warning: Back button found without valid target in onclick:", btn);
                     }
                 });
             }


            function hostMultiplayer(maxPlayers) {
                log(`Requesting to Host Multiplayer game for ${maxPlayers} players...`);
                // Validate maxPlayers briefly on client side
                if (![2, 3, 4].includes(maxPlayers)) {
                    error("Invalid max player count requested:", maxPlayers);
                    UI.updateStatus("Invalid player count.", true);
                    return;
                }
                appState.mode = 'multiplayer-host';
                resetClientState(false); // Reset state but don't show menu yet
                UI.updateStatus(`Creating ${maxPlayers}-player game...`);
                // Send max_players value to server
                Network.sendMessage({ type: 'create_game', max_players: maxPlayers });
                // UI transition happens on 'game_created' response
            }



            // --- Expose necessary functions from Game module ---
            return {
                 resetClientState,
                 startGameLoop,
                 cleanupLoop,
                 sendChatMessage,
                 getLocalGameState,
                 initListeners, 
                 getInterpolatedState: getInterpolatedState
            };
        })(); // End Game module IIFE

        // --- Global Server Message Handler ---
        function handleServerMessage(event) {
            let data;
            try {
                data = JSON.parse(event.data);
            } catch (err) {
                console.error("[Client] Failed to parse server message:", err, event.data);
                UI.updateStatus("Received invalid data from server.", true);
                return;
            }

            try {
                switch (data.type) {
                    // --- Case: HOST Creates Game ---
                    case 'game_created':
                        log("[handleServerMessage] Processing 'game_created'");
                        appState.localPlayerId = data.player_id;
                        appState.currentGameId = data.game_id;
                        appState.serverState = data.initial_state; // Host receives initial state here
                        appState.maxPlayersInGame = data.max_players; // Store max players

                        if (!appState.maxPlayersInGame) {
                            error("'game_created' message missing 'max_players'!");
                            appState.maxPlayersInGame = '?';
                        }
                        log(`-> Stored maxPlayersInGame: ${appState.maxPlayersInGame}`);

                        const hostPlayer = appState.serverState?.players[appState.localPlayerId];
                        if (hostPlayer) {
                            appState.predictedPlayerPos = { x: hostPlayer.x, y: hostPlayer.y };
                            appState.renderedPlayerPos = { x: hostPlayer.x, y: hostPlayer.y };
                        }

                        if (DOM.gameCodeDisplay) DOM.gameCodeDisplay.textContent = appState.currentGameId || 'ERROR_ID';
                        else error("DOM.gameCodeDisplay not found!");

                        const currentPlayers = Object.keys(appState.serverState?.players || {}).length;
                        if (DOM.waitingMessage) DOM.waitingMessage.textContent = `Waiting for Team Mate... (${currentPlayers}/${appState.maxPlayersInGame})`;
                        else error("DOM.waitingMessage not found!");

                        UI.updateStatus(`Game hosted. Code: ${appState.currentGameId}`);
                        UI.showSection('host-wait-section');

                        // Host loop starts via 'game_state' update when game becomes active/countdown
                        log("-> Host waiting, loop NOT started yet.");
                        break; // End game_created

                    // --- Case: CLIENT Joins Game ---
                    case 'game_joined':
                        log("[handleServerMessage] Processing 'game_joined'");
                        appState.localPlayerId = data.player_id;
                        appState.currentGameId = data.game_id;
                        appState.serverState = data.initial_state; // Client receives initial state here

                        appState.maxPlayersInGame = appState.serverState?.max_players;
                        if (!appState.maxPlayersInGame) {
                            error("'game_joined' initial_state missing 'max_players'!");
                            appState.maxPlayersInGame = '?';
                        }
                        log(`-> Stored maxPlayersInGame: ${appState.maxPlayersInGame}`);

                        const joinedPlayer = appState.serverState?.players[appState.localPlayerId];
                        if (joinedPlayer) {
                            appState.predictedPlayerPos = { x: joinedPlayer.x, y: joinedPlayer.y };
                            appState.renderedPlayerPos = { x: joinedPlayer.x, y: joinedPlayer.y };
                        }

                        UI.updateStatus(`Joined game ${appState.currentGameId}. Get ready!`);
                        UI.showSection('game-area');

                        // --- TRIGGER INITIAL BACKGROUND GENERATION ---
                        if (appState.serverState) {
                            log("[handleServerMessage] Triggering initial background gen for joined client.");
                            Renderer.updateGeneratedBackground(appState.serverState.is_night);
                            // Also update HUD immediately
                            UI.updateHUD(appState.serverState);
                            UI.updateCountdown(appState.serverState);
                        } else {
                            log("[handleServerMessage] Warning: No server state available on game_joined to generate initial background.");
                        }
                        // -------------------------------------------

                        log("-> Join successful, starting loop for client.");
                        Game.startGameLoop(); // Start loop immediately for joining client
                        break; // End game_joined

                    // --- Case: SINGLE PLAYER Starts Game ---
                    case 'sp_game_started':
                        log("[handleServerMessage] Processing 'sp_game_started'");
                        appState.localPlayerId = data.player_id;
                        appState.currentGameId = data.game_id;
                        appState.serverState = data.initial_state; // SP receives initial state here
                        appState.maxPlayersInGame = 1;

                        const spPlayer = appState.serverState?.players[appState.localPlayerId];
                        if (spPlayer) {
                            appState.predictedPlayerPos = { x: spPlayer.x, y: spPlayer.y };
                            appState.renderedPlayerPos = { x: spPlayer.x, y: spPlayer.y };
                        }

                        UI.updateStatus("Single Player Game Started!");
                        UI.showSection('game-area');

                        // --- TRIGGER INITIAL BACKGROUND & HUD UPDATE ---
                        if (appState.serverState) {
                             log("[handleServerMessage] Triggering initial background gen for SP client.");
                             Renderer.updateGeneratedBackground(appState.serverState.is_night); // Trigger background gen
                             UI.updateHUD(appState.serverState);
                             UI.updateCountdown(appState.serverState);
                             // UI.updateDayNight(appState.serverState); // No need, background gen handles initial visual state
                        } else {
                             log("[handleServerMessage] Warning: No server state available on sp_game_started to generate initial background.");
                        }
                        // ---------------------------------------------

                        log("-> SP started, starting loop.");
                        Game.startGameLoop(); // Start loop immediately for SP
                        break; // End sp_game_started

                    // --- Case: Receiving Game State Updates ---
                    case 'game_state':
                        // Store previous state info before updating
                        const previousStatus = appState.serverState?.status;
                        const wasGameOver = appState.serverState?.game_over;
                        const previousPlayerState = appState.serverState?.players?.[appState.localPlayerId];

                        // Update state history for interpolation
                        appState.previousServerState = appState.lastServerState;
                        appState.lastServerState = appState.serverState;
                        appState.serverState = data.state; // Update to the new state
                        const newState = appState.serverState; // Use newState for clarity
                        const currentPlayerState = newState?.players?.[appState.localPlayerId];

                        // --- Handle hit shake ---
                        if (previousPlayerState && currentPlayerState &&
                            typeof currentPlayerState.health === 'number' &&
                            typeof previousPlayerState.health === 'number' &&
                            currentPlayerState.health < previousPlayerState.health)
                        {
                            const damageTaken = previousPlayerState.health - currentPlayerState.health;
                            const baseMagnitude = 3; const damageScale = 0.1; const maxMagnitude = 10;
                            const shakeMagnitude = Math.min(maxMagnitude, baseMagnitude + damageTaken * damageScale);
                            const shakeDuration = 250;
                            // log(`Damage detected! Taken: ${damageTaken.toFixed(1)}, Triggering Shake: Mag=${shakeMagnitude.toFixed(1)}, Dur=${shakeDuration}`);
                            Renderer.triggerShake(shakeMagnitude, shakeDuration);
                        }

                         // --- Handle hit pause ---
                         const localPlayerStateHit = newState?.players?.[appState.localPlayerId];
                         if (localPlayerStateHit?.hit_flash_this_tick && hitPauseFrames <= 0) {
                             hitPauseFrames = 3; // Apply hit pause frames
                         }

                        // --- Update max players if missing ---
                        if (!appState.maxPlayersInGame && newState.max_players) {
                             appState.maxPlayersInGame = newState.max_players;
                             log(`-> Max players set from game_state: ${appState.maxPlayersInGame}`);
                        }

                        // --- Handle Game Status Changes ---
                        if (newState.status !== previousStatus) {
                            log(`[Client State Change] From ${previousStatus || 'null'} to ${newState.status}`);

                            if (newState.status === 'waiting') {
                                if (appState.mode === 'multiplayer-host') {
                                    log("-> Handling transition TO waiting (player left?)");
                                    UI.updateStatus("Teammate left. Waiting...", true);
                                    UI.showSection('host-wait-section');
                                    const currentPlayersWaiting = Object.keys(newState.players || {}).length;
                                    if(DOM.waitingMessage) DOM.waitingMessage.textContent = `Waiting for Team Mate... (${currentPlayersWaiting}/${appState.maxPlayersInGame || '?'})`;
                                    Game.cleanupLoop(); // Stop loop if returning to wait
                                } else {
                                    log("-> Game returned to waiting (client view).");
                                    UI.updateStatus("Host or player left. Returning to menu.", true);
                                    Game.resetClientState(true); // Go back to menu
                                }

                            } else if (newState.status === 'countdown' || newState.status === 'active') {
                                UI.updateStatus(newState.status === 'countdown' ? "Countdown starting..." : "Game active!");
                                UI.showSection('game-area'); // Ensure game area is shown

                                // --- START LOOP & TRIGGER INITIAL BACKGROUND IF NEEDED ---
                                if (!appState.animationFrameId) {
                                    log(`--> Starting game loop NOW (triggered by ${newState.status} state update).`);
                                     // Generate background only if loop is just starting
                                    if (newState) {
                                         log("[handleServerMessage] Triggering initial background gen on loop start from game_state.");
                                         Renderer.updateGeneratedBackground(newState.is_night);
                                    }
                                    Game.startGameLoop();
                                } else {
                                     // log(`--> Loop already running (${newState.status} change).`); // Can be noisy
                                }
                                // -------------------------------------------------------

                            } else if (newState.status === 'finished') {
                                log("-> Game status changed to 'finished'. Game loop will stop or show game over screen.");
                            }
                        } // End status change check

                        // --- Update UI based on current state (even if status didn't change) ---
                        if (newState.status === 'countdown' || newState.status === 'active') {
                            UI.updateHUD(newState); // Update stats, etc.
                            UI.updateCountdown(newState); // Update visual countdown timer
                            UI.updateDayNight(newState); // Update Day/Night indicator text AND trigger background changes if needed
                        }
                        else if (newState.status === 'waiting' && appState.mode === 'multiplayer-host') {
                            // Update waiting message for host if player count changes
                            const playerCount = Object.keys(newState.players || {}).length;
                            if(DOM.waitingMessage) DOM.waitingMessage.textContent = `Waiting for Team Mate... (${playerCount}/${appState.maxPlayersInGame || '?'})`;
                        }

                        // --- Fallback Check for game over signal ---
                        if (newState.game_over && !wasGameOver) {
                            log("-> Game Over signal received from server via regular state update (Fallback).");
                            UI.showGameOver(newState); // Show using the state data received
                            Game.cleanupLoop(); // Stop the loop
                        }

                        // Handle enemy speech bubble updates
                        const serverSpeakerId = newState.enemy_speaker_id;
                        const serverSpeechText = newState.enemy_speech_text;
                        if (serverSpeakerId && serverSpeechText) {
                            const bubbleText = serverSpeechText.substring(0, 50); // Limit length
                            activeEnemyBubbles[serverSpeakerId] = {
                                text: bubbleText, endTime: performance.now() + 3000 // Show for 3 seconds
                            };
                        }
                        break; // End game_state

                    // --- NEW CASE: Explicit Game Over Notification ---
                    case 'game_over_notification':
                        log("[handleServerMessage] Processing 'game_over_notification'");
                        // Ensure we have final state data
                        if (data.final_state) {
                            // Update the client's state representation immediately
                            appState.serverState = data.final_state;
                            UI.updateStatus("Game Over!"); // Update status text
                            UI.showGameOver(data.final_state); // Show the game over screen with final stats
                            Game.cleanupLoop(); // Stop the client's game loop
                            log("-> Game Over screen displayed via notification, loop stopped.");
                        } else {
                            error("Received 'game_over_notification' without final_state data.");
                            // Fallback? Maybe just show basic game over or go to menu?
                            Game.resetClientState(true); // Go back to menu as a safety measure
                        }
                        break; // End game_over_notification
                    // --- END NEW CASE ---

                     // --- Case: Chat Message ---
                     case 'chat_message':
                         const senderId = data.sender_id;
                         const messageText = data.message;
                         const isSelf = senderId === appState.localPlayerId;
                         UI.addChatMessage(senderId, messageText, isSelf);
                         // Add speech bubble for chat message
                         if (senderId && messageText) {
                             const bubbleText = messageText.substring(0, 50); // Limit length
                             activeSpeechBubbles[senderId] = {
                                 text: bubbleText, endTime: performance.now() + 4000 // Show for 4 seconds
                             };
                         }
                         break; // End chat_message

                     // --- Case: Server Error Message ---
                     case 'error':
                         console.error("[Client] Server Error Message:", data.message);
                         UI.updateStatus(`Server Error: ${data.message}`, true);
                         // Handle specific errors that might require UI changes
                         if (appState.mode === 'multiplayer-client' && (data.message.includes('not found') || data.message.includes('not waiting') || data.message.includes('full') || data.message.includes('finished'))) {
                             UI.showSection('join-code-section'); // Go back to join input
                             appState.mode = 'menu'; // Reset mode conceptually
                         } else if (appState.mode === 'multiplayer-host' && data.message.includes('Creation Error')) {
                             Game.resetClientState(true); // Back to main menu on host creation error
                         } else if (data.message === 'Please create or join a game first.') {
                              log("Received 'join first' error unexpectedly, maybe disconnected? Resetting state.");
                              Game.resetClientState(true); // Back to main menu
                         }
                         break; // End error

                    // --- Default Case: Unknown Message Type ---
                    default:
                        log(`Unknown message type received: ${data.type}`);
                } // End switch
            } catch (handlerError) {
                console.error("[Client] Error inside handleServerMessage logic:", handlerError);
                UI.updateStatus("Client error processing message.", true);
            }
        } // End handleServerMessage


        // --- Global Init ---
        // Wrapper for inline HTML button compatibility
        function showSection(sectionId) { UI.showSection(sectionId); }

        window.onload = () => {
            log("Window loaded.");
            UI.updateStatus("Initializing...");

            // Define appState *before* initializing modules that might use it
             // --- Global Client State --- <<< IMPORTANT PLACEMENT
             appState = { // Use global scope assignment since it's used everywhere
                 mode: 'menu',
                 localPlayerId: null,
                 currentGameId: null,
                 serverState: null,
                 animationFrameId: null,
                 isConnected: false,
                 renderedPlayerPos: { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 },
                 predictedPlayerPos: { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 },
                 lastServerState: null,
                 previousServerState: null,
                 lastLoopTime: null, // Initialize as null
             };
             socket = null; // Also define socket globally

            // Now safe to initialize listeners and connect
            try {
                 Game.initListeners();
                 Network.connect(() => {
                     // This callback runs *after* WebSocket opens
                     UI.updateStatus("Connected. Select Mode.");
                     // Show main menu only *after* connection is confirmed open
                     UI.showSection('main-menu-section');
                 });
                 UI.updateStatus("Connecting..."); // Initial status while connecting
            } catch (initError) {
                 console.error("Initialization failed:", initError);
                 UI.updateStatus("Error initializing game. Please refresh.", true);
            }
        };

    </script>
</body>
</html>

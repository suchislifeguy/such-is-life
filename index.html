You're absolutely right. Trying to shoehorn the "create game" / "join game" flow into the existing UI and immediately jumping into the network complexities is causing friction and likely masking underlying issues.

Let's pivot to the approach you suggested:

Clear Start Screen: Offer distinct "Single Player" and "Multiplayer" options.

Multiplayer Flow:

Option to "Host Game" (generates code, shows waiting screen).

Option to "Join Game" (prompts for code).

Single Player: Directly starts the game simulation locally (or potentially connects to a server-side single-player instance if we want server authority even for SP).

This simplifies the initial user interaction and separates the single-player and multiplayer paths earlier.

Client-Side Changes (index.html - Focus on UI Structure & Flow)

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>SUCH IS LIFE - Kelly Gang Survival</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        /* --- (Keep previous CSS) --- */
        :root { /* ... */ }
        body { /* ... */ }
        #game-container { /* ... */ }
        h1 { /* ... */ }

        /* --- Visibility Control --- */
        /* Hide all sections initially */
        #main-menu-section,
        #multiplayer-menu-section,
        #host-wait-section,
        #join-code-section,
        #game-area,
        #game-over-screen {
            display: none;
        }

        #game-status { /* ... */ }
        button { /* ... */ }
        input[type="text"] { /* ... */ }
        #game-canvas { /* ... */ }
        #hud { /* ... */ }
        #player-stats { /* ... */ }
        #game-info { /* ... */ }
        #chat-section { /* ... */ }
        #chatInput { /* ... */ }
        #chat-log { /* ... */ }
        #countdown { /* ... */ }
        #day-night-indicator { /* ... */ }
        #game-over-screen { /* ... */ }

        /* Specific Menu Styles */
        .menu-section {
             padding: 30px; text-align: center;
        }
        .menu-section h2 {
            color: var(--accent-color); margin-bottom: 20px;
        }
        .menu-section button {
            display: block; /* Stack buttons vertically */
            width: 80%;
            max-width: 300px;
            margin: 15px auto; /* Center buttons */
            padding: 15px 20px;
            font-size: 1.2rem;
        }

        #host-wait-section p, #join-code-section p { font-size: 1.1rem; margin-bottom: 10px; }
        #game-code-display { font-size: 1.8rem; font-weight: bold; color: var(--accent-color); background-color: var(--bg-color); padding: 5px 15px; border-radius: 5px; display: inline-block; margin: 10px 0; user-select: all; }
        #waiting-message { margin-top: 15px; font-style: italic;}

    </style>
</head>
<body>
    <div id="game-container">
        <h1>SUCH IS LIFE</h1>
        <div id="game-status">Connecting...</div>

        <!-- 1. Main Menu -->
        <div id="main-menu-section" class="menu-section">
            <h2>Main Menu</h2>
            <button id="singlePlayerBtn">Single Player</button>
            <button id="multiplayerBtn">Multiplayer</button>
            <!-- <button disabled>Options (Soon)</button> -->
            <!-- <button disabled>Credits (Soon)</button> -->
        </div>

        <!-- 2. Multiplayer Menu -->
        <div id="multiplayer-menu-section" class="menu-section">
             <h2>Multiplayer</h2>
             <button id="hostGameBtn">Host Game (Get Code)</button>
             <button id="showJoinUIBtn">Join Game (Enter Code)</button>
             <button class="back-button" onclick="showSection('main-menu-section')">Back</button>
        </div>

        <!-- 3. Host Waiting Screen -->
        <div id="host-wait-section" class="menu-section">
             <h2>Hosting Game</h2>
             <p>Share this code with your mate:</p>
             <div id="game-code-display">------</div>
             <p id="waiting-message">Waiting for opponent to connect...</p>
             <button id="cancelHostBtn">Cancel Hosting</button>
             <!-- Optional: Maybe a mini preview canvas later? -->
        </div>

        <!-- 4. Join Code Input -->
        <div id="join-code-section" class="menu-section">
             <h2>Join Game</h2>
             <p>Enter the 6-character game code:</p>
             <input type="text" id="gameIdInput" placeholder="ABCDEF" maxlength="6">
             <button id="joinGameSubmitBtn">Join Game</button>
             <button class="back-button" onclick="showSection('multiplayer-menu-section')">Back</button>
        </div>

        <!-- 5. Main Game Area -->
        <div id="game-area">
            <!-- (Keep canvas, hud, chat etc. from previous version) -->
            <div style="position: relative;">
                <canvas id="gameCanvas" width="800" height="600"></canvas>
                <div id="countdown"></div>
                <div id="day-night-indicator">Day</div>
            </div>
            <div id="hud">
                 <div id="player-stats">Loading...</div>
                 <div id="game-info">Score: 0 | Level: 1</div>
            </div>
             <div id="chat-section">
                 <input type="text" id="chatInput" placeholder="Say somethin', mate..." maxlength="50">
                 <button id="sendChatBtn">Send</button>
                 <div id="chat-log"></div>
             </div>
             <button id="leaveGameBtn">Leave Game</button>
        </div>

        <!-- 6. Game Over Screen -->
        <div id="game-over-screen">
             <!-- (Keep content from previous version) -->
            <h2>Game Over, Mate!</h2>
            <div id="final-stats"></div>
            <button id="gameOverBackBtn">Back to Menu</button>
        </div>

    </div>

    <script>
        // --- Constants & Utils (Keep from previous) ---
        const WEBSOCKET_URL = 'wss://such-is-life.glitch.me/ws'; // Adjust if needed
        const CANVAS_WIDTH = 800; /* ... other constants ... */
        function getCssVar(varName) { /* ... */ }
        function lerp(start, end, amount) { /* ... */ }
        function distance(x1, y1, x2, y2) { /* ... */ }

        // --- DOM Elements ---
        const DOM = {
            gameContainer: document.getElementById('game-container'),
            gameStatus: document.getElementById('game-status'),
            // Sections
            mainMenuSection: document.getElementById('main-menu-section'),
            multiplayerMenuSection: document.getElementById('multiplayer-menu-section'),
            hostWaitSection: document.getElementById('host-wait-section'),
            joinCodeSection: document.getElementById('join-code-section'),
            gameArea: document.getElementById('game-area'),
            gameOverScreen: document.getElementById('game-over-screen'),
            // Specific elements
            gameCodeDisplay: document.getElementById('game-code-display'),
            waitingMessage: document.getElementById('waiting-message'),
            gameIdInput: document.getElementById('gameIdInput'),
            canvas: document.getElementById('gameCanvas'),
            ctx: document.getElementById('gameCanvas').getContext('2d'),
            playerStatsDiv: document.getElementById('player-stats'),
            gameInfoDiv: document.getElementById('game-info'),
            countdownDiv: document.getElementById('countdown'),
            dayNightIndicator: document.getElementById('day-night-indicator'),
            finalStatsDiv: document.getElementById('final-stats'),
            chatInput: document.getElementById('chatInput'),
            chatLog: document.getElementById('chat-log'),
            // Buttons (assign listeners in init)
            singlePlayerBtn: document.getElementById('singlePlayerBtn'),
            multiplayerBtn: document.getElementById('multiplayerBtn'),
            hostGameBtn: document.getElementById('hostGameBtn'),
            showJoinUIBtn: document.getElementById('showJoinUIBtn'),
            cancelHostBtn: document.getElementById('cancelHostBtn'),
            joinGameSubmitBtn: document.getElementById('joinGameSubmitBtn'),
            sendChatBtn: document.getElementById('sendChatBtn'),
            leaveGameBtn: document.getElementById('leaveGameBtn'),
            gameOverBackBtn: document.getElementById('gameOverBackBtn'),
            // Back buttons handled via inline onclick or assigned if needed
        };

        // --- Global State (Simplified) ---
        let appState = {
            mode: null, // 'singleplayer', 'multiplayer-host', 'multiplayer-client', 'menu'
            localPlayerId: null,
            currentGameId: null,
            serverState: null, // Last received full state
            // Add other client-side state as needed (interpolation, prediction buffers)
            animationFrameId: null,
            isConnected: false,
            // ... prediction/interpolation state ...
            renderedPlayerPos: { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 },
            predictedPlayerPos: { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 },
            lastServerState: null,
            previousServerState: null,
            lastLoopTime: performance.now(),
        };
        let socket = null; // Single WebSocket connection

        // --- UI Management ---
        const UI = (() => {
            const allSections = Object.values(DOM).filter(el => el.id?.endsWith('-section'));

            function showSection(sectionId) {
                allSections.forEach(s => s.style.display = 'none');
                const sectionToShow = DOM[sectionId] || document.getElementById(sectionId);
                if (sectionToShow) {
                    sectionToShow.style.display = 'block';
                     log(`UI: Showing section: ${sectionId}`);
                } else {
                     error(`UI: Section not found: ${sectionId}`);
                }
            }
            function updateStatus(message, isError = false) {
                 DOM.gameStatus.textContent = message;
                 DOM.gameStatus.style.color = isError ? 'var(--player-color)' : 'var(--accent-color)';
                 if(isError) console.error("Status Update:", message);
                 else console.log("Status Update:", message);
            }
            // Add other UI functions (updateHUD, addChatMessage, showGameOver, etc.)
            // ... include updateHUD, addChatMessage, updateCountdown, updateDayNight from previous client ...
             function updateHUD(player, serverState) {
                 if (!player) { DOM.playerStatsDiv.textContent = "Waiting..."; return; }
                 DOM.playerStatsDiv.innerHTML = `<span>HP:</span> ${player.health}/${player.max_health}<br><span>Armor:</span> ${player.armor}<br><span>Gun:</span> ${player.gun}<br><span>Speed:</span> ${player.speed}<br><span>Kills:</span> ${player.kills} | <span>Score:</span> ${player.score}`;
                 DOM.gameInfoDiv.innerHTML = `Score: ${serverState?.score ?? 0} | Level: ${serverState?.level ?? 1}`;
             }
             function addChatMessage(sender, message, isSelf, isSystem = false) { /* ... same ... */
                const div = document.createElement('div');
                if (isSystem) { div.className = 'system-message'; div.textContent = message; }
                else { div.className = isSelf ? 'my-message' : 'other-message'; div.textContent = `${sender ? `P:${sender.substring(0,4)}` : '???'}: ${message}`; }
                DOM.chatLog.appendChild(div); DOM.chatLog.scrollTop = DOM.chatLog.scrollHeight;
            }
             function updateCountdown(serverState) { /* ... same ... */
                if (serverState?.status === 'countdown' && serverState?.countdown >= 0) { DOM.countdownDiv.textContent = Math.ceil(serverState.countdown); DOM.countdownDiv.style.display = 'block'; DOM.dayNightIndicator.style.display = 'none'; }
                else { DOM.countdownDiv.style.display = 'none'; DOM.dayNightIndicator.style.display = (serverState?.status === 'active') ? 'block' : 'none';}
             }
             function updateDayNight(serverState) { /* ... same ... */
                 if (serverState?.status === 'active') { const isNight = serverState.is_night; DOM.dayNightIndicator.textContent = isNight ? 'Night' : 'Day'; DOM.canvas.style.backgroundColor = isNight ? getCssVar('--bg-color') : '#A0522D'; DOM.dayNightIndicator.style.display = 'block'; }
                 else { DOM.dayNightIndicator.style.display = 'none'; }
             }
             function showGameOver(finalState) { /* ... same, use gameOverBackBtn */
                const player = finalState?.players[appState.localPlayerId]; let statsHtml = "Could not load final stats.";
                if (player) { statsHtml = `<strong>Score:</strong> ${player.score}<br><strong>Kills:</strong> ${player.kills}<br><strong>Level:</strong> ${finalState.level}`; /* ... add teammate ... */ }
                DOM.finalStatsDiv.innerHTML = statsHtml; showSection('gameOverScreen');
             }

            return { showSection, updateStatus, updateHUD, addChatMessage, updateCountdown, updateDayNight, showGameOver };
        })();

        // --- Logging Wrapper ---
        function log(...args) { console.log("[Client]", ...args); }
        function error(...args) { console.error("[Client]", ...args); }

        // --- Network Logic ---
        const Network = (() => {
            let reconnectTimer = null;

            function connect(onOpenCallback) {
                if (socket && socket.readyState !== WebSocket.CLOSED) {
                     log("Connect called but socket exists, state:", socket.readyState);
                     if (socket.readyState === WebSocket.OPEN && onOpenCallback) onOpenCallback();
                     return;
                }
                clearTimeout(reconnectTimer);
                UI.updateStatus('Connecting...');
                log("Attempting WebSocket connection...");

                socket = new WebSocket(WEBSOCKET_URL);

                socket.onopen = () => {
                    log('WebSocket connection established.');
                    appState.isConnected = true;
                    UI.updateStatus('Connected.');
                    showSection('main-menu-section'); // Show main menu on successful connect
                    if (onOpenCallback) onOpenCallback();
                };

                socket.onmessage = handleServerMessage; // Global handler

                socket.onerror = (event) => {
                    error('WebSocket Error:', event);
                    // Don't update status here, onclose will handle it
                };

                socket.onclose = (event) => {
                    error(`WebSocket Closed: Code=${event.code}, Reason=${event.reason}`);
                    const wasConnected = appState.isConnected;
                    appState.isConnected = false;
                    socket = null;
                    Game.resetClientState(false); // Reset game state but don't change UI yet

                    if (event.code === 1000) { // Normal closure
                        UI.updateStatus('Disconnected.');
                        showSection('main-menu-section'); // Go to main menu
                    } else if (wasConnected) { // Abnormal closure after being connected
                         UI.updateStatus('Connection lost. Reconnecting...', true);
                         scheduleReconnect();
                    } else { // Failed initial connection
                         UI.updateStatus('Connection failed. Please refresh.', true);
                         // Disable buttons maybe? Or just let refresh handle it.
                    }
                     if (appState.animationFrameId) { cancelAnimationFrame(appState.animationFrameId); appState.animationFrameId = null; Input.cleanup(); }
                };
            }

            function scheduleReconnect() {
                 clearTimeout(reconnectTimer);
                 reconnectTimer = setTimeout(() => {
                     log("Attempting reconnect...");
                     connect(() => {
                          // On successful reconnect, just show main menu. Rejoining state is complex.
                          UI.updateStatus('Reconnected.');
                          showSection('main-menu-section');
                     });
                 }, 3000); // 3 second delay
            }

            function sendMessage(payload) {
                if (socket && socket.readyState === WebSocket.OPEN) {
                    try {
                        const msg = JSON.stringify(payload);
                        // log("Sending:", msg.substring(0, 100)); // Log truncated message
                        socket.send(msg);
                    } catch (err) { error("Error sending message:", err, payload); }
                } else { error('Cannot send message, WS not open.', payload); }
            }

             function closeConnection(code = 1000, reason = "User action") {
                 clearTimeout(reconnectTimer);
                 if (socket && socket.readyState === WebSocket.OPEN) {
                     log(`Closing WebSocket: ${reason}`);
                     socket.close(code, reason);
                 }
                 socket = null; // Clear ref immediately
                 appState.isConnected = false;
             }

            return { connect, sendMessage, closeConnection };
        })();


        // --- Input Handling (Keep similar structure) ---
        const Input = (() => {
             let keys = {}; let lastShotTime = 0; let movementInterval = null;
             const INPUT_SEND_INTERVAL = 50; // ms

             function setup() { /* ... add listeners ... */
                cleanup(); // Ensure clean state
                document.addEventListener('keydown', handleKeyDown); document.addEventListener('keyup', handleKeyUp);
                DOM.chatInput.addEventListener('keydown', handleChatEnter);
                movementInterval = setInterval(sendMovementInput, INPUT_SEND_INTERVAL);
             }
             function cleanup() { /* ... remove listeners ... */
                 document.removeEventListener('keydown', handleKeyDown); document.removeEventListener('keyup', handleKeyUp);
                 DOM.chatInput.removeEventListener('keydown', handleChatEnter);
                 clearInterval(movementInterval); movementInterval = null; keys = {};
             }
             function handleKeyDown(e) {
                 if (document.activeElement === DOM.chatInput) return;
                 const key = e.key.toLowerCase(); keys[key] = true;
                 if (key === ' ' || key === 'mouse0') handleShooting(); // Left click needs different handling (on canvas)
                 if ([' ','w','a','s','d','arrowup','arrowdown','arrowleft','arrowright'].includes(key)) e.preventDefault();
             }
             function handleKeyUp(e) { keys[e.key.toLowerCase()] = false; }
             function handleChatEnter(e) { if (e.key === 'Enter') { e.preventDefault(); Game.sendChatMessage(); }}
             function getMovementInputVector() { /* ... same logic ... */
                 let dx = 0, dy = 0;
                 if (keys['w'] || keys['arrowup']) dy -= 1; if (keys['s'] || keys['arrowdown']) dy += 1;
                 if (keys['a'] || keys['arrowleft']) dx -= 1; if (keys['d'] || keys['arrowright']) dx += 1;
                 if (dx !== 0 && dy !== 0) { const f = Math.sqrt(2); dx /= f; dy /= f; } return { dx, dy };
             }
             function sendMovementInput() { if (appState.mode === 'singleplayer' || appState.serverState?.status === 'active') { Network.sendMessage({ type: 'player_move', direction: getMovementInputVector() }); }}
             function handleShooting() { /* ... same cooldown logic ... */
                 if (appState.mode !== 'singleplayer' && appState.serverState?.status !== 'active') return;
                 const now = Date.now(); if (now - lastShotTime >= 200) { lastShotTime = now; Network.sendMessage({ type: 'player_shoot', direction: {dx:0, dy:-1} /* TODO: MOUSE AIM */ }); }
             }
             return { setup, cleanup, getMovementInputVector };
        })();

        // --- Rendering Logic (Keep similar structure) ---
        const Renderer = (() => {
            const ctx = DOM.ctx;
            const lerpFactor = 0.2; // Keep interpolation factor
            function drawGame() { /* ... include clearCanvas, getInterpolatedState, drawPlayers, drawEnemies, drawBullets, drawPowerups, drawHealthBar ... */
                 ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                 const now = performance.now();
                 // Decide which state to render based on mode
                 let stateToRender;
                 if (appState.mode === 'singleplayer') {
                     stateToRender = Game.getLocalGameState(); // Need local game state
                     // Apply prediction/reconciliation locally if needed, or just render directly
                     // For simplicity now, render directly from local state
                     if (stateToRender?.players[appState.localPlayerId]) {
                         appState.renderedPlayerPos.x = stateToRender.players[appState.localPlayerId].x;
                         appState.renderedPlayerPos.y = stateToRender.players[appState.localPlayerId].y;
                     }
                 } else { // Multiplayer
                     stateToRender = getInterpolatedState(now); // Use server state + interpolation
                 }

                 if (!stateToRender || !appState.localPlayerId) return;

                 // --- Drawing calls using stateToRender ---
                 drawPowerups(stateToRender.powerups); drawBullets(stateToRender.bullets);
                 drawEnemies(stateToRender.enemies); drawPlayers(stateToRender.players);
            }
             function getInterpolatedState(now) { /* ... same interpolation logic using appState.serverState etc. ... */
                const { serverState, lastServerState, previousServerState } = appState;
                if (!serverState || !lastServerState || !previousServerState || lastServerState.timestamp === previousServerState.timestamp) return serverState;
                const timeBetweenUpdates = lastServerState.timestamp - previousServerState.timestamp; const timeSinceLastUpdate = (now / 1000) - lastServerState.timestamp;
                let factor = (timeSinceLastUpdate / timeBetweenUpdates); // factor = Math.max(0, Math.min(factor, 1.1));
                let iState = JSON.parse(JSON.stringify(serverState)); // Deep copy latest
                ['players', 'enemies', 'bullets', 'powerups'].forEach(key => {
                    if (!iState[key] || !previousServerState[key]) return;
                    Object.keys(iState[key]).forEach(id => {
                        const current = iState[key][id]; const previous = previousServerState[key]?.[id];
                        if (previous && id !== appState.localPlayerId && current.x !== undefined && previous.x !== undefined) { current.x = lerp(previous.x, current.x, factor); current.y = lerp(previous.y, current.y, factor); }
                        else if (id === appState.localPlayerId) { current.x = appState.renderedPlayerPos.x; current.y = appState.renderedPlayerPos.y; } // Use reconciled render pos
                    });
                }); return iState;
            }
            // --- Specific Draw functions (drawPlayerRect etc. placeholders) ---
             function drawPlayers(players) { if (!players) return; Object.values(players).forEach(p => { if (!p || p.health <= 0) return; const isSelf = p.id === appState.localPlayerId; const x = isSelf ? appState.renderedPlayerPos.x : p.x; const y = isSelf ? appState.renderedPlayerPos.y : p.y; drawPlayerRect(x, y, isSelf); drawHealthBar(x, y, p.width, p.health, p.max_health); }); }
             function drawPlayerRect(x, y, isSelf) { ctx.fillStyle = isSelf ? '#DC143C' : '#4682B4'; ctx.fillRect(x - PLAYER_DEFAULTS.width/2, y - PLAYER_DEFAULTS.height/2, PLAYER_DEFAULTS.width, PLAYER_DEFAULTS.height); }
             function drawEnemies(enemies) { if (!enemies) return; Object.values(enemies).forEach(e => { if (!e || e.health <= 0) return; drawEnemyRect(e.x, e.y); drawHealthBar(e.x, e.y, e.width, e.health, e.max_health); }); }
             function drawEnemyRect(x, y) { ctx.fillStyle = '#2E8B57'; ctx.fillRect(x - ENEMY_DEFAULTS.width/2, y - ENEMY_DEFAULTS.height/2, ENEMY_DEFAULTS.width, ENEMY_DEFAULTS.height); }
             function drawBullets(bullets) { if (!bullets) return; Object.values(bullets).forEach(b => { if (!b) return; drawBulletCircle(b.x, b.y, b.owner_type === 'player'); }); }
             function drawBulletCircle(x, y, isPlayer) { ctx.fillStyle = isPlayer ? '#FFEB3B' : '#FFFFFF'; ctx.beginPath(); ctx.arc(x, y, BULLET_DEFAULTS.radius, 0, Math.PI * 2); ctx.fill(); }
             function drawPowerups(powerups) { /* ... same ... */ }
             function drawPowerupSquare(x, y, type) { /* ... same ... */ }
             function drawHealthBar(x, y, width, current, max) { /* ... same ... */
                const barH=5, yOff=-10, currW=Math.max(0,(current/max)*width), perc=current/max; ctx.fillStyle='#555'; ctx.fillRect(x-width/2,y+yOff,width,barH); let c='#F44336'; if(perc>0.66)c='#4CAF50'; else if(perc>0.33)c='#FFC107'; ctx.fillStyle=c; ctx.fillRect(x-width/2,y+yOff,currW,barH);
             }

            return { drawGame };
        })();

        // --- Core Game Logic & State Management ---
        const Game = (() => {

            // --- Local Simulation (for Single Player) ---
            let localGameInstance = null; // Holds a JS simulation if SP mode active

            function startSinglePlayer() {
                log("Starting Single Player Mode...");
                appState.mode = 'singleplayer';
                resetClientState(false); // Clear MP state but don't reset UI yet
                // For now, still use server for SP (simpler to manage code)
                // If purely local simulation needed, create JS Game class here.
                // Let's assume SP still requires server connection for now.
                UI.updateStatus("Starting Single Player...");
                Network.sendMessage({ type: 'start_single_player' }); // Tell server
                // Server will reply with game state for SP game
            }

             function hostMultiplayer() {
                 log("Starting Multiplayer Host Mode...");
                 appState.mode = 'multiplayer-host';
                 UI.updateStatus("Creating game...");
                 Network.sendMessage({ type: 'create_game' }); // Server replies with game_created
             }

             function joinMultiplayer() {
                 const gameId = DOM.gameIdInput.value.trim().toUpperCase();
                 if (!gameId || gameId.length !== 6) { UI.updateStatus('Invalid Game ID.', true); return; }
                 log(`Attempting to join game: ${gameId}`);
                 appState.mode = 'multiplayer-client';
                 UI.updateStatus(`Joining game ${gameId}...`);
                 Network.sendMessage({ type: 'join_game', game_id: gameId });
             }

             function leaveGame() {
                 log("Leaving current game...");
                 Network.closeConnection(1000, "User left game");
                 resetClientState(true); // Reset state and UI to main menu
             }

             function sendChatMessage() { /* ... same chat logic ... */
                const msg = DOM.chatInput.value.trim(); if(msg && appState.localPlayerId && appState.currentGameId){ Network.sendMessage({type:'player_chat', message:msg}); DOM.chatInput.value=''; }
             }


             function resetClientState(showMenu = true) {
                 log(`Resetting client state. Show Menu: ${showMenu}`);
                 appState.mode = 'menu';
                 appState.localPlayerId = null;
                 appState.currentGameId = null;
                 appState.serverState = null;
                 appState.lastServerState = null;
                 appState.previousServerState = null;
                 appState.predictedPlayerPos = { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 };
                 appState.renderedPlayerPos = { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 };
                 DOM.chatLog.innerHTML = '';
                 if (appState.animationFrameId) {
                     cancelAnimationFrame(appState.animationFrameId); appState.animationFrameId = null;
                 }
                 Input.cleanup(); // Remove input listeners

                 if (showMenu) {
                     showSection('main-menu-section');
                     UI.updateStatus("Ready."); // Or "Disconnected" if socket closed
                 }
             }

            function startGameLoop() {
                if (appState.animationFrameId) return; // Already running
                log("Starting game loop...");
                appState.lastLoopTime = performance.now();
                Input.setup();

                function loop(currentTime) {
                    if (!appState.serverState && appState.mode !== 'singleplayer') { // Wait for first server state in MP
                         appState.animationFrameId = requestAnimationFrame(loop); return;
                    }
                     // Check if game should stop (e.g., back to menu, game over handled by server state)
                     if (appState.mode === 'menu') { log("Mode is menu, stopping loop."); cleanupLoop(); return; }


                    const deltaTime = (currentTime - appState.lastLoopTime) / 1000;
                    appState.lastLoopTime = currentTime;

                    if (appState.mode !== 'singleplayer') { // Multiplayer Prediction/Reconciliation
                        if (appState.serverState?.status === 'active') {
                             updatePredictedPosition(deltaTime); reconcileWithServer();
                        } else if (appState.serverState?.status === 'countdown' || appState.serverState?.status === 'waiting'){
                            const serverPlayer = appState.serverState?.players[appState.localPlayerId];
                            if(serverPlayer){ appState.predictedPlayerPos.x = serverPlayer.x; appState.predictedPlayerPos.y = serverPlayer.y; appState.renderedPlayerPos.x = serverPlayer.x; appState.renderedPlayerPos.y = serverPlayer.y; }
                        }
                    }
                    // else { /* Handle local simulation update if purely client-side SP */}

                    Renderer.drawGame();
                    appState.animationFrameId = requestAnimationFrame(loop);
                }
                appState.animationFrameId = requestAnimationFrame(loop);
            }

             function cleanupLoop() {
                 if (appState.animationFrameId) { cancelAnimationFrame(appState.animationFrameId); appState.animationFrameId = null; }
                 Input.cleanup();
             }

             // --- Prediction/Reconciliation (Multiplayer) ---
             function updatePredictedPosition(deltaTime) { /* ... same logic ... */
                 const moveVector = Input.getMovementInputVector();
                 const player = appState.serverState?.players[appState.localPlayerId];
                 const playerSpeed = player?.speed || 150;
                 if (moveVector.dx === 0 && moveVector.dy === 0) return;
                 appState.predictedPlayerPos.x += moveVector.dx * playerSpeed * deltaTime; appState.predictedPlayerPos.y += moveVector.dy * playerSpeed * deltaTime;
                 appState.predictedPlayerPos.x = Math.max(PLAYER_DEFAULTS.width/2, Math.min(CANVAS_WIDTH - PLAYER_DEFAULTS.width/2, appState.predictedPlayerPos.x));
                 appState.predictedPlayerPos.y = Math.max(PLAYER_DEFAULTS.height/2, Math.min(CANVAS_HEIGHT - PLAYER_DEFAULTS.height/2, appState.predictedPlayerPos.y));
             }
             function reconcileWithServer() { /* ... same logic ... */
                if (!appState.serverState?.players[appState.localPlayerId]) return;
                const serverPos = appState.serverState.players[appState.localPlayerId]; const predictedPos = appState.predictedPlayerPos; const renderedPos = appState.renderedPlayerPos;
                const dist = distance(predictedPos.x, predictedPos.y, serverPos.x, serverPos.y); const threshold=5, lerpFactor=0.2;
                if (dist > threshold) { predictedPos.x = serverPos.x; predictedPos.y = serverPos.y; renderedPos.x = serverPos.x; renderedPos.y = serverPos.y; }
                else { predictedPos.x = lerp(predictedPos.x, serverPos.x, lerpFactor * 0.1); predictedPos.y = lerp(predictedPos.y, serverPos.y, lerpFactor * 0.1); renderedPos.x = lerp(renderedPos.x, predictedPos.x, lerpFactor); renderedPos.y = lerp(renderedPos.y, predictedPos.y, lerpFactor); }
             }


             // --- Local State Accessor (for purely client-side SP rendering) ---
             function getLocalGameState() {
                 // If using client-side simulation, return its state
                 // return localGameInstance ? localGameInstance.getState() : null;
                 // If SP uses server, this isn't needed for rendering (uses serverState)
                 return appState.serverState; // Placeholder if SP uses server
             }


             // --- Initialize Button Listeners ---
             function initListeners() {
                DOM.singlePlayerBtn.onclick = startSinglePlayer;
                DOM.multiplayerBtn.onclick = () => showSection('multiplayer-menu-section');
                DOM.hostGameBtn.onclick = hostMultiplayer;
                DOM.showJoinUIBtn.onclick = () => showSection('join-code-section');
                DOM.cancelHostBtn.onclick = leaveGame; // Same as leaving
                DOM.joinGameSubmitBtn.onclick = joinMultiplayer;
                DOM.sendChatBtn.onclick = sendChatMessage;
                DOM.leaveGameBtn.onclick = leaveGame;
                DOM.gameOverBackBtn.onclick = () => { resetClientState(true); }; // Explicitly show menu
                // Add listeners for back buttons if not using inline onclick
                DOM.gameContainer.querySelectorAll('.back-button').forEach(btn => {
                    const target = btn.getAttribute('onclick')?.match(/'([^']+)'/)?.[1];
                    if (target) btn.onclick = () => showSection(target); // Assign direct function
                });
             }


            return {
                resetClientState, startGameLoop, sendChatMessage,
                getLocalGameState, // If needed for rendering SP
                initListeners
             };
        })();

        // --- Global Server Message Handler ---
        function handleServerMessage(event) {
            try {
                const data = JSON.parse(event.data);
                log("Received:", data.type); // Log message type

                switch (data.type) {
                    case 'game_created': // HOST perspective
                        appState.localPlayerId = data.player_id;
                        appState.currentGameId = data.game_id;
                        appState.serverState = data.initial_state;
                        const player = appState.serverState?.players[appState.localPlayerId];
                        if (player) { appState.predictedPlayerPos = {x:player.x, y:player.y}; appState.renderedPlayerPos = {x:player.x, y:player.y}; }
                        DOM.gameCodeDisplay.textContent = appState.currentGameId;
                        UI.updateStatus(`Game hosted. Code: ${appState.currentGameId}`);
                        showSection('host-wait-section');
                        Game.startGameLoop(); // Start loop to potentially show waiting animations/updates
                        break;

                    case 'game_joined': // CLIENT perspective (after sending join request)
                        appState.localPlayerId = data.player_id;
                        appState.currentGameId = data.game_id;
                        appState.serverState = data.initial_state; // Should include countdown state
                         const joinedPlayer = appState.serverState?.players[appState.localPlayerId];
                         if (joinedPlayer) { appState.predictedPlayerPos = {x:joinedPlayer.x, y:joinedPlayer.y}; appState.renderedPlayerPos = {x:joinedPlayer.x, y:joinedPlayer.y}; }
                        UI.updateStatus(`Joined game ${appState.currentGameId}. Get ready!`);
                        showSection('game-area');
                        Game.startGameLoop(); // Start rendering/input loop
                        break;

                    case 'sp_game_started': // Response to 'start_single_player'
                         appState.localPlayerId = data.player_id;
                         appState.currentGameId = data.game_id; // Server manages SP game instance too
                         appState.serverState = data.initial_state; // Should be 'active' state
                         const spPlayer = appState.serverState?.players[appState.localPlayerId];
                         if (spPlayer) { appState.predictedPlayerPos = {x:spPlayer.x, y:spPlayer.y}; appState.renderedPlayerPos = {x:spPlayer.x, y:spPlayer.y}; }
                         UI.updateStatus("Single Player Game Started!");
                         showSection('game-area');
                         Game.startGameLoop();
                         break;

                    case 'game_state':
                        const previousStatus = appState.serverState?.status;
                        // Store state history for interpolation
                        appState.previousServerState = appState.lastServerState;
                        appState.lastServerState = appState.serverState;
                        appState.serverState = data.state;

                        // Handle transitions based on server state
                        if (appState.serverState.status === 'waiting' && previousStatus === 'countdown') {
                             // Opponent left during countdown? Show waiting screen again.
                             UI.updateStatus("Opponent left. Waiting...", true);
                             showSection('host-wait-section'); // If host
                             // Need logic for client if host leaves? Server should handle.
                        } else if (appState.serverState.status === 'countdown' && previousStatus === 'waiting') {
                             // Opponent joined (Host perspective) or game starting (Joiner perspective)
                             UI.updateStatus("Opponent joined! Countdown starting...");
                             showSection('game-area'); // Ensure game area is visible
                             if (!appState.animationFrameId) Game.startGameLoop(); // Ensure loop running
                        } else if (appState.serverState.status === 'active' && previousStatus === 'countdown') {
                             UI.updateStatus("Game active!");
                             // Ensure loop running
                             if (!appState.animationFrameId) Game.startGameLoop();
                        }

                        // Update HUD etc. based on current state
                        if (appState.serverState.status !== 'finished') {
                             if (appState.serverState.status === 'waiting' && appState.mode === 'multiplayer-host') {
                                DOM.waitingMessage.textContent = `Waiting for opponent... (${Object.keys(appState.serverState.players).length}/2)`;
                             } else if (appState.serverState.status !== 'waiting') {
                                 const player = appState.serverState.players[appState.localPlayerId];
                                 UI.updateHUD(player, appState.serverState);
                                 UI.updateCountdown(appState.serverState);
                                 UI.updateDayNight(appState.serverState);
                             }
                        }

                        // Handle game over state
                        if (appState.serverState.game_over && previousStatus !== 'finished') {
                             UI.showGameOver(appState.serverState);
                             // Loop will stop naturally if mode changes or based on game_over flag
                        }
                        break;

                    case 'chat_message':
                         UI.addChatMessage(data.sender_id, data.message, data.sender_id === appState.localPlayerId);
                         break;

                    case 'error':
                        error('Server Error:', data.message);
                        UI.updateStatus(`Error: ${data.message}`, true);
                        // If join failed, go back to MP menu or join UI
                        if (appState.mode === 'multiplayer-client' && (data.message.includes('not found') || data.message.includes('not waiting') || data.message.includes('full'))) {
                             showSection('join-code-section'); // Let them retry
                             appState.mode = 'menu'; // Reset mode logic
                        }
                        // Handle other errors? Maybe back to main menu.
                        break;

                    default:
                        log('Unknown message type:', data.type);
                }

            } catch (err) {
                error('Error processing server message:', err, event.data);
                 UI.updateStatus('Error processing server message.', true);
            }
        }


        // --- Global Init ---
        function showSection(sectionId) { // Make globally accessible for inline buttons too
             UI.showSection(sectionId);
        }
        window.onload = () => {
            UI.updateStatus("Initializing...");
            Game.initListeners(); // Setup button clicks
            Network.connect(() => {
                 // On initial connection, show main menu
                 showSection('main-menu-section');
            }); // Connect automatically
            Game.resetClientState(true); // Initial state reset and show menu
        };

    </script>
</body>
</html>


Server-Side Changes (server.py)

Add Single Player Handling:

Add a new message type 'start_single_player'.

In websocket_handler, when this message is received, call a new method like network_server.create_single_player_game(ws).

create_single_player_game: Similar to create_game but only adds one player, immediately sets the game status to active (skipping waiting/countdown), starts the loop, and sends back a sp_game_started message with the initial state.

# --- Add to KellyGangGameServer class ---

    async def create_single_player_game(self, ws):
        player_id = generate_id()
        game_id = f"SP_{generate_id()[:5].upper()}" # Distinguish SP games
        log.info(f"Attempting SP game create {game_id} for player {player_id}")

        game = None
        try:
            game = Game(game_id, player_id, self.broadcast_state_callback)
            if not game.add_player(player_id): raise RuntimeError("Failed add_player (SP)")

            # --- Crucial Difference: Immediately start the game ---
            game.status = 'active' # Skip waiting/countdown
            game.level = 1; game.score = 0; game.is_night = False
            game.day_night_timer = DAY_NIGHT_CYCLE_DURATION / 2
            game.enemy_spawn_timer = game._get_current_enemy_spawn_interval()
            game.powerup_spawn_timer = POWERUP_SPAWN_INTERVAL
            # Reset player if needed (though add_player sets defaults)
            player = game.players[player_id]
            player['health'] = player['max_health']
            log.info(f"[Game {game_id}] Initialized directly to active state for SP.")
            # ---

            self.games[game_id] = game
            self.clients[player_id] = ws
            self.player_to_game[player_id] = game_id
            log.info(f"SP Game {game_id} created, host {player_id} mapped.")

            initial_state = game.get_state()
            # Send a specific message type for SP start
            payload = {'type': 'sp_game_started', 'game_id': game_id, 'player_id': player_id, 'initial_state': initial_state}

            if not await self._send_to_player(player_id, payload):
                 raise ConnectionError(f"Failed to send sp_game_started to {player_id}")

            game.loop_task = asyncio.create_task(game.run_game_loop())
            log.info(f"SP Game loop started for {game_id}")

            return {'game_id': game_id, 'player_id': player_id}

        except Exception as e:
            log.error(f"EXCEPTION during create_single_player_game {game_id}/{player_id}: {e}", exc_info=True)
            # --- Cleanup ---
            if game: game.finish_game("SP Creation Error")
            if game_id in self.games: del self.games[game_id]
            if player_id in self.clients: del self.clients[player_id]
            if player_id in self.player_to_game: del self.player_to_game[player_id]
            if ws and not ws.closed: await self.close_client_connection(player_id, 1011, "SP Create Error")
            return None

# --- Add to websocket_handler ---
async def websocket_handler(request):
    # ... (ws setup, connection_info etc) ...
    try:
        async for msg in ws:
            # ... (message parsing) ...
            try:
                # ... (existing create_game, join_game handling) ...

                elif msg_type == 'start_single_player': # NEW CASE
                    if connection_info: continue # Don't start SP if already in a game
                    # Call the new SP handler
                    connection_info = await network_server.create_single_player_game(ws)
                    if connection_info:
                         player_id = connection_info['player_id']
                         game_id = connection_info['game_id'] # Store SP game ID too

                elif connection_info and player_id: # Route game actions
                     await network_server.route_to_game(player_id, data)
                # ... (else unassociated message) ...
            # ... (exception handling for message processing) ...
    # ... (finally block with disconnect handling) ...
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Python
IGNORE_WHEN_COPYING_END

Explanation of Changes:

HTML:

Created distinct sections for main-menu, multiplayer-menu, host-wait, join-code.

Added "Single Player" and "Multiplayer" buttons on the main menu.

Added "Host Game" and "Join Game" buttons on the multiplayer menu.

Simplified button IDs and assigned listeners in JS initListeners.

Removed the initial "Play Friend"/"Join Friend" buttons.

JavaScript:

showSection function manages UI visibility based on the new structure.

appState.mode tracks whether the user is in SP, MP host, MP client, or menu.

Button listeners now trigger specific functions (startSinglePlayer, hostMultiplayer, joinMultiplayer, leaveGame).

handleServerMessage updated to handle the new UI sections and the sp_game_started message type.

resetClientState now reliably takes the user back to the main menu UI.

The game loop checks the appState.mode before running prediction/reconciliation (only needed in multiplayer).

Server (server.py):

Added create_single_player_game method to KellyGangGameServer.

This method creates a Game instance, adds one player, sets the status directly to active, starts the loop, and sends sp_game_started.

websocket_handler now listens for start_single_player and calls the new method.

This creates a much clearer user flow and separates the concerns better. Now, single-player can potentially be tested independently, and the multiplayer flow (Host/Join) is distinct. The underlying Game class still handles the core simulation for both modes.

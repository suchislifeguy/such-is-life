<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>SUCH IS LIFE - Kelly Gang Survival</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        /* --- Base Styles & Variables --- */
        :root {
            /* Dark/Green Scheme */
            --dark-bg: #1e2a28;
            --container-bg: #2a3d45; /* Slightly lighter for main container */
            --left-panel-bg: #1e2a28; /* Darker for left info panel */
            --container-border: #111a18;
            --dusty-green: #7a8c79;
            --dark-text: #d0d8d7;
            --accent-gold: #FFD700;

            /* Mappings */
            --bg-color: var(--dark-bg);
            --primary-color: var(--dusty-green);
            --secondary-color: var(--left-panel-bg); /* Use darker bg for panel */
            --accent-color: var(--accent-gold);
            --text-color: var(--dark-text);

            /* Other Colors */
            --player-color: #DC143C; /* Crimson */
            --health-bar-bg: #444;
            --health-bar-high: #66bb6a;
            --health-bar-medium: var(--accent-gold);
            --health-bar-low: var(--player-color);
            --powerup-health: #81c784;
            --powerup-gun: #ba68c8;
            --powerup-speed: #4dd0e1;
            --powerup-armor: #9e9e9e;
            --night-overlay: rgba(0, 0, 10, 0.3);
            --bullet-player-color: #FFEB3B;
            --bullet-enemy-color: #C0C0C0;
            --damage-text-color: #FFFFFF;
            --damage-text-crit-color: var(--accent-gold);
            --campfire-aura-color: rgba(255, 165, 0, 0.15);
            --esc-menu-bg: rgba(10, 20, 25, 0.9);

            /* Other variables */
            --font-family: 'Courier New', monospace;
            --left-panel-width: 360px;
            --damage-text-font-size: 14px;
            --damage-text-crit-font-size: 18px;
        }

        /* --- General Body/Container --- */
        body {
            margin: 0; display: flex; flex-direction: column; justify-content: center;
            align-items: center; min-height: 100vh; background-color: var(--bg-color);
            font-family: var(--font-family); color: var(--text-color);
            overflow: hidden; /* Prevent body scrollbars */
        }

        #game-container {
            background-color: var(--container-bg);
            border: 5px solid var(--container-border);
            border-radius: 15px;
            /* Padding removed from main container, will be added to inner panels */
            padding: 0;
            text-align: center;
            /* Max width calculation accounts for left panel + canvas + padding/borders */
            max-width: calc(var(--left-panel-width) + 1600px + 40px); /* Adjust padding if needed */
            width: calc(100% - 40px);
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.7);
            display: flex; /* Use flex for main container content alignment */
            flex-direction: column; /* Stack menus/game area vertically */
            overflow: hidden; /* Prevent scrollbars on container */
            /* Allow container height to grow based on content, up to screen height */
            max-height: calc(100vh - 40px); /* Adjust based on body padding/margins */
            box-sizing: border-box;
        }

        /* --- Visibility Control --- */
        #main-menu-section,
        #multiplayer-menu-section,
        #host-wait-section,
        #join-code-section,
        #game-area, /* This is the main wrapper for the in-game layout */
        #game-over-screen,
        #esc-menu-overlay { /* Initially hide Esc menu */
            display: none;
        }

        /* --- NEW: In-Game Layout Structure --- */
        #game-area {
            display: flex; /* Use flexbox for the two-column layout */
            flex-direction: row; /* Arrange columns side-by-side */
            width: 100%;
            height: 100%; /* Take up full container height when visible */
            overflow: hidden; /* Prevent internal scrollbars if not needed */
        }

        #left-panel {
            width: var(--left-panel-width);
            flex-shrink: 0; /* Prevent left panel from shrinking */
            background-color: var(--secondary-color); /* Darker background for contrast */
            padding: 15px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column; /* Stack elements vertically */
            border-right: 3px solid var(--container-border);
            overflow-y: auto; /* Allow scrolling ONLY if content overflows height */
            height: 100%; /* Make panel fill vertical space */
        }

        #right-panel {
            flex-grow: 1; /* Allow right panel to take remaining space */
            display: flex; /* Center canvas within this panel */
            justify-content: center;
            align-items: center;
            overflow: hidden; /* Hide anything extending beyond canvas container */
            padding: 10px; /* Optional padding around canvas */
             background-color: #3b5261; /* Default DAY canvas background color, JS will override */
        }

        /* --- Styling for Elements within Left Panel --- */

        /* Title */
        #left-panel h1.game-title { /* Add class to H1 in HTML */
            color: var(--text-color);
            margin: 0 0 15px 0; /* Adjust margin */
            padding: 0;
            line-height: 1.1;
            text-shadow: 2px 2px 5px black;
            font-size: 2.5em;
            font-weight: bold;
            text-align: center; /* Center title in left panel */
        }

        /* Day/Night Indicator */
        #day-night-indicator {
            font-size: 16px; /* Slightly larger */
            font-weight: bold;
            color: var(--text-color);
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px; /* Adjust padding */
            border-radius: 5px;
            display: none; /* JS shows this */
            margin: 0 auto 15px auto; /* Center horizontally, add margin below */
            text-align: center;
            width: fit-content; /* Size to content */
        }

        /* Stats Grid Container */
        #stats-grid-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr); /* 2 equal columns */
            gap: 8px; /* Gap between grid items */
            margin-bottom: 15px; /* Space below the grid */
            width: 100%; /* Take full width of left panel */
        }

        /* Stats Box Refinement (largely unchanged, fits in grid now) */
        .player-stats-box {
            color: var(--text-color);
            font-size: 11px;
            background: rgba(10, 20, 25, 0.6);
            padding: 4px 8px; /* Slightly increased padding */
            border-radius: 4px;
            text-align: left;
            border: 1px solid var(--dusty-green);
            box-sizing: border-box;
            box-shadow: inset 0 0 4px rgba(0,0,0,0.4);
            /* Width is controlled by the grid, remove min/max width maybe */
            /* min-width: 120px; */
            /* max-width: 160px; */
            overflow: hidden; /* Prevent content overflow */
        }

         /* Add styles for empty placeholder grid items if needed */
        .player-stats-box.placeholder {
            background: transparent;
            border: 1px dashed rgba(122, 140, 121, 0.3); /* Dimmer border */
            box-shadow: none;
            /* Ensure it takes up space */
             min-height: 100px; /* Match expected height of filled boxes */
        }

        .player-stats-box .stats-header {
            font-weight: bold;
            color: var(--accent-color);
            text-align: center;
            padding-bottom: 3px; /* Adjust spacing */
            margin-bottom: 3px; /* Adjust spacing */
            border-bottom: 1px dashed var(--primary-color);
            font-size: 13px; /* Slightly larger header */
        }

        .player-stats-box .stats-content {
             line-height: 1.4; /* Adjust line spacing */
        }

        .player-stats-box .stats-content span {
            display: inline-block;
            min-width: 40px; /* Slightly wider label */
            font-weight: bold;
            color: var(--dusty-green);
            padding-right: 3px; /* Space between label and value */
        }

        /* Game Status */
        #game-status {
            min-height: 25px;
            color: var(--accent-color);
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
            font-size: 1.1em; /* Slightly larger status */
            flex-shrink: 0; /* Prevent shrinking */
        }

        /* Chat Section Styling */
        #chat-section {
            display: flex;
            flex-direction: column; /* Stack log and input vertically */
            margin-top: auto; /* Pushes chat to the bottom of the left panel */
            width: 100%;
            padding: 0;
            box-sizing: border-box;
            flex-shrink: 0; /* Prevent shrinking */
            border-top: 1px solid var(--primary-color); /* Separator */
            padding-top: 10px; /* Space above chat log */
        }

        #chat-log {
            /* Set a flexible height, allowing it to grow but also have max */
            height: 150px; /* Example starting height */
            max-height: 250px; /* Limit growth */
            min-height: 80px; /* Ensure some space even if short */
            overflow-y: scroll;
            border: 1px solid var(--primary-color);
            margin-bottom: 8px; /* Space between log and input */
            padding: 6px;
            text-align: left;
            background: rgba(10, 20, 25, 0.5);
            font-size: 13px;
            border-radius: 5px;
            width: 100%; /* Take full width */
            box-sizing: border-box;
            transition: background-color 0.5s ease, border-color 0.5s ease;
            color: var(--dark-text);
            order: 1; /* Ensure log comes first */
            flex-grow: 1; /* Allow log to take up available space before input */
        }

        #chat-input-area { /* New wrapper for input and button */
            display: flex;
            width: 100%;
            order: 2; /* Ensure input comes after log */
            flex-shrink: 0; /* Prevent input area shrinking */
        }

        #chatInput {
             flex-grow: 1; /* Take remaining space */
             margin-right: 5px;
             padding: 8px;
             font-size: 0.9rem;
             /* Remove bottom margin, handled by container */
             margin-bottom: 0;
             /* Ensure input styling is consistent (copied from before) */
             font-family: var(--font-family);
             border: 2px solid var(--primary-color);
             border-radius: 5px;
             background-color: var(--dark-text);
             color: var(--dark-bg);
             text-transform: uppercase;
        }
        #sendChatBtn {
             padding: 8px 15px;
             font-size: 0.9rem;
             /* Remove margins, handled by container/gap */
             margin: 0;
             flex-shrink: 0; /* Prevent button shrinking */
        }

        #chat-log div { margin-bottom: 3px; word-wrap: break-word; }
        #chat-log .my-message { color: var(--bullet-player-color); }
        #chat-log .other-message { color: var(--text-color); }
        #chat-log .system-message { color: var(--accent-color); font-style: italic; }

        /* --- Night Mode Chat Styling (Unchanged) --- */
        #game-container.night-mode #chat-log {
            background-color: rgba(10, 20, 25, 0.7);
            border-color: var(--accent-color);
        }
        /* (Other night mode styles unchanged) */

        /* --- Styling for Elements within Right Panel --- */
        #canvas-wrapper { /* Wrapper for canvas and countdown */
            position: relative;
            /* Ensure wrapper doesn't exceed canvas size */
            width: 1600px;
            height: 900px;
            max-width: 100%; /* Allow shrinking if needed */
            max-height: 100%;
             box-shadow: 0 0 15px rgba(0,0,0,0.5); /* Optional shadow around canvas */
        }

        #gameCanvas {
            border: 3px solid var(--primary-color);
             /* Background color now set on #right-panel or via JS */
            /* background-color: #3b5261; */
            display: block; /* Remove extra space below canvas */
            /* Canvas size set by attributes, let wrapper handle max size */
            width: 100%;
            height: 100%;
            box-sizing: border-box;
            image-rendering: pixelated; /* Optional: For crisp pixel art */
            image-rendering: crisp-edges; /* Broader support */
        }

        #countdown {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 80px; /* Larger countdown */
            color: var(--player-color);
            text-shadow: 3px 3px 8px black; /* Stronger shadow */
            z-index: 10; pointer-events: none; display: none;
            font-weight: bold;
        }

        /* --- Common Elements (Buttons, Inputs) - Largely Unchanged --- */
        button { /* Base button styles */
            background-color: var(--primary-color);
            color: var(--dark-bg);
            border: 2px solid var(--container-border);
            padding: 10px 20px; margin: 10px 5px; cursor: pointer; font-family: var(--font-family);
            font-size: 1rem; transition: background-color 0.2s ease, color 0.2s ease; border-radius: 5px;
            font-weight: bold;
        }
        button:hover:not(:disabled) { background-color: #9cb49a; color: #000; }
        button:disabled { background-color: #555; color: #aaa; cursor: not-allowed; border-color: #444; }

        input[type="text"] { /* Base text input */
             padding: 10px; margin: 10px 5px; /* Keep default margins for menu inputs */
             width: auto; /* Allow natural width unless overridden */
             font-family: var(--font-family); font-size: 1rem;
             border: 2px solid var(--primary-color);
             border-radius: 5px; background-color: var(--dark-text);
             color: var(--dark-bg);
             text-transform: uppercase;
         }

        /* --- Menu Sections Styling (Keep for non-game screens) --- */
        .menu-section {
             padding: 30px; text-align: center;
             box-sizing: border-box;
             width: 100%; /* Menus take full container width */
             color: var(--text-color);
             /* Allow menus to scroll if content exceeds viewport height */
             overflow-y: auto;
             max-height: calc(100vh - 80px); /* Example max height */
        }
        .menu-section h2 { color: var(--accent-color); margin-bottom: 20px; }
        .menu-section button {
            display: block; width: 80%; max-width: 300px;
            margin: 15px auto; padding: 15px 20px; font-size: 1.2rem;
        }
        .menu-section input[type="text"] { /* Specific styling for menu inputs */
            display: inline-block; width: auto; min-width: 180px;
            margin: 10px 5px; /* Restore menu input margins */
        }

        /* --- Host/Join Specific (Unchanged) --- */
         #host-wait-section p, #join-code-section p { font-size: 1.1rem; margin-bottom: 10px; }
         #game-code-display {
             font-size: 1.8rem; font-weight: bold;
             color: var(--accent-color);
             background-color: var(--dark-bg);
             padding: 5px 15px; border-radius: 5px; display: inline-block;
             margin: 10px 0; user-select: all; border: 1px solid var(--primary-color);
         }
         #waiting-message { margin-top: 15px; font-style: italic;}

        /* --- Game Over Screen (Unchanged structurally, check positioning) --- */
        #game-over-screen {
            position: absolute; /* Position relative to game-container */
            top: 50%; left: 50%; transform: translate(-50%, -50%);
            background-color: var(--esc-menu-bg); /* Consistent background */
            padding: 25px;
            border: 3px solid var(--player-color);
            border-radius: 10px; color: var(--accent-color);
            text-align: center; z-index: 20;
            width: 90%; max-width: 400px; /* Slightly wider */
            display: none;
            box-sizing: border-box;
        }
        /* --- Game Over Screen (Positioning relative to game-container) --- */

        /* Apply original styles */
        #game-over-screen h2 {
            color: var(--player-color);
            margin-top: 0;
            margin-bottom: 20px;
            font-size: 1.8em;
        }
        #final-stats {
            margin-bottom: 25px;
            text-align: center;
            color: var(--text-color);
            font-size: 1.3em;
            line-height: 1.6;
        }
        .final-stat-item strong {
             color: var(--accent-color);
             margin-right: 8px;
             display: inline-block;
             min-width: 70px;
             text-align: right;
        }
        #game-over-screen button {
            margin-top: 10px;
            padding: 12px 25px;
            font-size: 1.1rem;
        }

        /* --- NEW: ESC Key Menu Overlay --- */
        #esc-menu-overlay {
            position: absolute;
            top: 0; left: 0; /* Cover entire container */
            width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.7); /* Dark semi-transparent overlay */
            display: none; /* Hidden by default */
            justify-content: center;
            align-items: center;
            z-index: 50; /* Ensure it's above everything */
        }

        #esc-menu-content {
            background-color: var(--left-panel-bg); /* Use panel background */
            padding: 30px 40px;
            border-radius: 10px;
            border: 3px solid var(--primary-color);
            text-align: center;
            box-shadow: 0 5px 25px rgba(0,0,0,0.7);
        }

        #esc-menu-content h2 {
            color: var(--accent-color);
            margin-top: 0;
            margin-bottom: 25px;
            font-size: 1.8em;
        }

        #esc-menu-content button {
            display: block; /* Stack buttons */
            width: 100%; /* Full width within the menu */
            min-width: 200px;
            margin: 15px auto; /* Center horizontally */
            padding: 12px 20px;
            font-size: 1.2rem;
        }


    </style>
</head>
<body>
    <div id="game-container">

        <!-- Menu Sections (Remain outside the main game layout) -->
        <div id="main-menu-section" class="menu-section">
            <h2>Main Menu</h2>
            <button id="singlePlayerBtn">Single Player</button>
            <button id="multiplayerBtn">Multiplayer</button>
        </div>
        <div id="multiplayer-menu-section" class="menu-section">
            <h2>Multiplayer</h2>
            <p style="margin-bottom: 5px;">Choose number of players:</p>
            <button id="hostGameBtn2">Host 2 Player Game</button>
            <button id="hostGameBtn3">Host 3 Player Game</button>
            <button id="hostGameBtn4">Host 4 Player Game</button>
            <hr style="margin: 20px auto; width: 80%; border-color: var(--primary-color);">
            <button id="showJoinUIBtn">Join Game (Enter Code)</button>
            <button class="back-button" onclick="showSection('main-menu-section')">Back</button>
       </div>
        <div id="host-wait-section" class="menu-section">
             <h2>Hosting Game</h2>
             <p>Share this code with your mate:</p>
             <div id="game-code-display">------</div>
             <p id="waiting-message">Waiting for opponent to connect...</p>
             <button id="cancelHostBtn">Cancel Hosting</button>
        </div>
        <div id="join-code-section" class="menu-section">
             <h2>Join Game</h2>
             <p>Enter the 6-character game code:</p>
             <input type="text" id="gameIdInput" placeholder="ABCDEF" maxlength="6">
             <button id="joinGameSubmitBtn">Join Game</button>
             <button class="back-button" onclick="showSection('multiplayer-menu-section')">Back</button>
        </div>

        <!-- NEW Game Area Structure -->
        <div id="game-area">
            <!-- Left Info Panel -->
            <div id="left-panel">
                <h1 class="game-title">SUCH IS LIFE</h1>
                <div id="day-night-indicator" style="display: none;">Day --:--</div>

                <!-- Player Stats Grid -->
                <div id="stats-grid-container">
                     <!-- JS will populate .player-stats-box elements here -->
                     <!-- Example Placeholder Structure (JS needs to generate this) -->
                     <!-- <div class="player-stats-box placeholder"></div> -->
                     <!-- <div class="player-stats-box placeholder"></div> -->
                     <!-- <div class="player-stats-box placeholder"></div> -->
                     <!-- <div class="player-stats-box placeholder"></div> -->
                </div>

                <div id="game-status">Initializing...</div>

                <!-- Chat Section -->
                <div id="chat-section">
                    <div id="chat-log"></div>
                    <div id="chat-input-area">
                        <input type="text" id="chatInput" placeholder="Say somethin'..." maxlength="50">
                        <button id="sendChatBtn">Send</button>
                    </div>
                </div>
            </div>

            <!-- Right Canvas Panel -->
            <div id="right-panel">
                <div id="canvas-wrapper"> {/* Added wrapper */}
                    <canvas id="gameCanvas" width="1600" height="900"></canvas>
                    <div id="countdown"></div> {/* Countdown overlay */}
                </div>
            </div>
        </div>
        <!-- End NEW Game Area Structure -->

        <!-- Game Over Screen (Remains the same structure, positioned absolutely) -->
        <div id="game-over-screen">
            <h2>Game Over, Mate!</h2>
            <div id="final-stats"></div>
            <button id="gameOverBackBtn">Back to Menu</button>
        </div>

        <!-- NEW ESC Menu Overlay -->
        <div id="esc-menu-overlay">
            <div id="esc-menu-content">
                <h2>Paused</h2>
                <button id="resumeGameBtn">Resume</button>
                {/* <!-- Add Settings button here later if needed --> */}
                <button id="escLeaveGameBtn">Leave Game</button>
            </div>
        </div>


    </div> {/* End #game-container */}

    <script>
        // --- Constants (Defined First) ---
        const WEBSOCKET_URL = 'wss://such-is-life.glitch.me/ws'; // UPDATE IF YOUR GLITCH URL CHANGES
        const CANVAS_WIDTH = 1600;
        const CANVAS_HEIGHT = 900;
        // Constants PLAYER_WIDTH etc. remain unchanged...
        const PLAYER_WIDTH = 32; const PLAYER_HEIGHT = 32;
        const ENEMY_WIDTH = 15; const ENEMY_HEIGHT = 25; const BULLET_RADIUS = 4; const POWERUP_SIZE = 12;
        const SHOOT_COOLDOWN = 300; // ms
        const RAPID_FIRE_COOLDOWN_MULTIPLIER = 0.4;
        const INPUT_SEND_INTERVAL = 50; // ms
        const MAX_PLAYERS = 4; // Keep consistent with CSS Grid logic
        const RECONNECT_DELAY = 3000; // ms
        const PLAYER_DEFAULTS = { width: 20, height: 20, max_health: 100 };
        const ENEMY_DEFAULTS = { width: 25, height: 25, max_health: 50 };
        const BULLET_DEFAULTS = { radius: 4 };
        const ENEMY_TYPE_CHASER = 'chaser';
        const ENEMY_TYPE_SHOOTER = 'shooter';
        const BULLET_TYPE_STANDARD = 'standard';
        const BULLET_TYPE_STANDARD_ENEMY = 'standard_enemy';
        const PLAYER_STATUS_ALIVE = 'alive';
        const PLAYER_STATUS_DOWN = 'down';
        const PLAYER_STATUS_DEAD = 'dead';
        // --- End Constants ---

        // --- Utility Functions (Unchanged) ---
        function getCssVar(varName) { return getComputedStyle(document.documentElement).getPropertyValue(varName).trim() || ''; }
        function lerp(start, end, amount) { return start + (end - start) * amount; }
        function distance(x1, y1, x2, y2) { const dx = x1 - x2; const dy = y1 - y2; return Math.sqrt(dx * dx + dy * dy); }

        // --- DOM Elements (UPDATED) ---
        const DOM = {
            gameContainer: document.getElementById('game-container'),
            // Menu Sections
            mainMenuSection: document.getElementById('main-menu-section'),
            multiplayerMenuSection: document.getElementById('multiplayer-menu-section'),
            hostWaitSection: document.getElementById('host-wait-section'),
            joinCodeSection: document.getElementById('join-code-section'),
            // In-Game Layout Sections
            gameArea: document.getElementById('game-area'), // Wrapper for 2-column layout
            leftPanel: document.getElementById('left-panel'),
            rightPanel: document.getElementById('right-panel'),
            // Elements within Left Panel
            gameTitle: document.querySelector('#left-panel h1.game-title'), // Use querySelector for class
            dayNightIndicator: document.getElementById('day-night-indicator'),
            statsGridContainer: document.getElementById('stats-grid-container'), // Container for player stats boxes
            gameStatus: document.getElementById('game-status'),
            chatSection: document.getElementById('chat-section'),
            chatLog: document.getElementById('chat-log'),
            chatInput: document.getElementById('chatInput'),
            sendChatBtn: document.getElementById('sendChatBtn'),
            // Elements within Right Panel
            canvasWrapper: document.getElementById('canvas-wrapper'),
            canvas: document.getElementById('gameCanvas'),
            ctx: document.getElementById('gameCanvas').getContext('2d'),
            countdownDiv: document.getElementById('countdown'),
            // Other Screens
            gameOverScreen: document.getElementById('game-over-screen'),
            finalStatsDiv: document.getElementById('final-stats'),
            gameOverBackBtn: document.getElementById('gameOverBackBtn'),
            // Esc Menu
            escMenuOverlay: document.getElementById('esc-menu-overlay'),
            resumeGameBtn: document.getElementById('resumeGameBtn'),
            escLeaveGameBtn: document.getElementById('escLeaveGameBtn'),
            // Menu Specific Elements (remain unchanged)
            gameCodeDisplay: document.getElementById('game-code-display'),
            waitingMessage: document.getElementById('waiting-message'),
            gameIdInput: document.getElementById('gameIdInput'),
            // Buttons (listeners assigned in Game.initListeners)
            singlePlayerBtn: document.getElementById('singlePlayerBtn'),
            multiplayerBtn: document.getElementById('multiplayerBtn'),
            hostGameBtn2: document.getElementById('hostGameBtn2'),
            hostGameBtn3: document.getElementById('hostGameBtn3'),
            hostGameBtn4: document.getElementById('hostGameBtn4'),
            showJoinUIBtn: document.getElementById('showJoinUIBtn'),
            cancelHostBtn: document.getElementById('cancelHostBtn'),
            joinGameSubmitBtn: document.getElementById('joinGameSubmitBtn'),
            // leaveGameBtn is REMOVED
        };

        // --- Global Client State (Unchanged) ---
        let appState = {
            mode: 'menu', // Start in menu
            localPlayerId: null,
            maxPlayersInGame: null,
            currentGameId: null,
            serverState: null,
            animationFrameId: null,
            isConnected: false,
            isPaused: false, // <<< NEW: Track pause state for Esc menu
            // Interpolation/Prediction State
            renderedPlayerPos: { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 },
            predictedPlayerPos: { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 },
            lastServerState: null,
            previousServerState: null,
            lastLoopTime: performance.now(),
            lastStateReceiveTime: performance.now(),
        };
        // Other global vars unchanged...
        let localPlayerMuzzleFlash = { active: false, endTime: 0, aimDx: 0, aimDy: 0 };
        let hitPauseFrames = 0;
        let activeSpeechBubbles = {};
        let activeEnemyBubbles = {};
        let socket = null;

        // --- Logging Wrapper (Unchanged) ---
        function log(...args) { console.log("[Client]", ...args); }
        function error(...args) { console.error("[Client]", ...args); }

        // --- UI Management "Module" (MODIFIED) ---
        const UI = (() => {
            // Keep track of ALL toggleable sections, including the new Esc menu
            const allSections = [
                DOM.mainMenuSection, DOM.multiplayerMenuSection, DOM.hostWaitSection,
                DOM.joinCodeSection, DOM.gameArea, DOM.gameOverScreen, DOM.escMenuOverlay
            ];

            const gameSections = ['game-area']; // Only 'game-area' represents the active game view

            // showSection now handles the main view toggling
            function showSection(sectionId) {
                allSections.forEach(s => { if(s && s.id !== 'esc-menu-overlay') s.style.display = 'none'; }); // Hide all *except* esc menu

                const sectionToShow = DOM[sectionId] || document.getElementById(sectionId);

                if (sectionToShow) {
                    // Use 'flex' for game-area, 'block' for others
                    sectionToShow.style.display = gameSections.includes(sectionId) ? 'flex' : 'block';
                    log(`UI: Showing section: ${sectionId}`);

                    // Update body class based on whether we are in-game or not
                    if (gameSections.includes(sectionId)) {
                        document.body.classList.add('in-game'); // Add class to body
                    } else {
                        document.body.classList.remove('in-game');
                    }

                } else {
                     error(`UI: Section not found: ${sectionId}`);
                }
            }

            // --- NEW: Toggle Esc Menu ---
            function toggleEscMenu(show) {
                if (DOM.escMenuOverlay) {
                    DOM.escMenuOverlay.style.display = show ? 'flex' : 'none'; // Use flex to center content
                    appState.isPaused = show; // Update global pause state
                    log(`UI: Esc Menu ${show ? 'Shown' : 'Hidden'}. Paused: ${appState.isPaused}`);
                    // Potentially pause/resume game loop or input handling here or in Game module
                } else {
                    error("DOM.escMenuOverlay not found!");
                }
            }

            // updateStatus (Unchanged)
            function updateStatus(message, isError = false) {
                 if (DOM.gameStatus) {
                     DOM.gameStatus.textContent = message;
                     DOM.gameStatus.style.color = isError ? (getCssVar('--player-color') || 'red') : (getCssVar('--accent-color') || 'yellow');
                     // Don't log here, handled by caller if needed
                 } else {
                     error("DOM.gameStatus not found for update:", message);
                 }
            }

            // formatTime (Unchanged)
            function formatTime(totalSeconds) { /* ... */ return ''; }


// --- REWRITTEN updateHUD function for Stats Grid ---
            function updateHUD(localPlayerData, serverState) { // localPlayerData might not be strictly needed if using serverState directly
                const players = serverState?.players;
                const localPlayerId = appState.localPlayerId;
                const statsGridContainer = DOM.statsGridContainer; // Target the grid container

                // --- 1. Check if container exists ---
                if (!statsGridContainer) {
                    error("DOM.statsGridContainer not found for HUD update.");
                    return;
                }

                // --- 2. Clear previous content ---
                statsGridContainer.innerHTML = '';
                let generatedBoxes = 0; // Counter for generated player boxes

                // --- 3. Handle player data ---
                if (players && Object.keys(players).length > 0) {
                    // Sort players: Local player first, then by ID
                    const sortedPlayerIds = Object.keys(players).sort((a, b) => {
                        if (a === localPlayerId) return -1; // Prioritize local player
                        if (b === localPlayerId) return 1;
                        return a.localeCompare(b); // Simple alphabetical sort for others
                    });

                    // --- 4. Generate boxes for actual players ---
                    sortedPlayerIds.forEach(playerId => {
                        // Only generate up to MAX_PLAYERS boxes
                        if (generatedBoxes >= MAX_PLAYERS) return;

                        const playerData = players[playerId];
                        if (!playerData) return; // Skip if data somehow missing

                        const isSelf = (playerId === localPlayerId);
                        const headerText = isSelf ? "YOU" : `P:${playerId.substring(0, 4)}`;

                        // Format health display based on status
                        const healthValue = playerData.health ?? 0;
                        const maxHealth = playerData.max_health ?? 100;
                        const status = playerData.player_status ?? PLAYER_STATUS_ALIVE;
                        let healthDisplay;
                        if (status === PLAYER_STATUS_DEAD) {
                            healthDisplay = `<span style='color: var(--health-bar-low); font-weight: bold;'>DEAD</span>`;
                        } else if (status === PLAYER_STATUS_DOWN) {
                             // Use a distinct color/style for DOWN, maybe orange/yellow?
                            healthDisplay = `<span style='color: var(--health-bar-medium); font-weight: bold;'>DOWN</span>`;
                        } else {
                            // Format as current/max for alive players
                             healthDisplay = `${Math.round(healthValue)}/${maxHealth}`;
                        }

                        // Format other stats (using nullish coalescing for defaults)
                        const armorDisplay = Math.round(playerData.armor ?? 0);
                        const gunDisplay = playerData.gun ?? 1;
                        // Use base_speed from defaults if player speed is missing
                        const speedDisplay = playerData.speed ?? PLAYER_DEFAULTS.base_speed ?? 150;
                        const killsDisplay = playerData.kills ?? 0;
                        const scoreDisplay = playerData.score ?? 0;

                        // Create the HTML string for this player's stats box
                        // Styling/layout is handled by CSS grid rules
                        const statsBoxHTML = `
                            <div class="player-stats-box">
                                <div class="stats-header">${headerText}</div>
                                <div class="stats-content">
                                    <span>HP:</span> ${healthDisplay}<br>
                                    <span>Armor:</span> ${armorDisplay}<br>
                                    <span>Gun:</span> ${gunDisplay}<br>
                                    <span>Speed:</span> ${speedDisplay}<br>
                                    <span>Kills:</span> ${killsDisplay}<br>
                                    <span>Score:</span> ${scoreDisplay}
                                </div>
                            </div>
                        `;

                        // Append the generated box to the grid container
                        statsGridContainer.innerHTML += statsBoxHTML;
                        generatedBoxes++; // Increment the counter
                    });
                }

                // --- 5. Add placeholder boxes if needed ---
                // Fill remaining grid slots (up to MAX_PLAYERS) with placeholders
                while (generatedBoxes < MAX_PLAYERS) {
                    statsGridContainer.innerHTML += `<div class="player-stats-box placeholder"></div>`;
                    generatedBoxes++;
                }

                // --- 6. Update Day/Night Indicator (as before) ---
                // This function is called separately but keep the call here for completeness
                updateDayNight(serverState);

            } // --- End of REWRITTEN updateHUD ---


            // addChatMessage (Unchanged)
            function addChatMessage(sender, message, isSelf, isSystem = false) { /* ... */ }

            // updateCountdown (Small change: check visibility based on pause state)
            function updateCountdown(serverState) {
                 if (DOM.countdownDiv && DOM.dayNightIndicator) {
                     // Hide countdown if paused
                    if (appState.isPaused) {
                         DOM.countdownDiv.style.display = 'none';
                         // Keep day/night indicator potentially visible if game active? Or hide too? Let's hide.
                         DOM.dayNightIndicator.style.display = 'none';
                         return;
                     }

                    if (serverState?.status === 'countdown' && serverState?.countdown >= 0) {
                        DOM.countdownDiv.textContent = Math.ceil(serverState.countdown);
                        DOM.countdownDiv.style.display = 'block';
                        DOM.dayNightIndicator.style.display = 'none';
                    } else {
                        DOM.countdownDiv.style.display = 'none';
                        // Show day/night only if game is active AND not paused
                        DOM.dayNightIndicator.style.display = (serverState?.status === 'active') ? 'inline-block' : 'none';
                    }
                } else {
                    error("DOM.countdownDiv or DOM.dayNightIndicator not found.");
                }
             }

            // updateDayNight (Small change: check visibility based on pause state)
            function updateDayNight(serverState) {
                 if (DOM.dayNightIndicator && DOM.rightPanel && DOM.gameContainer) { // Check rightPanel for background
                     // Hide day/night if paused
                     if (appState.isPaused) {
                         DOM.dayNightIndicator.style.display = 'none';
                         return;
                     }

                     if (serverState?.status === 'active') {
                        const isNight = serverState.is_night;
                        DOM.dayNightIndicator.textContent = isNight ? 'Night' : 'Day';
                        // Update background color of the right panel instead of canvas
                        DOM.rightPanel.style.backgroundColor = isNight ? (getCssVar('--bg-color') || '#1e2a28') : '#3b5261'; // Use game bg or day color
                        DOM.dayNightIndicator.style.display = 'inline-block';

                        // Toggle night-mode class on game-container for broader style changes (like chat)
                        if (isNight) {
                            DOM.gameContainer.classList.add('night-mode');
                        } else {
                            DOM.gameContainer.classList.remove('night-mode');
                        }
                     } else {
                        // Hide indicator and remove class if game not active
                        DOM.dayNightIndicator.style.display = 'none';
                        DOM.gameContainer.classList.remove('night-mode');
                        // Reset right panel background? Or let it persist? Let's reset to default day.
                        DOM.rightPanel.style.backgroundColor = '#3b5261';
                     }
                 } else {
                      error("DOM.dayNightIndicator, DOM.rightPanel, or DOM.gameContainer not found for day/night update.");
                 }
             }

            // showGameOver (Unchanged)
            function showGameOver(finalState) { /* ... */ }

            // Expose necessary UI functions
            return {
                showSection,
                toggleEscMenu, // <<< ADDED
                updateStatus,
                updateHUD,
                addChatMessage,
                updateCountdown,
                updateDayNight,
                showGameOver
            };
        })(); // <-- This closes the UI IIFE

        // --- Network "Module" (Unchanged) ---
        const Network = (() => {
            let reconnectTimer = null;
            function connect(onOpenCallback) { /* ... */ }
            function scheduleReconnect() { /* ... */ }
            function sendMessage(payload) { /* ... */ }
             function closeConnection(code = 1000, reason = "User action") { /* ... */ }
            return { connect, sendMessage, closeConnection };
        })();

        // --- Input Handling "Module" (MODIFIED for Esc key) ---
        const Input = (() => {
             let keys = {};
             let lastShotTime = 0;
             let movementInterval = null;
             let mouseCanvasPos = { x: 0, y: 0 };
             let isMouseDown = false;

             function setup() {
                cleanup();
                // Add keydown listener globally
                document.addEventListener('keydown', handleKeyDown);
                document.addEventListener('keyup', handleKeyUp);
                // Chat input listener remains specific
                DOM.chatInput.addEventListener('keydown', handleChatEnter);
                // Mouse listeners remain on canvas/document
                if (DOM.canvas) {
                     DOM.canvas.addEventListener('mousemove', handleMouseMove);
                     DOM.canvas.addEventListener('mousedown', handleMouseDown);
                } else { error("Input setup failed: Canvas element not found."); }
                document.addEventListener('mouseup', handleMouseUp);

                // Movement interval remains
                movementInterval = setInterval(sendMovementInput, INPUT_SEND_INTERVAL);
                log("Input listeners setup.");
             }

             function cleanup() {
                 document.removeEventListener('keydown', handleKeyDown);
                 document.removeEventListener('keyup', handleKeyUp);
                 DOM.chatInput.removeEventListener('keydown', handleChatEnter);
                 if (DOM.canvas) {
                      DOM.canvas.removeEventListener('mousemove', handleMouseMove);
                      DOM.canvas.removeEventListener('mousedown', handleMouseDown);
                 }
                 document.removeEventListener('mouseup', handleMouseUp);
                 clearInterval(movementInterval);
                 movementInterval = null;
                 keys = {};
                 isMouseDown = false;
                 mouseCanvasPos = { x: 0, y: 0 };
                 log("Input listeners cleaned up.");
             }

             // handleMouseMove, handleMouseDown, handleMouseUp (Unchanged)
             function handleMouseMove(event) { /* ... */ }
             function handleMouseDown(event) { /* ... */ }
             function handleMouseUp(event) { /* ... */ }


             // --- MODIFIED handleKeyDown: Includes Esc Menu Toggle ---
             function handleKeyDown(e) {
                // --- 1. Handle ESC Key First (if in game) ---
                if (e.key === 'Escape' && document.body.classList.contains('in-game')) {
                    e.preventDefault(); // Prevent browser default Esc behavior
                    // Toggle the menu (show if hidden, hide if shown)
                    UI.toggleEscMenu(!appState.isPaused); // Pass the desired *new* state
                    return; // Handled Esc, do nothing else
                }

                // --- 2. Ignore Game Inputs if Paused or Typing Chat ---
                if (appState.isPaused || document.activeElement === DOM.chatInput) {
                    // If paused, ONLY allow Esc (already handled) or Enter in chat (handled separately)
                    // If typing chat, Enter is handled by handleChatEnter, other keys ignored here
                    return;
                }
                 // --- END Pause/Chat Focus Check ---


                 // --- 3. Process Game Keys (if not paused/typing chat) ---
                 const key = e.key.toLowerCase();

                 // Movement & Space (Hold Keys)
                 if (['w','a','s','d','arrowup','arrowdown','arrowleft','arrowright',' '].includes(key)) {
                    if (!keys[key]) { keys[key] = true; }
                    e.preventDefault();
                    return; // Handled hold key start
                 }

                 // Pushback ('E' - Event Key)
                 if (key === 'e') {
                     // Check game state (active check now implies not paused)
                     if (appState.serverState?.status === 'active' && appState.isConnected) {
                         log("Sending player_pushback message.");
                         Network.sendMessage({ type: 'player_pushback' });
                         e.preventDefault();
                     } else { log("Pushback ('e') ignored: Game not active or not connected."); }
                     return; // Handled 'e'
                 }
                 // --- End Game Key Processing ---
             }
             // --- End modification ---


             // handleKeyUp (Unchanged - clears hold flags)
             function handleKeyUp(e) {
                 const key = e.key.toLowerCase();
                 if (['w','a','s','d','arrowup','arrowdown','arrowleft','arrowright',' '].includes(key)) {
                     if (keys[key]) { keys[key] = false; }
                 }
             }

             // handleChatEnter (Unchanged - handles Enter specifically for chat input)
             function handleChatEnter(e) {
                 if (e.key === 'Enter') {
                     e.preventDefault();
                     log("Enter key detected in chat input.");
                     Game.sendChatMessage(); // Attempt to send
                 }
             }

             // getMovementInputVector (Unchanged)
             function getMovementInputVector() { /* ... */ return {dx:0, dy:0}; }

             // sendMovementInput (Add Pause Check)
             function sendMovementInput() {
                 // Don't send movement if paused
                 if (appState.isPaused) return;

                 // Original checks remain
                 if (appState.mode !== 'menu' && appState.serverState?.status === 'active' && appState.isConnected) {
                    const moveVector = getMovementInputVector();
                    Network.sendMessage({ type: 'player_move', direction: moveVector });
                 }
             }

            // handleShooting (Add Pause Check)
            function handleShooting() {
                // Don't shoot if paused
                if (appState.isPaused) return;

                // Original checks remain
                if (appState.serverState?.status !== 'active') return;
                const playerState = appState.serverState?.players?.[appState.localPlayerId];
                const currentAmmo = playerState?.active_ammo_type || 'standard';
                let actualShootCooldown = SHOOT_COOLDOWN;
                if (currentAmmo === 'ammo_rapid_fire') { /* ... adjust cooldown ... */ }
                const now = Date.now();
                if (now - lastShotTime < actualShootCooldown) { return; }
                lastShotTime = now;

                // Muzzle flash logic...
                /* ... */

                // Send message (Unchanged)
                log("Sending shoot message with Target Coords:", mouseCanvasPos);
                Network.sendMessage({
                    type: 'player_shoot',
                    target: { x: mouseCanvasPos.x, y: mouseCanvasPos.y }
                });
            }

            // isShootHeld (Unchanged)
            function isShootHeld() {
                return keys[' '] || isMouseDown;
            }

            // Expose functions
            return {
                setup,
                cleanup,
                getMovementInputVector,
                handleShooting,
                isShootHeld
            };

        })(); // End Input IIFE

        // --- Rendering "Module" ---
        const Renderer = (() => {
            const ctx = DOM.ctx;
            const lerpFactor = parseFloat(getCssVar('--lerp-factor')) || 0.2;

            // Define enemy type constants locally to match backend
            const ENEMY_TYPE_CHASER = 'chaser';
            const ENEMY_TYPE_SHOOTER = 'shooter';
            const BULLET_TYPE_STANDARD = 'standard';
            const BULLET_TYPE_STANDARD_ENEMY = 'standard_enemy';

         // Inside Renderer module IIFE...

            function drawDamageTexts(damageTexts) {
                    if (!damageTexts) return;

                    const now = performance.now(); // Get current time for animation calc
                    const normalColor = getCssVar('--damage-text-color') || '#FFFFFF';
                    const critColor = getCssVar('--damage-text-crit-color') || '#FFD700';
                    const normalFontSizeBase = 14; // Base size from CSS or default
                    const critFontSizeBase = 18;   // Base crit size from CSS or default
                    const fontFamily = getCssVar('--font-family') || 'monospace';
                    const pulseDuration = 250; // How long the pulse effect lasts (in ms)
                    const pulseMaxSizeIncrease = 4; // How many extra pixels font size increases at peak

                    // Attempt to parse font sizes from CSS vars, use defaults if failed
                    const normalFontSize = parseInt(getCssVar('--damage-text-font-size'), 10) || normalFontSizeBase;
                    const critFontSize = parseInt(getCssVar('--damage-text-crit-font-size'), 10) || critFontSizeBase;


                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';

                    Object.values(damageTexts).forEach(dmgText => {
                        if (!dmgText) return;

                        const x = dmgText.x ?? 0;
                        const y = dmgText.y ?? 0;
                        const text = dmgText.text ?? '?';
                        const isCrit = dmgText.is_crit ?? false;
                        const spawnTime = dmgText.spawn_time ? dmgText.spawn_time * 1000 : now; // Convert backend seconds to ms
                        const timeSinceSpawn = now - spawnTime;

                        let currentFontSize = isCrit ? critFontSize : normalFontSize;
                        let currentFillColor = isCrit ? critColor : normalColor;

                        // --- Add Pulse Effect for Crits ---
                        if (isCrit && timeSinceSpawn < pulseDuration) {
                            // Calculate pulse progress (0 to 1, then back to 0) using sine wave
                            const pulseProgress = Math.sin((timeSinceSpawn / pulseDuration) * Math.PI); // Goes 0 -> 1 -> 0
                            // Increase font size based on progress
                            currentFontSize += pulseProgress * pulseMaxSizeIncrease;
                            // Optional: Slightly brighten color? (Could lerp towards white)
                            // Example: Lerp between critColor and white - might be too much
                            // const white = '#FFFFFF';
                            // currentFillColor = lerpColor(critColor, white, pulseProgress * 0.5); // Need a lerpColor helper
                        }
                        // --- End Pulse Effect ---

                        // Set final font and color
                        ctx.font = `bold ${Math.round(currentFontSize)}px ${fontFamily}`; // Round size to integer
                        ctx.fillStyle = currentFillColor;

                        // Optional: Shadow
                        ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                        ctx.shadowBlur = 3; ctx.shadowOffsetX = 1; ctx.shadowOffsetY = 1;

                        // Draw the text
                        ctx.fillText(text, x, y);

                        // Reset shadow
                        ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0;
                        ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 0;
                    });
                } 

            function drawCampfire(campfireData) {
                // Only draw if campfire data exists and it's active (night time)
                if (!campfireData || !campfireData.active) {
                    return;
                }

                const x = campfireData.x ?? CANVAS_WIDTH / 2;
                const y = campfireData.y ?? CANVAS_HEIGHT / 2;
                const radius = campfireData.radius ?? 0; // Aura radius

                if (radius <= 0) return; // Don't draw if radius is invalid

                // --- Settings for Campfire Elements ---
                const auraColor = getCssVar('--campfire-aura-color') || 'rgba(255, 255, 0, 0.15)';
                const stickColor = '#8B4513'; // SaddleBrown
                const stickWidth = 20;
                const stickHeight = 4;
                const flameColorOuter = 'rgba(255, 165, 0, 0.6)'; // Semi-transparent Orange
                const flameColorInner = 'rgba(255, 255, 0, 0.7)'; // Semi-transparent Yellow
                const flameWidth = 15;
                const flameHeight = 25;
                // --------------------------------------

                // Use save/restore for rotations and state changes
                ctx.save();

                // 1. Draw the Aura (Behind everything else)
                ctx.fillStyle = auraColor;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();

                // 2. Draw the Sticks (Centered around x, y but slightly lower)
                const stickOffsetY = 5; // Move sticks slightly down from exact center
                ctx.fillStyle = stickColor;
                ctx.translate(x, y + stickOffsetY); // Move origin to stick center

                // Stick 1 (angled)
                ctx.rotate(Math.PI / 5); // Rotate ~36 degrees
                ctx.fillRect(-stickWidth / 2, -stickHeight / 2, stickWidth, stickHeight);
                ctx.rotate(-Math.PI / 5); // Rotate back

                // Stick 2 (angled other way)
                ctx.rotate(-Math.PI / 6); // Rotate ~-30 degrees
                ctx.fillRect(-stickWidth / 2, -stickHeight / 2, stickWidth, stickHeight);
                ctx.rotate(Math.PI / 6); // Rotate back

                ctx.translate(-x, -(y + stickOffsetY)); // Reset translation

                // 3. Draw the Flame (Above the sticks)
                const flameOffsetY = -10; // Position flame slightly above center
                const flameCenterX = x;
                const flameCenterY = y + flameOffsetY;

                // Draw Outer Flame (Orange Oval)
                ctx.fillStyle = flameColorOuter;
                ctx.beginPath();
                // ellipse(xCenter, yCenter, radiusX, radiusY, rotation, startAngle, endAngle)
                ctx.ellipse(flameCenterX, flameCenterY, flameWidth / 2, flameHeight / 2, 0, 0, Math.PI * 2);
                ctx.fill();

                // Draw Inner Flame (Yellow Oval - slightly smaller and higher)
                ctx.fillStyle = flameColorInner;
                ctx.beginPath();
                ctx.ellipse(flameCenterX, flameCenterY - 3, flameWidth / 3, flameHeight / 3, 0, 0, Math.PI * 2);
                ctx.fill();

                // Restore context to prevent affecting other drawings
                ctx.restore();
            }

            function drawMuzzleFlash(playerX, playerY, aimDx, aimDy) {
                const flashSizeBase = 10;
                const flashSizeVariation = 5;
                const flashColor = 'rgba(255, 220, 50, 0.9)'; // Bright yellow/orange
                const offsetDistance = 12;
                const flashX = playerX + aimDx * offsetDistance;
                const flashY = playerY + aimDy * offsetDistance;
                const flashSize = flashSizeBase + Math.random() * flashSizeVariation;

                ctx.fillStyle = flashColor;
                ctx.beginPath();
                ctx.arc(flashX, flashY, flashSize / 2, 0, Math.PI * 2); // Simple circle
                ctx.fill();
            }

            function drawDamageVignette(intensity) { // Intensity 0 to 1
                if (intensity <= 0) return; // Don't draw if intensity is zero or less
                ctx.save(); // Save current context settings

                // Calculate outer radius to cover canvas corners
                const outerRadius = Math.sqrt(CANVAS_WIDTH * CANVAS_WIDTH + CANVAS_HEIGHT * CANVAS_HEIGHT) / 2;

                // Create gradient from center outwards
                const gradient = ctx.createRadialGradient(
                    CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, 0, // Inner circle (center, radius 0)
                    CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, outerRadius // Outer circle (center, covers canvas)
                );

                // Colors: Transparent center, fading to semi-transparent red at edges
                const redAlpha = 0.4 * intensity; // Base alpha (max 0.4), scaled by intensity
                gradient.addColorStop(0, 'rgba(255, 0, 0, 0)');    // Center transparent
                gradient.addColorStop(0.75, 'rgba(255, 0, 0, 0)'); // Stay transparent until outer part
                gradient.addColorStop(1, `rgba(255, 0, 0, ${redAlpha.toFixed(2)})`); // Fade to red edge

                // Draw the gradient over the whole canvas
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                ctx.restore(); // Restore context settings
            }

            function drawEnemySpeechBubbles(enemiesToRender) {
                const now = performance.now();
                const bubbleFont = 'italic 11px ' + (getCssVar('--font-family') || 'monospace'); // Slightly different?
                const bubbleColor = '#FFAAAA'; // Pale Red / Pink?
                const bubbleBgColor = 'rgba(50, 0, 0, 0.6)'; // Dark red transparent background?
                const textPadding = 3;
                const bubbleOffset = 20;

                ctx.font = bubbleFont;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';

                const enemyIdsToRemove = [];

                for (const enemyId in activeEnemyBubbles) {
                    const bubble = activeEnemyBubbles[enemyId];

                    if (now >= bubble.endTime) {
                        enemyIdsToRemove.push(enemyId);
                        continue;
                    }

                    const enemy = enemiesToRender?.[enemyId]; // Find enemy in current render state

                    if (enemy && enemy.health > 0) { // Check enemy exists and is alive
                        const enemyDrawX = enemy.x; // Use interpolated/current enemy X
                        const enemyDrawY = enemy.y; // Use interpolated/current enemy Y
                        const enemyHeight = enemy.height ?? ENEMY_DEFAULTS.height;

                        const bubbleY = enemyDrawY - (enemyHeight / 2) - bubbleOffset; // Position above head

                        const textMetrics = ctx.measureText(bubble.text);
                        const textWidth = textMetrics.width;
                        const boxWidth = textWidth + textPadding * 2;
                        const approxFontHeight = 11;
                        const boxHeight = approxFontHeight + textPadding * 2;
                        const boxX = enemyDrawX - boxWidth / 2;

                        ctx.fillStyle = bubbleBgColor;
                        ctx.fillRect(boxX, bubbleY - boxHeight, boxWidth, boxHeight);

                        ctx.fillStyle = bubbleColor;
                        ctx.fillText(bubble.text, enemyDrawX, bubbleY - textPadding);
                    } else {
                        // Enemy might have died while bubble was active, mark for removal
                        enemyIdsToRemove.push(enemyId);
                    }
                }

                // Clean up expired/invalid bubbles
                enemyIdsToRemove.forEach(id => {
                    delete activeEnemyBubbles[id];
                });
            }

            function drawSpeechBubbles(playersToRender) {
                const now = performance.now();
                const bubbleFont = 'bold 12px ' + (getCssVar('--font-family') || 'monospace');
                // Use the standard text color directly
                const bubbleColor = getCssVar('--text-color') || '#FFF8DC';
                const bubbleBgColor = 'rgba(0, 0, 0, 0.6)'; // Semi-transparent black background
                const textPadding = 4;
                const bubbleOffset = 30; // How far above the player's head

                ctx.font = bubbleFont;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom'; // Text draws upwards from y position

                const playerIdsToRemove = []; // Keep track of expired bubbles

                for (const playerId in activeSpeechBubbles) {
                    const bubble = activeSpeechBubbles[playerId];

                    if (now >= bubble.endTime) {
                        playerIdsToRemove.push(playerId); // Mark for removal
                        continue; // Skip drawing expired bubble
                    }

                    // Find the player's current rendered position from the passed state
                    const player = playersToRender?.[playerId];

                    // Only draw if player exists and is alive
                    if (player && player.health > 0) {
                        // Use player's draw position
                        const playerDrawX = (playerId === appState.localPlayerId) ? appState.renderedPlayerPos.x : player.x;
                        const playerDrawY = (playerId === appState.localPlayerId) ? appState.renderedPlayerPos.y : player.y;
                        const playerHeight = player.height ?? PLAYER_DEFAULTS.height;

                        const bubbleY = playerDrawY - (playerHeight / 2) - bubbleOffset; // Position above head

                        // Measure text for background box
                        const textMetrics = ctx.measureText(bubble.text);
                        const textWidth = textMetrics.width;
                        const boxWidth = textWidth + textPadding * 2;
                        const approxFontHeight = 12; // Rough height based on font size
                        const boxHeight = approxFontHeight + textPadding * 2;
                        const boxX = playerDrawX - boxWidth / 2; // Center the box

                        // Draw background box
                        ctx.fillStyle = bubbleBgColor;
                        ctx.fillRect(boxX, bubbleY - boxHeight, boxWidth, boxHeight);

                        // Draw text using the standard color
                        ctx.fillStyle = bubbleColor;
                        ctx.fillText(bubble.text, playerDrawX, bubbleY - textPadding); // Y adjusted for padding
                    }
                }

                // Clean up expired bubbles
                playerIdsToRemove.forEach(id => {
                    delete activeSpeechBubbles[id];
                });
            }

            function drawGame() {
                // 1. Preparation
                ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                const now = performance.now();

                // 2. Determine State to Render (SP vs MP/Interpolated)
                let stateToRender;
                if (appState.mode === 'singleplayer') {
                    stateToRender = appState.serverState;
                    // In SP, prediction/interpolation isn't used for the local player.
                    // Directly use server position for rendering.
                    const spPlayer = stateToRender?.players[appState.localPlayerId];
                    if (spPlayer) {
                        appState.renderedPlayerPos.x = spPlayer.x;
                        appState.renderedPlayerPos.y = spPlayer.y;
                    }
                } else { // Multiplayer uses interpolated state
                    stateToRender = getInterpolatedState(now);
                }

                // 3. Guard Clause: Stop if essential render data is missing
                if (!stateToRender || !appState.localPlayerId || !stateToRender.players) {
                    // log("Skipping draw: Missing state, localPlayerId, or players");
                    return;
                }

                // 4. Handle Muzzle Flash State (Decide if it should be drawn)
                let shouldDrawMuzzleFlash = false;
                if (localPlayerMuzzleFlash.active) {
                    if (now < localPlayerMuzzleFlash.endTime) {
                        shouldDrawMuzzleFlash = true; // Still active, mark for drawing this frame
                    } else {
                        localPlayerMuzzleFlash.active = false; // Time expired, deactivate for next frame
                    }
                }

                // --- START DRAWING ---

                // 5. Draw Background Elements
                drawCampfire(stateToRender.campfire); // Call the new function name

                // 6. Draw Transient Effects (On top of background, under entities)
                if (shouldDrawMuzzleFlash) {
                    drawMuzzleFlash(
                        appState.renderedPlayerPos.x, // Use local player's rendered position
                        appState.renderedPlayerPos.y,
                        localPlayerMuzzleFlash.aimDx, // Use stored aim direction
                        localPlayerMuzzleFlash.aimDy
                    );
                }

                // 7. Draw Core Game Entities (Order matters for layering)
                // (Individual draw functions should handle null/undefined checks internally)
                drawPowerups(stateToRender.powerups);
                drawBullets(stateToRender.bullets);
                drawEnemies(stateToRender.enemies);
                drawPlayers(stateToRender.players); // Assumes drawPlayers checks internally
                drawSpeechBubbles(stateToRender.players); // 
                drawEnemySpeechBubbles(stateToRender.enemies); 
                drawDamageTexts(stateToRender.damage_texts); // Draw damage text last (on top)

                // --- DRAW VIGNETTE OVERLAY LAST (Based on Health %) ---
                let vignetteIntensity = 0;
                // Get local player's data from the state we are rendering
                const localPlayer = stateToRender?.players?.[appState.localPlayerId];

                if (localPlayer && localPlayer.max_health > 0) { // Check player exists
                    const healthPercentage = localPlayer.health / localPlayer.max_health;

                    // Set intensity based on health thresholds (matching health bar colors)
                    if (healthPercentage <= 0.33) { // RED health
                        // Intensity scales from 0.6 (at 33%) to 1.0 (at 0%)
                        vignetteIntensity = 0.6 + (0.4 * (1 - (healthPercentage / 0.33)));
                        vignetteIntensity = Math.min(1.0, Math.max(0, vignetteIntensity)); // Clamp 0-1
                    } else if (healthPercentage <= 0.66) { // YELLOW health
                        // Intensity scales from 0 (at 66%) to 0.4 (at 33%)
                        vignetteIntensity = 0.4 * (1 - ((healthPercentage - 0.33) / (0.66 - 0.33)));
                        vignetteIntensity = Math.max(0, vignetteIntensity); // Clamp >= 0
                    }
                    // No intensity if health is GREEN (> 66%)
                }

                // Call the drawing function with the calculated intensity
                drawDamageVignette(vignetteIntensity);
                // ----------------------------------------------------


                // 8. Future Placeholders
                // drawMapObstacles(stateToRender.map);

                // --- END DRAWING ---
            } // End drawGame function

            function getInterpolatedState(now) {
                const { serverState, lastServerState, previousServerState, localPlayerId, renderedPlayerPos } = appState;

                // --- Guard Clauses (remain the same) ---
                if (!serverState) {
                    // console.warn("getInterpolatedState: No serverState available.");
                    return null; // Return null or an empty object if no state exists yet
                }
                if (!lastServerState || !previousServerState || serverState.timestamp === lastServerState.timestamp) {
                    // Not enough history for interpolation, return the latest state directly
                    // Return a shallow copy to prevent accidental modification of the original appState.serverState
                    // elsewhere if the caller modifies the returned object.
                    // return { ...serverState }; // Simple shallow copy (careful with nested objects if they exist)
                    // OR more robustly copy only known top-level properties needed for rendering:
                     const latestStateCopy = {
                         timestamp: serverState.timestamp,
                         status: serverState.status,
                         score: serverState.score,
                         level: serverState.level,
                         is_night: serverState.is_night,
                         day_night_timer_remaining: serverState.day_night_timer_remaining,
                         countdown: serverState.countdown,
                         game_over: serverState.game_over,
                         max_players: serverState.max_players,
                         // Deep copy potentially complex objects if needed, shallow otherwise
                         players: serverState.players ? { ...serverState.players } : {},
                         enemies: serverState.enemies ? { ...serverState.enemies } : {},
                         bullets: serverState.bullets ? { ...serverState.bullets } : {},
                         powerups: serverState.powerups ? { ...serverState.powerups } : {},
                         damage_texts: serverState.damage_texts ? { ...serverState.damage_texts } : {},
                         campfire: serverState.campfire ? { ...serverState.campfire } : null,
                         enemy_speaker_id: serverState.enemy_speaker_id,
                         enemy_speech_text: serverState.enemy_speech_text,
                     };
                    // Crucially, still adjust local player pos in this non-interpolated state
                    if (localPlayerId && latestStateCopy.players[localPlayerId]) {
                        latestStateCopy.players[localPlayerId] = {
                             ...latestStateCopy.players[localPlayerId], // Copy existing player props
                             x: renderedPlayerPos.x, // Override with rendered pos
                             y: renderedPlayerPos.y
                         };
                    }
                    return latestStateCopy;
                 }
                // --- End Guard Clauses ---


                // --- Interpolation Factor Calculation (remains the same) ---
                const timeBetweenServerUpdates = lastServerState.timestamp - previousServerState.timestamp;
                const timeSinceLastServerUpdate = (now / 1000) - lastServerState.timestamp;
                let factor = 0;
                if (timeBetweenServerUpdates > 0.001) {
                    factor = timeSinceLastServerUpdate / timeBetweenServerUpdates;
                }
                factor = Math.max(0, Math.min(factor, 1.5)); // Clamp factor (allow slight extrapolation)
                // --- End Factor Calculation ---


                // --- Build the Interpolated State (NEW LOGIC) ---
                // Start with an empty object
                const iState = {};

                // 1. Copy non-entity, top-level properties from the latest serverState
                //    (Assume these don't need interpolation themselves)
                iState.timestamp = serverState.timestamp; // Keep latest timestamp
                iState.status = serverState.status;
                iState.score = serverState.score;
                iState.level = serverState.level;
                iState.is_night = serverState.is_night;
                iState.day_night_timer_remaining = serverState.day_night_timer_remaining;
                iState.countdown = serverState.countdown;
                iState.game_over = serverState.game_over;
                iState.max_players = serverState.max_players;
                // Copy objects that aren't interpolated entity containers (shallow copy is usually fine)
                // Make sure damage_texts are handled correctly - they have timestamps but aren't lerped
                iState.damage_texts = serverState.damage_texts ? { ...serverState.damage_texts } : {};
                iState.campfire = serverState.campfire ? { ...serverState.campfire } : null;
                iState.enemy_speaker_id = serverState.enemy_speaker_id;
                iState.enemy_speech_text = serverState.enemy_speech_text;


                // 2. Process Entity Collections (Players, Enemies, Bullets, Powerups)
                const entityKeys = ['players', 'enemies', 'bullets', 'powerups'];
                entityKeys.forEach(key => {
                    // Initialize the collection in iState
                    iState[key] = {};

                    // Iterate through entities present in the *latest* server state for this key
                    const currentEntities = serverState[key] || {};
                    Object.keys(currentEntities).forEach(id => {
                        const currentEntity = currentEntities[id];
                        const lastEntity = lastServerState[key]?.[id];
                        const previousEntity = previousServerState[key]?.[id];

                        // Create a shallow copy of the current entity state first
                        // This ensures all non-positional data from the latest state is preserved
                        const interpolatedEntity = { ...currentEntity };

                        // Check if interpolation is possible for this entity's position
                        const canInterpolate = previousEntity && lastEntity &&
                                               previousEntity.x !== undefined && previousEntity.y !== undefined &&
                                               lastEntity.x !== undefined && lastEntity.y !== undefined;

                        // Apply interpolation or specific logic
                        if (key === 'players' && id === localPlayerId) {
                            // --- Local Player ---
                            // Use the reconciled rendered position, not interpolated server position
                            interpolatedEntity.x = renderedPlayerPos.x;
                            interpolatedEntity.y = renderedPlayerPos.y;
                        } else if (canInterpolate) {
                            // --- Remote Entity - Interpolate ---
                            interpolatedEntity.x = lerp(previousEntity.x, lastEntity.x, factor);
                            interpolatedEntity.y = lerp(previousEntity.y, lastEntity.y, factor);
                        }
                        // --- Else (New Entity or Not Interpolatable) ---
                        // No position change needed, the shallow copy already has the latest x, y

                        // Assign the processed entity (copied/interpolated) to our iState
                        iState[key][id] = interpolatedEntity;
                    });
                });
                // --- End Build ---

                return iState; // Return the newly constructed state object
            }

            // No changes needed for drawPlayers - it already correctly consumes
            // the state object passed to it (which will now be the efficiently interpolated one)
            // and uses appState.renderedPlayerPos for the local player.
            function drawPlayers(players) {
                 if (!players) return;
                 Object.values(players).forEach(player => {
                     // Skip if player data is invalid or status is fully DEAD
                     if (!player || player.player_status === PLAYER_STATUS_DEAD) {
                         return;
                     }

                     const isSelf = player.id === appState.localPlayerId;
                     const playerStatus = player.player_status || PLAYER_STATUS_ALIVE; // Default to alive if missing

                     // Determine draw position (use prediction/reconciliation for self)
                     // This logic correctly uses appState.renderedPlayerPos for self,
                     // and the (now interpolated) player.x/y for others.
                     const drawX = isSelf ? appState.renderedPlayerPos.x : player.x;
                     const drawY = isSelf ? appState.renderedPlayerPos.y : player.y;

                     // Get dimensions and health info
                     const width = player.width ?? PLAYER_DEFAULTS.width;
                     const height = player.height ?? PLAYER_DEFAULTS.height;
                     const maxHealth = player.max_health ?? PLAYER_DEFAULTS.max_health;
                     const currentArmor = player.armor ?? 0;

                     // --- GHOST STATE LOGIC ---
                     let isDown = (playerStatus === PLAYER_STATUS_DOWN);
                     let alpha = isDown ? 0.4 : 1.0; // Set transparency if down
                     // --- END GHOST STATE LOGIC ---

                     // --- DRAW PLAYER ---
                     ctx.save(); // Save context before applying alpha
                     ctx.globalAlpha = alpha; // Apply calculated alpha

                     // Pass aim direction only for self (unchanged)
                     const aimDx = isSelf ? localPlayerMuzzleFlash.aimDx : 0;
                     const aimDy = isSelf ? localPlayerMuzzleFlash.aimDy : 0;

                     // Draw the character shape
                     drawPlayerCharacter(drawX, drawY, width, height, isSelf, player, aimDx, aimDy);

                     ctx.restore(); // Restore context (resets globalAlpha)
                     // --- END DRAW PLAYER ---

                     // --- DRAW BARS (Only if ALIVE) ---
                     if (playerStatus === PLAYER_STATUS_ALIVE) {
                         drawHealthBar(drawX, drawY, width, player.health, maxHealth);
                         if (currentArmor > 0) { // Only draw armor bar if armor exists
                             drawArmorBar(drawX, drawY, width, currentArmor);
                         }
                     }
                     // --- END BARS ---
                 });
            }

            function drawPlayerCharacter(x, y, w, h, isSelf, playerState, aimDx, aimDy) {
                // --- Colors ---
                const headColor = '#D2B48C';
                const helmetColor = '#CCCCCC';
                const slitColor = '#222222';
                const coatColor = '#8B4513';
                const torsoColor = isSelf ? '#A00000' : '#004488'; // Red (Self) / Blue (Mate)
                const bootColor = '#222222';
                const gunColor = '#444444';
                // Note: hitFlashColor variable is no longer needed/used here
                const armorOverlayColor = '#C0C0C0';

                // --- Proportions ---
                const headRadius = h * 0.2;
                const bodyHeight = h * 0.5;
                const coatLengthBonus = h * 0.15;
                const bodyWidthTop = w * 0.9;
                const bodyWidthBottom = w * 0.7;
                const coatWidth = w * 1.1;
                const armWidth = w * 0.2;
                const armLength = h * 0.4;
                const helmetWidth = w * 0.85;
                const helmetHeight = h * 0.5;
                const slitWidth = helmetWidth * 0.75;
                const slitHeight = helmetHeight * 0.2;
                const bootSize = 5;
                const bootSpacing = w * 0.3;

                // --- Calculated Positions ---
                const headCenterY = y - (h / 2) + headRadius;
                const bodyTopY = headCenterY + headRadius * 0.8;
                const bodyBottomY = bodyTopY + bodyHeight;
                const coatTopY = bodyTopY + bodyHeight * 0.1;
                const coatBottomY = bodyBottomY + coatLengthBonus;
                const helmetTopY = headCenterY - helmetHeight * 0.4;
                const slitY = helmetTopY + (helmetHeight / 2) - (slitHeight / 2);
                const bootOffsetY = coatBottomY + 2;

                // --- Drawing Order ---
                // 1. Coat
                ctx.fillStyle = coatColor;
                ctx.fillRect(x - coatWidth / 2, coatTopY, coatWidth, coatBottomY - coatTopY);

                // 2. Torso
                ctx.fillStyle = torsoColor;
                ctx.beginPath();
                ctx.moveTo(x - bodyWidthTop / 2, bodyTopY);
                ctx.lineTo(x + bodyWidthTop / 2, bodyTopY);
                ctx.lineTo(x + bodyWidthBottom / 2, bodyBottomY);
                ctx.lineTo(x - bodyWidthBottom / 2, bodyBottomY);
                ctx.closePath();
                ctx.fill();

                // 3. Arms
                ctx.fillRect(x - bodyWidthTop / 2 - armWidth, bodyTopY, armWidth, armLength);
                ctx.fillRect(x + bodyWidthTop / 2, bodyTopY, armWidth, armLength);

                // 4. Helmet Body
                ctx.fillStyle = helmetColor;
                ctx.fillRect(x - helmetWidth / 2, helmetTopY, helmetWidth, helmetHeight);

                // 5. Helmet Slit
                ctx.fillStyle = slitColor;
                ctx.fillRect(x - slitWidth / 2, slitY, slitWidth, slitHeight);

                // 6. Gun Barrel (Local Player Only)
                if (isSelf) {
                    const gunLevel = playerState?.gun ?? 1;
                    const gunLengthBase = 12;
                    const gunLengthBonus = (gunLevel - 1) * 3;
                    const gunLength = gunLengthBase + gunLengthBonus;
                    const gunThickness = 5;
                    const gunOriginY = bodyTopY + bodyHeight / 2;

                    ctx.save();
                    ctx.translate(x, gunOriginY);
                    const angle = Math.atan2(aimDy, aimDx);
                    ctx.rotate(angle);
                    ctx.fillStyle = gunColor;
                    ctx.fillRect(w * 0.1, -gunThickness / 2, gunLength, gunThickness);
                    ctx.restore();
                }

                // 7. Boots (Dynamic Animation)
                ctx.fillStyle = bootColor;
                const dx = playerState?.input_vector?.dx ?? 0;
                const dy = playerState?.input_vector?.dy ?? 0;
                const isMoving = (dx !== 0 || dy !== 0);

                if (isMoving) {
                    const stepDuration = 250;
                    const stepPhase = Math.floor(performance.now() / stepDuration) % 2;
                    if (stepPhase === 0) {
                        ctx.fillRect(x - bootSpacing - bootSize / 2, bootOffsetY, bootSize, bootSize);
                    } else {
                        ctx.fillRect(x + bootSpacing - bootSize / 2, bootOffsetY, bootSize, bootSize);
                    }
                } else {
                    ctx.fillRect(x - bootSpacing - bootSize / 2, bootOffsetY, bootSize, bootSize);
                    ctx.fillRect(x + bootSpacing - bootSize / 2, bootOffsetY, bootSize, bootSize);
                }

                // Note: The Hit Flash drawing block based on playerState?.hit_flash_this_tick has been removed.

            } 

            function drawEnemies(enemies) {
                if (!enemies) return;
                const now = performance.now() / 1000; // Get current time in seconds
                const FADE_DURATION = 0.5; // Still use this duration constant for the window

                Object.values(enemies).forEach(enemy => {
                    if (!enemy) return; // Skip invalid enemy data

                    const width = enemy.width ?? ENEMY_DEFAULTS.width;
                    const height = enemy.height ?? ENEMY_DEFAULTS.height;
                    const maxHealth = enemy.max_health ?? ENEMY_DEFAULTS.max_health;

                    // --- CORRECTED FADE LOGIC ---
                    let alpha = 1.0; // Default to fully visible
                    let shouldDraw = true;
                    let isDying = false; // Track if in the dying state

                    // Check if enemy is marked as dying (health <= 0 and has timestamp)
                    if (enemy.health <= 0 && enemy.death_timestamp) {
                        isDying = true;
                        const elapsed = now - enemy.death_timestamp;

                        // If within the 0.5 second window after death
                        if (elapsed < FADE_DURATION) {
                            alpha = 0.4; // Instantly set alpha to 40%
                        } else {
                            // If fade duration has passed, don't draw at all
                            shouldDraw = false;
                        }
                    }
                    // --- END CORRECTED FADE LOGIC ---

                    // --- DRAW ENEMY (only if shouldDraw is true) ---
                    if (shouldDraw) {
                        ctx.save(); // Save context before applying alpha
                        ctx.globalAlpha = alpha; // Apply calculated alpha (1.0 or 0.4)

                        // Call the draw function using the enemy object
                        drawEnemyRect(enemy.x, enemy.y, width, height, enemy.type, enemy);

                        ctx.restore(); // Restore context (resets globalAlpha)
                    }
                    // --- END DRAW ENEMY ---

                    // --- DRAW HEALTH BAR (Only if NOT dying and alive) ---
                    if (!isDying && enemy.health > 0) {
                        drawHealthBar(enemy.x, enemy.y, width, enemy.health, maxHealth);
                    }
                    // --- END HEALTH BAR ---
                });
            } // End drawEnemies


            function drawEnemyRect(x, y, w, h, type, enemyState) { // enemyState includes type, health, etc.
                // --- Colors ---
                const skinColor = '#D2B48C';        // Beige (Face/Head)
                const coatColor = '#8B4513';        // Brown (Coat - same for all enemies for now)
                // Different torso colors for identification
                const torsoColorChaser = '#2F4F4F'; // DarkSlateGray for Chasers
                const torsoColorShooter = '#4682B4'; // SteelBlue for Shooters
                const bootColor = '#222222';        // Dark Grey (Boots)
                const capColor = '#111111';         // Dark Cap instead of helmet
                const hitFlashColor = 'rgba(255, 255, 255, 0.7)';

                // Determine torso color based on enemy type
                const isShooter = type === ENEMY_TYPE_SHOOTER; // Use 'type' passed in
                const torsoColor = isShooter ? torsoColorShooter : torsoColorChaser;

                // --- Proportions (Based on Player Model, adjusted for potentially different w/h) ---
                const headRadius = h * 0.18; // Slightly larger proportion for head without helmet
                const bodyHeight = h * 0.5;
                const coatLengthBonus = h * 0.15;
                const bodyWidthTop = w * 0.9;
                const bodyWidthBottom = w * 0.7;
                const coatWidth = w * 1.1;
                const armWidth = w * 0.2;
                const armLength = h * 0.4;
                const capHeight = headRadius * 0.8; // Cap height relative to head radius
                const capWidth = headRadius * 2.2;  // Cap width relative to head radius
                const bootSize = 5; // Keep boots simple for now
                const bootSpacing = w * 0.3;

                // --- Calculated Positions ---
                // Base calculations on center x, y provided
                const headCenterY = y - (h / 2) + headRadius; // Top-most part is head center now
                const bodyTopY = headCenterY + headRadius * 0.8; // Body starts below head
                const bodyBottomY = bodyTopY + bodyHeight;
                const coatTopY = bodyTopY + bodyHeight * 0.1;
                const coatBottomY = bodyBottomY + coatLengthBonus;
                const armTopY = bodyTopY + bodyHeight * 0.05;
                const capTopY = headCenterY - headRadius; // Cap sits on top of head circle
                const bootOffsetY = coatBottomY + 2;

                // --- Drawing Order (Similar to Player) ---
                ctx.save(); // Isolate drawing state

                // 1. Coat
                ctx.fillStyle = coatColor;
                ctx.fillRect(x - coatWidth / 2, coatTopY, coatWidth, coatBottomY - coatTopY);

                // 2. Torso (Use type-specific color)
                ctx.fillStyle = torsoColor;
                ctx.beginPath();
                ctx.moveTo(x - bodyWidthTop / 2, bodyTopY);
                ctx.lineTo(x + bodyWidthTop / 2, bodyTopY);
                ctx.lineTo(x + bodyWidthBottom / 2, bodyBottomY);
                ctx.lineTo(x - bodyWidthBottom / 2, bodyBottomY);
                ctx.closePath();
                ctx.fill();

                // 3. Arms
                ctx.fillStyle = coatColor; // Arms match coat color
                ctx.fillRect(x - bodyWidthTop / 2 - armWidth, armTopY, armWidth, armLength);
                ctx.fillRect(x + bodyWidthTop / 2, armTopY, armWidth, armLength);

                // 4. Head (Simple Circle)
                ctx.fillStyle = skinColor;
                ctx.beginPath();
                ctx.arc(x, headCenterY, headRadius, 0, Math.PI * 2);
                ctx.fill();

                // 5. Cap (Simple Rectangle on top of head) - Replaces Helmet
                ctx.fillStyle = capColor;
                ctx.fillRect(x - capWidth / 2, capTopY, capWidth, capHeight);

                // 6. Boots (Simple Rectangles)
                ctx.fillStyle = bootColor;
                // Static boots for enemies for now (no walking animation)
                ctx.fillRect(x - bootSpacing - bootSize / 2, bootOffsetY, bootSize, bootSize); // Left
                ctx.fillRect(x + bootSpacing - bootSize / 2, bootOffsetY, bootSize, bootSize); // Right

                // --- Optional: Shooter Barrel ---
                // if (isShooter) {
                //    ctx.fillStyle = '#444444'; // Gun Color
                //    const barrelLength = 10;
                //    const barrelThickness = 4;
                //    const barrelOriginY = bodyTopY + bodyHeight / 2;
                //    // Crude barrel pointing down for now
                //    ctx.fillRect(x - barrelThickness / 2, barrelOriginY, barrelThickness, barrelLength);
                //    // TODO: Could orient based on target direction if available in enemyState
                // }

                ctx.restore(); // Restore drawing state

                // 7. Hit Flash (Draw Last - Uses enemyState passed in)
                if (enemyState?.hit_flash_this_tick) {
                    ctx.fillStyle = hitFlashColor;
                    const flashMargin = 2;
                    // Use the original x, y, w, h for bounding box
                    ctx.fillRect(
                        x - w / 2 - flashMargin,
                        y - h / 2 - flashMargin,
                        w + flashMargin * 2,
                        h + flashMargin * 2
                    );
                    // As noted before, server needs to manage clearing this flag,
                    // or client needs to clear it after rendering once.
                }
            }

            function drawBullets(bullets) {
                if (!bullets) return; // Exit if no bullets data

                Object.values(bullets).forEach(bullet => {
                    if (!bullet) return; // Skip if bullet data is invalid

                    // Extract bullet properties, providing defaults
                    const x = bullet.x ?? 0;
                    const y = bullet.y ?? 0;
                    const vx = bullet.vx ?? 0;
                    const vy = bullet.vy ?? 0;
                    // Use the bullet's specific radius if provided by backend, else default
                    const radius = bullet.radius ?? BULLET_DEFAULTS.radius;
                    // Use bullet type string directly ('standard', 'ammo_shotgun', etc.)
                    const bulletType = bullet.bullet_type || 'standard';
                    const ownerType = bullet.owner_type; // 'player' or 'enemy'

                    // --- Choose Drawing Style Based on Type ---

                    // Check if velocity is valid for angle calculation
                    const hasVelocity = Math.abs(vx) > 0.01 || Math.abs(vy) > 0.01;

                    // Heavy slugs and potentially others might use the shaped drawing
                    if (bulletType === 'ammo_heavy_slug' || bulletType === 'standard' || bulletType === 'ammo_rapid_fire' || bulletType === 'standard_enemy') {
                        if (hasVelocity) {
                            // Pass the whole bullet object to use its radius
                            drawShapedBullet(bullet);
                        } else {
                            // Fallback if velocity is zero (draw simple circle)
                            drawBulletCircle(x, y, radius, ownerType === 'player');
                        }
                    }
                    // Shotgun pellets use the simple circle for now (could customize later)
                    else if (bulletType === 'ammo_shotgun') {
                        // Use the potentially smaller radius sent from backend
                        drawBulletCircle(x, y, radius, ownerType === 'player');
                    }
                    // Fallback for any other unknown types
                    else {
                        drawBulletCircle(x, y, radius, ownerType === 'player');
                    }
                });
            }

            // Draws a simple circle - used as fallback and for shotgun pellets
            function drawBulletCircle(x, y, r, isPlayerBullet) {
                // Determine color based on ownership
                ctx.fillStyle = isPlayerBullet
                                ? (getCssVar('--bullet-player-color') || 'yellow')
                                : (getCssVar('--bullet-enemy-color') || '#C0C0C0'); // Enemy bullets silver/grey

                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2); // Draw circle with given radius
                ctx.fill();
            }

            // Draws the standard rectangle-with-cone bullet, potentially scaled by radius
            // Now accepts the whole bullet object
            function drawShapedBullet(bullet) {
                // Extract properties from bullet object
                const x = bullet.x;
                const y = bullet.y;
                const vx = bullet.vx;
                const vy = bullet.vy;
                const ownerType = bullet.owner_type;
                // Use the bullet's specific radius for scaling
                const radius = bullet.radius || BULLET_DEFAULTS.radius;

                // --- Scaling based on radius ---
                // Make length and width proportional to the bullet's radius
                // Adjust these base values and multiplier as needed for visual appeal
                const baseLength = 8;
                const baseWidth = 4;
                const scaleFactor = radius / BULLET_DEFAULTS.radius; // How much bigger/smaller than default
                const length = baseLength * scaleFactor;
                const width = baseWidth * scaleFactor;
                // --- End Scaling ---

                // Determine color based on owner
                const color = (ownerType === 'player')
                              ? (getCssVar('--bullet-player-color') || 'yellow')
                              : (getCssVar('--bullet-enemy-color') || '#C0C0C0'); // Use consistent enemy bullet color

                // Calculate angle from velocity
                const angle = Math.atan2(vy, vx);

                ctx.save(); // Save context state
                ctx.translate(x, y); // Move origin to bullet position
                ctx.rotate(angle); // Rotate to bullet direction

                // Draw the scaled bullet body (rectangle) centered on the new origin
                ctx.fillStyle = color;
                ctx.fillRect(-length / 2, -width / 2, length, width);

                // Draw the scaled cone nose (triangle)
                const noseLength = length * 0.4; // Make nose proportional to body length
                ctx.beginPath();
                ctx.moveTo(length / 2, 0);                 // Tip of the nose
                ctx.lineTo(length / 2 - noseLength, -width / 2); // Back-left corner of nose base
                ctx.lineTo(length / 2 - noseLength, width / 2);  // Back-right corner of nose base
                ctx.closePath();
                ctx.fill(); // Use same color as body

                ctx.restore(); // Restore context state
            }

            function drawPowerups(powerups) {
                if (!powerups) return; // Exit if no powerups data
                Object.values(powerups).forEach(powerup => {
                    if (!powerup) return; // Skip invalid data

                    const size = powerup.size ?? POWERUP_DEFAULTS.size; // Use default if needed
                    const type = powerup.type; // e.g., 'health', 'armor', 'ammo_shotgun'
                    const subtype = powerup.subtype; // Only present for 'special_ammo' on backend (we don't use it for drawing here)

                    // Pass the main type to the drawing function
                    drawPowerupSquare(powerup.x, powerup.y, size, type);
                });
            }

            function drawPowerupSquare(x, y, size, type) {
                 const baseColors = {
                     'health': getCssVar('--powerup-health') || 'lime',
                     'gun_upgrade': getCssVar('--powerup-gun') || 'fuchsia',
                     'speed_boost': getCssVar('--powerup-speed') || 'aqua',
                     'armor': getCssVar('--powerup-armor') || 'silver',
                 };

                 let fillColor = baseColors[type] || '#888';
                 let symbol = '?';

                 // Determine symbol based on type
                 if (type === 'health') {
                     symbol = '+';
                 } else if (type === 'gun_upgrade') {
                     symbol = 'G';
                 } else if (type === 'speed_boost') {
                     symbol = 'S';
                 } else if (type === 'armor') {
                     symbol = '#'; // Hash for Armor
                 } else if (type === 'ammo_shotgun') {
                     symbol = '::'; // Colon pair for Shotgun spread
                     fillColor = '#FFA500'; // Orange
                 } else if (type === 'ammo_heavy_slug') {
                     symbol = '■'; // Black Square for Heavy Slug (Unicode: U+25A0)
                     fillColor = '#A0522D'; // Brown
                 } else if (type === 'ammo_rapid_fire') {
                     symbol = '>'; // Single '>' for simplicity, maybe '>>' ? Let's try '>'
                     fillColor = '#FFFF00'; // Yellow
                 } else if (type === 'bonus_score') {
                     symbol = '$'; // Dollar sign for score/money
                     fillColor = '#FFD700'; // Gold
                 }
                 // Unknown types will keep '?' and default grey color


                 // Draw background square
                 ctx.fillStyle = fillColor;
                 ctx.fillRect(x - size / 2, y - size / 2, size, size);

                 // Draw symbol in black
                 ctx.fillStyle = '#000'; // Black symbol for contrast
                 // Adjust font size slightly for multi-character symbols if needed
                 let fontSize = Math.round(size * 0.7);
                 if (symbol === '::' || symbol === '>') { // Adjust for potentially wider/taller symbols
                     // fontSize = Math.round(size * 0.6); // Example: slightly smaller
                 }
                 ctx.font = `bold ${fontSize}px monospace`;
                 ctx.textAlign = 'center';
                 ctx.textBaseline = 'middle';
                 ctx.fillText(symbol, x, y + (size * 0.05)); // Keep small vertical offset
            }

            function drawHealthBar(x, y, width, currentHealth, maxHealth) {
                if (maxHealth <= 0) return;
                const barHeight = 5;
                const yOffset = -( (width/2) + 18); // Position above the entity's top edge
                const barWidth = Math.max(20, width * 0.8);
                const currentWidth = Math.max(0, (currentHealth / maxHealth) * barWidth);
                const healthPercentage = currentHealth / maxHealth;
                const barX = x - barWidth / 2;
                const barY = y + yOffset - barHeight; // Align top of bar with yOffset

                ctx.fillStyle = getCssVar('--health-bar-bg') || '#555';
                ctx.fillRect(barX, barY, barWidth, barHeight);

                let barColor = getCssVar('--health-bar-low') || '#F44336';
                if (healthPercentage > 0.66) barColor = getCssVar('--health-bar-high') || '#4CAF50';
                else if (healthPercentage > 0.33) barColor = getCssVar('--health-bar-medium') || '#FFC107';
                ctx.fillStyle = barColor;
                ctx.fillRect(barX, barY, currentWidth, barHeight);
            }

            function drawArmorBar(x, y, width, currentArmor) {
                const maxArmor = 100;
                if (currentArmor <= 0) return;

                const armorBarHeight = 4; // Armor bar height
                const healthBarHeight = 5; // Height of the health bar above it
                const barSpacing = 1;      // Desired gap in pixels

                // --- Calculate position relative to HEALTH bar ---
                // 1. Find the health bar's vertical offset (negative = upwards)
                const healthBarYOffset = -( (width / 2) + 20);
                // 2. Find the absolute Y coordinate of the health bar's TOP edge
                const healthBarTopY = y + healthBarYOffset; // Note: No '- healthBarHeight' here, offset defines top
                // 3. Find the absolute Y coordinate of the health bar's BOTTOM edge
                const healthBarBottomY = healthBarTopY + healthBarHeight;
                // 4. Calculate the armor bar's TOP edge Y coordinate
                const armorBarTopY = healthBarBottomY + barSpacing;
                // ----------------------------------------------

                const barWidth = Math.max(20, width * 0.8);
                const currentWidth = Math.max(0, (currentArmor / maxArmor) * barWidth);
                const barX = x - barWidth / 2;
                const barY = armorBarTopY; // Use the correctly calculated top Y for drawing

                // Optional: Background
                ctx.fillStyle = getCssVar('--health-bar-bg') || '#555';
                ctx.fillRect(barX, barY, barWidth, armorBarHeight); // Use armorBarHeight

                // Armor Bar Fill
                ctx.fillStyle = getCssVar('--powerup-armor') || '#C0C0C0';
                ctx.fillRect(barX, barY, currentWidth, armorBarHeight); // Use armorBarHeight
            }

            // Expose only the main drawing function from the Renderer module
            return { drawGame };
        })(); // End Renderer module IIFE

        const Game = (() => {

            // --- Game Actions ---
            function startSinglePlayer() {
                log("Requesting Single Player game...");
                appState.mode = 'singleplayer';
                resetClientState(false);
                UI.updateStatus("Starting Single Player...");
                Network.sendMessage({ type: 'start_single_player' });
                // Loop starts on server confirmation ('sp_game_started')
            }

            function joinMultiplayer() {
                const gameId = DOM.gameIdInput.value.trim().toUpperCase();
                if (!gameId || gameId.length !== 6) {
                    UI.updateStatus('Invalid Game ID format.', true); return;
                 }
                log(`Attempting to join game: ${gameId}`);
                appState.mode = 'multiplayer-client';
                resetClientState(false);
                UI.updateStatus(`Joining game ${gameId}...`);
                Network.sendMessage({ type: 'join_game', game_id: gameId });
                 // Loop starts on server confirmation ('game_joined')
            }

            function leaveGame() {
                log("Leaving current game / Cancelling host...");
                Network.closeConnection(1000, "User action (leave/cancel)");
                resetClientState(true); // Show menu immediately
            }

            function sendChatMessage() {
                const message = DOM.chatInput.value.trim();
                if (message && appState.isConnected && appState.currentGameId && appState.localPlayerId) {
                    Network.sendMessage({ type: 'player_chat', message: message });
                    DOM.chatInput.value = '';
                } else {
                    log("Cannot send chat: Not connected or not in a game.");
                }
            }

            function resetClientState(showMenu = true) {
                 log(`Resetting client state. Show Menu: ${showMenu}`);
                 cleanupLoop(); // Stop game loop if running first

                 // --- DO NOT RESET appState.mode here ---
                 // Mode is set by the initiating action (startSP, hostMP, joinMP)
                 // or when explicitly returning to menu.

                 appState.localPlayerId = null;
                 appState.currentGameId = null;
                 appState.serverState = null;
                 appState.lastServerState = null;
                 appState.maxPlayersInGame = null; 
                 appState.previousServerState = null;
                 appState.predictedPlayerPos = { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 };
                 appState.renderedPlayerPos = { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 };
                 appState.lastLoopTime = null; // Reset timer

                 // Clear UI elements related to game state
                 DOM.chatLog.innerHTML = '';
                 DOM.gameCodeDisplay.textContent = '------';
                 DOM.gameIdInput.value = '';
                 DOM.countdownDiv.style.display = 'none';
                 DOM.dayNightIndicator.style.display = 'none';
                 DOM.gameOverScreen.style.display = 'none';
                 // Optional: Clear HUD?
                 // DOM.playerStatsDiv.textContent = 'Loading...';
                 // DOM.gameInfoDiv.textContent = 'Score: 0 | Level: 1';


                 // Update UI section and mode only if explicitly returning to menu
                 if (showMenu) {
                     appState.mode = 'menu'; // Set mode to 'menu' ONLY when showing the menu
                     UI.showSection('main-menu-section');
                     UI.updateStatus(appState.isConnected ? "Connected. Select Mode." : "Disconnected.");
                 }
                 // If showMenu is false, we assume we are resetting state *before*
                 // entering a game, and the correct mode ('singleplayer', 'multiplayer-host', etc.)
                 // has already been set by the function that called resetClientState(false).
             }

             // --- Game Loop Management ---

             // Define the main loop function at this scope level
            function gameLoop(currentTime) {
                // --- Hit Pause Check ---
                if (hitPauseFrames > 0) {
                    hitPauseFrames--;
                    if (appState.mode !== 'menu' && appState.isConnected && !appState.serverState?.game_over) {
                        appState.animationFrameId = requestAnimationFrame(gameLoop);
                    }
                    appState.lastLoopTime = null; // Reset time for accurate deltaTime on resume
                    return; // Skip updates this frame
                }

                // --- Game Stop Checks ---
                if (appState.mode === 'menu' || !appState.isConnected || appState.serverState?.game_over) {
                    const finalStateForDisplay = appState.serverState;
                    if (finalStateForDisplay?.game_over) {
                        UI.showGameOver(finalStateForDisplay);
                    } else if (appState.mode === 'menu') {
                        UI.updateStatus(appState.isConnected ? "Connected. Select Mode." : "Disconnected.");
                    }
                    cleanupLoop();
                    return;
                }

                // --- Server State Check ---
                if (!appState.serverState && appState.mode !== 'singleplayer') {
                    appState.animationFrameId = requestAnimationFrame(gameLoop);
                    return;
                }

                // --- Calculate Delta Time ---
                if (appState.lastLoopTime === null) {
                    appState.lastLoopTime = currentTime; // Initialize or reset time after pause
                }
                const deltaTime = Math.min(0.1, (currentTime - appState.lastLoopTime) / 1000);
                appState.lastLoopTime = currentTime;

                // --- Process Input (Shooting) ---
                if (appState.serverState?.status === 'active' && Input.isShootHeld()) {
                    Input.handleShooting(); // Input module handles isPaused check
                }

                // --- Prediction & Reconciliation ---
                if (appState.mode !== 'singleplayer' && appState.serverState?.status === 'active') {
                    updatePredictedPosition(deltaTime); // Input module provides {dx:0, dy:0} if paused
                    reconcileWithServer();
                }

                // --- Render ---
                Renderer.drawGame();

                // --- Request Next Frame ---
                if (appState.mode !== 'menu' && appState.isConnected && !appState.serverState?.game_over) {
                    appState.animationFrameId = requestAnimationFrame(gameLoop);
                } else {
                    if(appState.animationFrameId) cleanupLoop();
                }
            } // End gameLoop

            function startGameLoop() {
                // --- Initial Checks ---
                // Don't start if explicitly in menu mode
                if (appState.mode === 'menu') {
                    log("StartGameLoop called but client is in menu mode.");
                    return;
                }
                // Don't start if loop is already running
                if (appState.animationFrameId) {
                    log("StartGameLoop called but loop already running.");
                    return;
                }
                // Don't start multiplayer if initial state hasn't arrived
                // (SP gets state immediately with sp_game_started)
                if (!appState.serverState && appState.mode !== 'singleplayer') {
                     log("StartGameLoop: Waiting for initial server state in multiplayer... (Loop will start via state update)");
                     return;
                }

                // --- Setup & Start ---
                Input.setup(); // <<< SETUP INPUT LISTENERS FIRST
                log("Starting game loop..."); // <<< THEN LOG
                appState.lastLoopTime = null; // Reset last time for accurate delta calculation on the first frame

                // Make the initial call to request the first frame of the game loop
                appState.animationFrameId = requestAnimationFrame(gameLoop);
            }

            function cleanupLoop() {
                 if (appState.animationFrameId) {
                     cancelAnimationFrame(appState.animationFrameId);
                     appState.animationFrameId = null;
                     log("Game loop stopped and cleaned up.");
                 } else {
                     // log("CleanupLoop called but no active loop found."); // Can be noisy
                 }
                 Input.cleanup(); // Deactivate input listeners
                 appState.lastLoopTime = null; // Reset timer
             }

             // --- Prediction & Reconciliation Functions ---
             function updatePredictedPosition(deltaTime) {
                if (!appState.localPlayerId || !appState.serverState?.players?.[appState.localPlayerId]) return; // Safety check

                const moveVector = Input.getMovementInputVector();
                const playerState = appState.serverState.players[appState.localPlayerId];
                // Use default speed if player state or speed property is missing
                const playerSpeed = playerState?.speed ?? PLAYER_DEFAULTS.base_speed;

                // Only update prediction if moving
                if (moveVector.dx === 0 && moveVector.dy === 0) return;

                appState.predictedPlayerPos.x += moveVector.dx * playerSpeed * deltaTime;
                appState.predictedPlayerPos.y += moveVector.dy * playerSpeed * deltaTime;

                // Use default dimensions if player state or dimensions are missing
                const w_half = (playerState?.width ?? PLAYER_DEFAULTS.width) / 2;
                const h_half = (playerState?.height ?? PLAYER_DEFAULTS.height) / 2;

                // Clamp prediction to canvas bounds
                appState.predictedPlayerPos.x = Math.max(w_half, Math.min(CANVAS_WIDTH - w_half, appState.predictedPlayerPos.x));
                appState.predictedPlayerPos.y = Math.max(h_half, Math.min(CANVAS_HEIGHT - h_half, appState.predictedPlayerPos.y));
             }

             function reconcileWithServer() {
                // 1. Safety Checks: Ensure necessary data exists
                if (!appState.localPlayerId || !appState.serverState?.players?.[appState.localPlayerId]) return;

                const serverPos = appState.serverState.players[appState.localPlayerId];
                if (typeof serverPos.x !== 'number' || typeof serverPos.y !== 'number') {
                    log("Reconciliation skipped: Invalid server position data.");
                    return;
                }

                // 2. Get References & Calculate Difference
                const predictedPos = appState.predictedPlayerPos;
                const renderedPos = appState.renderedPlayerPos;
                const dist = distance(predictedPos.x, predictedPos.y, serverPos.x, serverPos.y);

                // 3. Get Tuning Parameters (from CSS Vars or defaults)
                const threshold = parseFloat(getCssVar('--reconciliation-threshold')) || 5;
                const lerpFactor = parseFloat(getCssVar('--lerp-factor')) || 0.2;

                // 4. Snapping Logic: If prediction is WAY off server position...
                if (dist > threshold * 2) { // Note the '* 2' makes this a large distance snap
                    // log(`Reconciliation SNAP! Dist: ${dist.toFixed(1)}`); // Uncomment for debugging snaps
                    // Force both predicted and rendered position to match the server immediately
                    predictedPos.x = serverPos.x;
                    predictedPos.y = serverPos.y;
                    renderedPos.x = serverPos.x;
                    renderedPos.y = serverPos.y;
                } else {
                    // 5. Smoothing Logic: If prediction is reasonably close...
                    // Smoothly move the VISIBLE (rendered) position towards the PREDICTED position
                    renderedPos.x = lerp(renderedPos.x, predictedPos.x, lerpFactor);
                    renderedPos.y = lerp(renderedPos.y, predictedPos.y, lerpFactor);

                    // 6. Gentle Nudge (Subtle Correction): If prediction is slightly off (but not snapping)...
                    if (dist > 2.0) { // Hardcoded small distance check
                         // Gently pull the PREDICTED position towards the SERVER position
                         // This uses a very small factor (lerpFactor * 0.1)
                         predictedPos.x = lerp(predictedPos.x, serverPos.x, lerpFactor * 0.1);
                         predictedPos.y = lerp(predictedPos.y, serverPos.y, lerpFactor * 0.1);
                    }
                }
             }

             // Accessor not strictly needed if SP uses server state directly
             function getLocalGameState() { return appState.serverState; }

             // Setup button listeners (called once on load)
             function initListeners() {
                 log("Initializing button listeners...");
                 DOM.singlePlayerBtn.onclick = startSinglePlayer;
                 DOM.multiplayerBtn.onclick = () => UI.showSection('multiplayer-menu-section');
                 DOM.hostGameBtn2.onclick = () => hostMultiplayer(2);
                 DOM.hostGameBtn3.onclick = () => hostMultiplayer(3);
                 DOM.hostGameBtn4.onclick = () => hostMultiplayer(4);
                 DOM.showJoinUIBtn.onclick = () => UI.showSection('join-code-section');
                 DOM.cancelHostBtn.onclick = leaveGame;
                 DOM.joinGameSubmitBtn.onclick = joinMultiplayer;
                 DOM.sendChatBtn.onclick = sendChatMessage;
                 DOM.leaveGameBtn.onclick = leaveGame;
                 DOM.gameOverBackBtn.onclick = () => resetClientState(true);

                 // Back buttons using class
                 DOM.gameContainer.querySelectorAll('.back-button').forEach(btn => {
                     const targetSectionMatch = btn.getAttribute('onclick')?.match(/'([^']+)'/);
                     if (targetSectionMatch && targetSectionMatch[1]) {
                         const targetSectionId = targetSectionMatch[1];
                         // Ensure valid section ID before overriding
                         if (DOM[targetSectionId] || document.getElementById(targetSectionId)) {
                              btn.onclick = (e) => { e.preventDefault(); UI.showSection(targetSectionId); }; // Override inline
                         } else {
                              log(`Warning: Back button target section invalid: ${targetSectionId}`);
                         }
                     } else {
                         log("Warning: Back button found without valid target in onclick:", btn);
                     }
                 });
             }


            function hostMultiplayer(maxPlayers) {
                log(`Requesting to Host Multiplayer game for ${maxPlayers} players...`);
                // Validate maxPlayers briefly on client side
                if (![2, 3, 4].includes(maxPlayers)) {
                    error("Invalid max player count requested:", maxPlayers);
                    UI.updateStatus("Invalid player count.", true);
                    return;
                }
                appState.mode = 'multiplayer-host';
                resetClientState(false); // Reset state but don't show menu yet
                UI.updateStatus(`Creating ${maxPlayers}-player game...`);
                // Send max_players value to server
                Network.sendMessage({ type: 'create_game', max_players: maxPlayers });
                // UI transition happens on 'game_created' response
            }



            // --- Expose necessary functions from Game module ---
            return {
                 resetClientState,
                 startGameLoop,
                 cleanupLoop,
                 sendChatMessage,
                 getLocalGameState,
                 initListeners // Expose initListeners to be called on load
            };
        })(); // End Game module IIFE

        // --- Global Server Message Handler ---
        function handleServerMessage(event) {
            let data;
            try {
                data = JSON.parse(event.data);
                // Using a more concise log for received messages
                // console.log(`[Client] Received: ${data.type}`); // Can uncomment for detailed tracing

            } catch (err) {
                console.error("[Client] Failed to parse server message:", err, event.data);
                UI.updateStatus("Received invalid data from server.", true);
                return;
            }

            try {
                switch (data.type) {
                    // --- Case: HOST Creates Game ---
                    case 'game_created':
                        log("[handleServerMessage] Processing 'game_created'");
                        appState.localPlayerId = data.player_id;
                        appState.currentGameId = data.game_id;
                        appState.serverState = data.initial_state;

                        // Critical: Store max players received from server
                        appState.maxPlayersInGame = data.max_players;
                        if (!appState.maxPlayersInGame) { // Log error if missing
                            error("'game_created' message missing 'max_players'!");
                            appState.maxPlayersInGame = '?'; // Use placeholder
                        }
                        log(`-> Stored maxPlayersInGame: ${appState.maxPlayersInGame}`);

                        // Initialize player positions
                        const hostPlayer = appState.serverState?.players[appState.localPlayerId];
                        if (hostPlayer) {
                            appState.predictedPlayerPos = { x: hostPlayer.x, y: hostPlayer.y };
                            appState.renderedPlayerPos = { x: hostPlayer.x, y: hostPlayer.y };
                        }

                        // Update UI for waiting host
                        if (DOM.gameCodeDisplay) {
                            DOM.gameCodeDisplay.textContent = appState.currentGameId || 'ERROR_ID';
                        } else { error("DOM.gameCodeDisplay not found!"); }

                        const currentPlayers = Object.keys(appState.serverState?.players || {}).length;
                        if (DOM.waitingMessage) {
                            DOM.waitingMessage.textContent = `Waiting for Team Mate... (${currentPlayers}/${appState.maxPlayersInGame})`;
                        } else { error("DOM.waitingMessage not found!"); }

                        UI.updateStatus(`Game hosted. Code: ${appState.currentGameId}`);
                        UI.showSection('host-wait-section');

                        // --- DO NOT START THE GAME LOOP HERE FOR THE HOST ---
                        // Host loop starts only when game status changes via 'game_state'
                        log("-> Host waiting, loop NOT started yet.");
                        break; // End game_created

                    // --- Case: CLIENT Joins Game ---
                    case 'game_joined':
                        log("[handleServerMessage] Processing 'game_joined'");
                        appState.localPlayerId = data.player_id;
                        appState.currentGameId = data.game_id;
                        appState.serverState = data.initial_state;

                        // Store max players (also sent in initial state for joiner)
                        appState.maxPlayersInGame = appState.serverState?.max_players;
                         if (!appState.maxPlayersInGame) { // Log error if missing
                             error("'game_joined' initial_state missing 'max_players'!");
                             appState.maxPlayersInGame = '?';
                         }
                         log(`-> Stored maxPlayersInGame: ${appState.maxPlayersInGame}`);


                        // Initialize player positions
                        const joinedPlayer = appState.serverState?.players[appState.localPlayerId];
                        if (joinedPlayer) {
                            appState.predictedPlayerPos = { x: joinedPlayer.x, y: joinedPlayer.y };
                            appState.renderedPlayerPos = { x: joinedPlayer.x, y: joinedPlayer.y };
                        }

                        UI.updateStatus(`Joined game ${appState.currentGameId}. Get ready!`);
                        UI.showSection('game-area');

                        // --- START LOOP FOR JOINING CLIENT ---
                        log("-> Join successful, starting loop for client.");
                        Game.startGameLoop();
                        // -------------------------------------
                        break; // End game_joined

                    // --- Case: SINGLE PLAYER Starts Game ---
                    case 'sp_game_started':
                        log("[handleServerMessage] Processing 'sp_game_started'");
                        appState.localPlayerId = data.player_id;
                        appState.currentGameId = data.game_id;
                        appState.serverState = data.initial_state;
                        appState.maxPlayersInGame = 1; // SP is always 1

                        // Initialize player positions
                        const spPlayer = appState.serverState?.players[appState.localPlayerId];
                        if (spPlayer) {
                            appState.predictedPlayerPos = { x: spPlayer.x, y: spPlayer.y };
                            appState.renderedPlayerPos = { x: spPlayer.x, y: spPlayer.y };
                        }

                        UI.updateStatus("Single Player Game Started!");
                        UI.showSection('game-area');

                        // --- START LOOP FOR SINGLE PLAYER ---
                        log("-> SP started, starting loop.");
                        Game.startGameLoop();
                        // ----------------------------------
                        break; // End sp_game_started

                    // --- Case: Receiving Game State Updates ---
                    case 'game_state':
                        // Minimal log for game state to avoid flooding console
                        // if (Math.random() < 0.05) log("[handleServerMessage] Processing 'game_state'");

                        // 1. Store previous state info
                        const previousStatus = appState.serverState?.status;
                        const wasGameOver = appState.serverState?.game_over;
                        appState.previousServerState = appState.lastServerState;
                        appState.lastServerState = appState.serverState;

                        // 2. Update the core server state
                        appState.serverState = data.state;
                        const newState = appState.serverState;

                        // 3. Update maxPlayers if needed (e.g., first state update for host)
                        if (!appState.maxPlayersInGame && newState.max_players) {
                             appState.maxPlayersInGame = newState.max_players;
                             log(`-> Max players set from game_state: ${appState.maxPlayersInGame}`);
                        }

                        // 4. Handle Hit Pause trigger
                         const localPlayerStateHit = newState?.players?.[appState.localPlayerId];
                         if (localPlayerStateHit?.hit_flash_this_tick && hitPauseFrames <= 0) {
                             hitPauseFrames = 3;
                         }

                        // 5. *** Handle Game Status Changes and Loop Control ***
                        if (newState.status !== previousStatus) {
                            log(`[Client State Change] From ${previousStatus || 'null'} to ${newState.status}`);

                            if (newState.status === 'waiting') {
                                // This only happens if game was active/countdown and player left
                                if (appState.mode === 'multiplayer-host') {
                                    log("-> Handling transition TO waiting (player left?)");
                                    UI.updateStatus("Teammate left. Waiting...", true);
                                    UI.showSection('host-wait-section');
                                    const currentPlayersWaiting = Object.keys(newState.players || {}).length;
                                    if(DOM.waitingMessage) DOM.waitingMessage.textContent = `Waiting for Team Mate... (${currentPlayersWaiting}/${appState.maxPlayersInGame || '?'})`;
                                    Game.cleanupLoop(); // *** Stop the loop ***
                                } else {
                                    // Client might get put back to menu? Or show a message.
                                    log("-> Game returned to waiting (client view).");
                                    UI.updateStatus("Host or player left. Returning to menu.", true);
                                    Game.resetClientState(true); // Send client to main menu
                                }

                            } else if (newState.status === 'countdown') {
                                log("-> Handling transition TO countdown");
                                UI.updateStatus("Countdown starting...");
                                UI.showSection('game-area'); // Show game area
                                // --- Start loop HERE if not already running ---
                                if (!appState.animationFrameId) {
                                    log("--> Starting game loop NOW (triggered by countdown).");
                                    Game.startGameLoop();
                                } else {
                                    log("--> Loop already running (countdown change).");
                                }
                                // --------------------------------------------
                            } else if (newState.status === 'active') {
                                log("-> Handling transition TO active");
                                UI.updateStatus("Game active!");
                                UI.showSection('game-area'); // Ensure game area is shown
                                // --- Start loop HERE if not already running ---
                                if (!appState.animationFrameId) {
                                    log("--> Starting game loop NOW (triggered by active).");
                                    Game.startGameLoop();
                                } else {
                                     log("--> Loop already running (active change).");
                                }
                                // --------------------------------------------
                            } else if (newState.status === 'finished') {
                                // The gameLoop itself detects 'finished' state and stops,
                                // no explicit stop needed here unless adding extra UI transition.
                                log("-> Game status changed to 'finished'.");
                            }
                        } // End of status change check

                        // 6. Update HUD/Timers (Only if game is actively running)
                        if (newState.status === 'countdown' || newState.status === 'active') {
                            const player = newState.players?.[appState.localPlayerId];
                            UI.updateHUD(player, newState);
                            UI.updateCountdown(newState);
                            UI.updateDayNight(newState);
                        }
                        // Update waiting message if status is waiting (even if status didn't change)
                        else if (newState.status === 'waiting' && appState.mode === 'multiplayer-host') {
                            const playerCount = Object.keys(newState.players || {}).length;
                            if(DOM.waitingMessage) DOM.waitingMessage.textContent = `Waiting for Team Mate... (${playerCount}/${appState.maxPlayersInGame || '?'})`;
                        }

                        // 7. Check for Game Over Transition (Primarily for logging)
                        if (newState.game_over && !wasGameOver) {
                            log("-> Game Over signal received from server.");
                            // Loop detects newState.game_over and handles stopping/showing screen
                        }

                        // 8. Handle Enemy Speech
                        const serverSpeakerId = newState.enemy_speaker_id;
                        const serverSpeechText = newState.enemy_speech_text;
                        if (serverSpeakerId && serverSpeechText) {
                            const bubbleText = serverSpeechText.substring(0, 50);
                            activeEnemyBubbles[serverSpeakerId] = {
                                text: bubbleText, endTime: performance.now() + 3000
                            };
                        }
                        break; // End game_state case

                    // Default case and other cases ('chat_message', 'error') remain the same...
                     case 'chat_message':
                         const senderId = data.sender_id;
                         const messageText = data.message;
                         const isSelf = senderId === appState.localPlayerId;
                         UI.addChatMessage(senderId, messageText, isSelf);
                         if (senderId && messageText) {
                             const bubbleText = messageText.substring(0, 50);
                             activeSpeechBubbles[senderId] = {
                                 text: bubbleText, endTime: performance.now() + 4000
                             };
                         }
                         break;
                     case 'error':
                         console.error("[Client] Server Error Message:", data.message);
                         UI.updateStatus(`Server Error: ${data.message}`, true);
                         if (appState.mode === 'multiplayer-client' && (data.message.includes('not found') || data.message.includes('not waiting') || data.message.includes('full') || data.message.includes('finished'))) {
                             UI.showSection('join-code-section');
                             appState.mode = 'menu';
                         } else if (appState.mode === 'multiplayer-host' && data.message.includes('Creation Error')) {
                             Game.resetClientState(true);
                         } else if (data.message === 'Please create or join a game first.') {
                              log("Received 'join first' error unexpectedly, resetting state.");
                              Game.resetClientState(true);
                         }
                         break;

                    default:
                        log(`Unknown message type received: ${data.type}`);
                } // End switch
            } catch (handlerError) {
                console.error("[Client] Error inside handleServerMessage logic:", handlerError);
                UI.updateStatus("Client error processing message.", true);
            }
        } // End handleServerMessage


        // --- Global Init ---
        // Wrapper for inline HTML button compatibility
        function showSection(sectionId) { UI.showSection(sectionId); }

        window.onload = () => {
            log("Window loaded.");
            UI.updateStatus("Initializing...");

            // Define appState *before* initializing modules that might use it
             // --- Global Client State --- <<< IMPORTANT PLACEMENT
             appState = { // Use global scope assignment since it's used everywhere
                 mode: 'menu',
                 localPlayerId: null,
                 currentGameId: null,
                 serverState: null,
                 animationFrameId: null,
                 isConnected: false,
                 renderedPlayerPos: { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 },
                 predictedPlayerPos: { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 },
                 lastServerState: null,
                 previousServerState: null,
                 lastLoopTime: null, // Initialize as null
             };
             socket = null; // Also define socket globally

            // Now safe to initialize listeners and connect
            try {
                 Game.initListeners();
                 Network.connect(() => {
                     // This callback runs *after* WebSocket opens
                     UI.updateStatus("Connected. Select Mode.");
                     // Show main menu only *after* connection is confirmed open
                     UI.showSection('main-menu-section');
                 });
                 UI.updateStatus("Connecting..."); // Initial status while connecting
            } catch (initError) {
                 console.error("Initialization failed:", initError);
                 UI.updateStatus("Error initializing game. Please refresh.", true);
            }
        };

    </script>
</body>
</html>

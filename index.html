<body>
    <div id="game-container">
        <h1>SUCH IS LIFE</h1>
        <div id="game-status">Initializing...</div>

        <!-- Mode Selection (Keep as is) -->
        <div id="mode-selection-section">
            <p>How do you want to play?</p>
            <button id="playFriendBtn" onclick="createFriendGame()">Play a Friend (Get Code)</button>
            <button id="showJoinCodeBtn" onclick="showJoinUI()">Join Friend's Game (Enter Code)</button>
        </div>

        <!-- Join Code Input (Keep as is) -->
        <div id="join-code-section">
             <p>Enter the 6-character game code:</p>
             <input type="text" id="gameIdInput" placeholder="ABCDEF" maxlength="6">
             <button id="joinGameBtn" onclick="joinGame()">Join Game</button>
             <button onclick="showModeSelection()">Back</button>
        </div>

        <!-- REMOVE #waiting-section -->
        <!-- <div id="waiting-section"> ... </div> -->

        <!-- Main Game Area (Now used for Waiting, Countdown, Active) -->
        <div id="game-area">
            <!-- NEW: Waiting Info (Shown conditionally) -->
            <div id="waiting-info" style="display: none; padding: 15px; border: 2px dashed var(--primary-color); margin-bottom:15px; background-color: rgba(0,0,0,0.2); border-radius: 8px;">
                 <p>Game Code: <strong id="game-code-display" style="font-size: 1.5rem; user-select: all;">------</strong></p>
                 <p id="waiting-message">Waiting for opponent to join...</p>
                 <button id="cancelGameBtn" onclick="resetToConnection(true)">Cancel Game</button>
            </div>

            <!-- Existing Game Canvas and Overlays -->
            <div style="position: relative;">
                <canvas id="gameCanvas" width="800" height="600"></canvas> <!-- Main canvas used always -->
                <div id="countdown"></div>
                <div id="day-night-indicator">Day</div>
            </div>
            <div id="hud">
                 <div id="player-stats">Loading...</div>
                 <div id="game-info">Score: 0 | Level: 1</div>
            </div>
             <div id="chat-section">
                 <input type="text" id="chatInput" placeholder="Say somethin', mate..." maxlength="50">
                 <button id="sendChatBtn" onclick="sendChatMessage()">Send</button>
                 <div id="chat-log"></div>
             </div>
             <button id="leaveGameBtn" onclick="resetToConnection(true)" style="display:none;">Leave Game</button> <!-- Initially hidden -->
        </div>

        <!-- Game Over Screen (Keep as is) -->
        <div id="game-over-screen">
            <h2>Game Over, Mate!</h2>
            <div id="final-stats"></div>
            <button onclick="resetToConnection(false)">Back to Menu</button>
        </div>
    </div>

    <script>
        // --- Constants (Keep as is) ---
        const WEBSOCKET_URL = 'wss://such-is-life.glitch.me/ws';
        // ... other constants ...

        // --- Colors (Keep as is) ---
        // ...

        // --- DOM Elements ---
        const gameContainer = document.getElementById('game-container');
        const modeSelectionSection = document.getElementById('mode-selection-section');
        const joinCodeSection = document.getElementById('join-code-section');
        // REMOVE waitingSection const
        const gameArea = document.getElementById('game-area'); // Main area now
        const waitingInfo = document.getElementById('waiting-info'); // Div inside gameArea
        const gameCodeDisplay = document.getElementById('game-code-display');
        const waitingMessage = document.getElementById('waiting-message');
        // (Keep other element consts: gameOverScreen, gameStatus, inputs, buttons, canvas etc.)
        const canvas = document.getElementById('gameCanvas'); // Main canvas
        // REMOVE waitingCanvas / waitingCtx consts
        const ctx = canvas.getContext('2d'); // Use main context
        // (Keep HUD, chat etc. consts)
        const cancelGameBtn = document.getElementById('cancelGameBtn');
        const leaveGameBtn = document.getElementById('leaveGameBtn');


        // --- Game State (Keep as is) ---
        let socket; let gameState = null; let localPlayerId = null; let currentGameId = null;
        let keys = {}; let lastShotTime = 0; let animationFrameId = null; let playerMessages = {};

        // --- Utility (Keep getCssVar) ---
        function getCssVar(varName) { /* ... */ }

        // --- UI Section Management ---
        function showSection(sectionId) {
             modeSelectionSection.style.display = 'none';
             joinCodeSection.style.display = 'none';
             gameArea.style.display = 'none'; // Hide game area by default too
             gameOverScreen.style.display = 'none';

             const sectionToShow = document.getElementById(sectionId);
             if (sectionToShow) {
                 sectionToShow.style.display = 'block'; // Or 'flex' if game-area needs it
                 if (sectionId === 'game-area') {
                     gameArea.style.display = 'block'; // Or appropriate display type
                 }
             } else { console.error("Section not found:", sectionId); }
        }

        // --- WebSocket Logic ---
        function connectWebSocket(onOpenCallback) { /* Keep existing */ }

        function handleServerMessage(event) {
             try {
                 const data = JSON.parse(event.data);
                 console.debug("Message received:", data);

                 switch (data.type) {
                     case 'game_created':
                         localPlayerId = data.player_id;
                         currentGameId = data.game_id;
                         gameState = data.initial_state; // Includes status: 'waiting'
                         playerMessages = {};
                         updateStatus(`Game created. Code: ${currentGameId}`);
                         showSection('game-area'); // Show the main game area
                         updateUI(); // Update UI will show waiting info based on status
                         addSystemMessageToLog(`Game ${currentGameId} created. Waiting for opponent...`);
                         if (!animationFrameId) startGameLoop(); // Start game loop (will draw waiting state)
                         break;

                     case 'game_joined':
                         localPlayerId = data.player_id;
                         currentGameId = data.game_id;
                         gameState = data.initial_state; // Should include status: 'countdown' now
                         playerMessages = {};
                         updateStatus(`Joined game: ${currentGameId}`);
                         showSection('game-area'); // Ensure game area is shown
                         updateUI(); // Update UI will show countdown
                         if (!animationFrameId) startGameLoop(); // Ensure loop is running
                         addSystemMessageToLog(`Joined game ${currentGameId}. Get ready!`);
                         break;

                     case 'game_state':
                         //const previousStatus = gameState ? gameState.status : null; // Optional: Check previous status
                         gameState = data.state;
                         currentGameId = currentGameId || findMyGameId();

                         // Just update the UI based on the current state received
                         updateUI();

                         if (gameState.game_over) {
                             showGameOver();
                         } else if (!animationFrameId && (gameState.status === 'active' || gameState.status === 'countdown' || gameState.status === 'waiting')) {
                             // If loop stopped but game is still joinable/playable, restart loop
                             startGameLoop();
                         }
                         break;

                     // (Keep 'chat_message', 'error', 'default' handlers)
                     case 'chat_message': handleChatMessage(data.sender_id, data.message); break;
                     case 'error': console.error('Server Error:', data.message); updateStatus(`Error: ${data.message}`); if (data.message.includes('Game not found') || data.message.includes('Game is full') || data.message.includes('not waiting')) { showJoinUI(); enableJoinButton(); } else { enableModeSelectionButtons(); } break;
                     default: console.warn('Unknown message type:', data.type); break;
                 }
             } catch (error) { console.error('Error processing server message:', error, event.data); }
        }

        function sendMessage(payload) { /* Keep existing */ }

        // --- Game Actions ---
        function createFriendGame() { /* Keep existing */ }
        function joinGame() { /* Keep existing */ }
        function sendChatMessage() { /* Keep existing */ }

        // --- UI Management ---
        function updateStatus(message) { gameStatus.textContent = message; } // Simplified

        // --- Button Disabling/Enabling (Simplified) ---
        function disableAllButtons() { document.querySelectorAll('button').forEach(button => button.disabled = true); }
        function enableModeSelectionButtons() { playFriendBtn.disabled = false; showJoinCodeBtn.disabled = false; joinGameBtn.disabled = true; /* other buttons likely disabled */ }
        function enableJoinButton() { joinGameBtn.disabled = false; playFriendBtn.disabled = true; showJoinCodeBtn.disabled = true; }
        function enableGameplayUI(enable=true) { // Controls UI during active game phases
            sendChatBtn.disabled = !enable;
            leaveGameBtn.disabled = !enable;
            // Disable mode/join buttons always during gameplay/waiting
            playFriendBtn.disabled = true;
            showJoinCodeBtn.disabled = true;
            joinGameBtn.disabled = true;
            const cancelBtn = document.getElementById('cancelGameBtn'); // Find cancel button if exists
            if (cancelBtn) cancelBtn.disabled = true; // Disable cancel when gameplay starts
        }
        function enableWaitingUI() { // Controls UI during waiting phase
             const cancelBtn = document.getElementById('cancelGameBtn');
             if (cancelBtn) cancelBtn.disabled = false;
             // Disable others
             playFriendBtn.disabled = true; showJoinCodeBtn.disabled = true; joinGameBtn.disabled = true; sendChatBtn.disabled = true; leaveGameBtn.disabled = true;
        }


        function showModeSelection() { showSection('mode-selection-section'); updateStatus("Select a game mode."); enableModeSelectionButtons(); gameIdInput.value = ''; }
        function showJoinUI() { showSection('join-code-section'); updateStatus("Enter your friend's game code."); enableJoinButton(); gameIdInput.focus(); }
        // REMOVE showGameArea - handled by message handler now

        function showErrorStateUI() { /* Keep existing - shows mode selection */ }
        function resetToConnection(closeSocket = true) { /* Keep existing */ }

        function updateUI() {
            if (!gameState) { updateStatus("Waiting for server..."); return; }

            const player = gameState.players ? gameState.players[localPlayerId] : null; // Handle case where players might be null briefly
            const status = gameState.status || 'unknown';

            // --- Control Visibility Based on Status ---
            if (status === 'waiting') {
                waitingInfo.style.display = 'block';
                hud.style.display = 'none'; // Hide HUD
                chatSection.style.display = 'none'; // Hide Chat
                leaveGameBtn.style.display = 'none'; // Hide leave button
                countdownDiv.style.display = 'none';
                dayNightIndicator.style.display = 'none';
                gameCodeDisplay.textContent = currentGameId || '???';
                waitingMessage.textContent = `Waiting for opponent... (${gameState.players ? Object.keys(gameState.players).length : 0}/${MAX_PLAYERS})`;
                enableWaitingUI();
                // Draw waiting state on canvas? (optional)
                drawWaitingScreen(); // Draw something simple
            } else { // Countdown, Active, Finished?
                waitingInfo.style.display = 'none'; // Hide waiting info
                hud.style.display = 'flex'; // Show HUD (use flex)
                chatSection.style.display = 'flex'; // Show Chat (use flex)
                leaveGameBtn.style.display = 'inline-block'; // Show leave button
                enableGameplayUI(); // Enable chat send / leave btn

                // Update HUD Stats
                if (player) { playerStatsDiv.innerHTML = `<span>HP:</span> ${player.health}/${player.max_health}<br>...`; } // Keep stat details
                else { playerStatsDiv.textContent = "Error/Spectating"; }

                // Update Game Info
                gameInfoDiv.innerHTML = `Score: ${gameState.score} | Level: ${gameState.level}`;

                // Update Countdown Timer
                if (status === 'countdown' && gameState.countdown >= 0) {
                    countdownDiv.textContent = Math.ceil(gameState.countdown);
                    countdownDiv.style.display = 'block';
                    dayNightIndicator.style.display = 'none';
                } else {
                    countdownDiv.style.display = 'none';
                    dayNightIndicator.style.display = 'block'; // Show only if not counting down
                }

                // Update Day/Night Indicator Text & Canvas Background
                const isNight = gameState.is_night;
                dayNightIndicator.textContent = isNight ? 'Night' : 'Day';
                canvas.style.backgroundColor = isNight ? getCssVar('--bg-color') : '#A0522D';
            }
        }

        function showGameOver() { /* Keep existing */ }
        function handleChatMessage(senderId, message) { /* Keep existing */ }
        function addMessageToLog(sender, message, isSelf) { /* Keep existing */ }
        function addSystemMessageToLog(message) { /* Keep existing */ }

        // --- Game Loop and Drawing ---
        function setupGameControls() { /* Keep existing */ }
        function removeGameControls() { /* Keep existing */ }
        function handleKeyDown(e) { // Modified to check status
            if (document.activeElement === chatInput) return;
            if (gameState && gameState.status === 'active' && !gameState.game_over) {
                 keys[e.key.toLowerCase()] = true;
            }
         }
        function handleKeyUp(e) { keys[e.key.toLowerCase()] = false; } // Keep simple
        function handleChatEnter(e) { /* Keep existing */ }
        function handlePlayerMovement() { // Modified to check status
             if (!localPlayerId || !gameState || gameState.status !== 'active' || gameState.game_over) return;
             const player = gameState.players[localPlayerId]; if (!player) return;
             // ... Keep actual movement logic ...
              const speed = player.speed; let dx = 0; let dy = 0;
              if (keys['w'] || keys['arrowup']) dy -= 1; if (keys['s'] || keys['arrowdown']) dy += 1; if (keys['a'] || keys['arrowleft']) dx -= 1; if (keys['d'] || keys['arrowright']) dx += 1;
              if (dx !== 0 || dy !== 0) { const magnitude = Math.sqrt(dx * dx + dy * dy); const moveX = player.position.x + (dx / magnitude) * speed; const moveY = player.position.y + (dy / magnitude) * speed; const boundedX = Math.max(0, Math.min(CANVAS_WIDTH - PLAYER_WIDTH, moveX)); const boundedY = Math.max(0, Math.min(CANVAS_HEIGHT - PLAYER_HEIGHT, moveY)); if (boundedX !== player.position.x || boundedY !== player.position.y) { player.position.x = boundedX; player.position.y = boundedY; sendMessage({ type: 'player_move', position: { x: boundedX, y: boundedY } }); } }
         }
        function handleShooting() { // Modified to check status
             if (!localPlayerId || !gameState || gameState.status !== 'active' || gameState.game_over) return;
             const currentTime = Date.now(); if (currentTime - lastShotTime < SHOOT_COOLDOWN) return;
             // ... Keep actual shooting direction logic ...
              let direction = null; if (keys['arrowup']) direction = 'up'; else if (keys['arrowdown']) direction = 'down'; else if (keys['arrowleft']) direction = 'left'; else if (keys['arrowright']) direction = 'right';
              if (direction) { sendMessage({ type: 'player_shoot', direction: direction }); lastShotTime = currentTime; }
         }

        function startGameLoop() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            setupGameControls();
            function gameLoop() {
                 if (!gameState || gameState.game_over) { removeGameControls(); animationFrameId = null; return; }

                 if (gameState.status === 'active') {
                     handlePlayerMovement(); handleShooting(); drawGame(); // Only handle input/draw full game if active
                 } else if (gameState.status === 'countdown') {
                      drawGame(); // Draw game during countdown (players visible, no movement/shooting)
                 } else if (gameState.status === 'waiting') {
                      drawWaitingScreen(); // Draw the simpler waiting screen
                 }
                 animationFrameId = requestAnimationFrame(gameLoop);
            }
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // --- Drawing Functions ---
        function drawGame() { // Draws the main game (active or countdown)
             ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
             if (!gameState) return; // Should not happen if loop is running, but safety check

             if (gameState.is_night) { ctx.fillStyle = COLOR_NIGHT_OVERLAY; ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT); }
             // (Keep drawing logic for powerups, enemies, players, bullets, healthbars, chat messages)
             // Draw Power-ups
             gameState.power_ups.forEach(power_up => { ctx.fillStyle = POWERUP_COLORS[power_up.type] || 'grey'; const pulse = Math.sin(Date.now() * 0.005) * 2; const size = POWERUP_SIZE + pulse; ctx.fillRect(power_up.position.x - size / 2, power_up.position.y - size / 2, size, size); });
             // Draw Enemies
             gameState.enemies.forEach(enemy => { ctx.fillStyle = COLOR_ENEMY; ctx.fillRect(enemy.position.x, enemy.position.y, ENEMY_WIDTH, ENEMY_HEIGHT); drawHealthBar(ctx, enemy.position.x, enemy.position.y, ENEMY_WIDTH, enemy.health, enemy.max_health); });
            // Draw Players
            Object.entries(gameState.players || {}).forEach(([id, player]) => { const isSelf = id === localPlayerId; ctx.fillStyle = isSelf ? COLOR_PLAYER_SELF : COLOR_PLAYER_OTHER; ctx.fillRect(player.position.x, player.position.y, PLAYER_WIDTH, PLAYER_HEIGHT); drawHealthBar(ctx, player.position.x, player.position.y, PLAYER_WIDTH, player.health, player.max_health); drawPlayerChatMessage(ctx, player, id); });
             // Draw Bullets
            gameState.bullets.forEach(bullet => { ctx.fillStyle = bullet.source === 'player' ? COLOR_BULLET_PLAYER : COLOR_BULLET_ENEMY; ctx.beginPath(); ctx.arc(bullet.position.x, bullet.position.y, bullet.is_crit ? BULLET_RADIUS * 1.5 : BULLET_RADIUS, 0, Math.PI * 2); ctx.fill(); if (bullet.is_crit) { ctx.strokeStyle = 'orange'; ctx.lineWidth = 1; ctx.stroke(); } });

        }
        function drawHealthBar(ctx, x, y, width, currentHealth, maxHealth) { /* Keep existing */ }
        function drawPlayerChatMessage(ctx, player, playerId) { /* Keep existing */ }

        // --- NEW: Simple Waiting Screen Drawing ---
        function drawWaitingScreen() {
             // Use the main canvas ctx
             ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
             ctx.fillStyle = '#A0522D'; // Day background color
             ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

             // Draw Players currently waiting
             if (gameState && gameState.players) {
                 Object.entries(gameState.players).forEach(([id, player]) => {
                     const isSelf = id === localPlayerId;
                     ctx.fillStyle = isSelf ? COLOR_PLAYER_SELF : COLOR_PLAYER_OTHER;
                     ctx.fillRect(player.position.x, player.position.y, PLAYER_WIDTH, PLAYER_HEIGHT);
                     // Maybe draw player ID/Name?
                     ctx.fillStyle = COLOR_TEXT;
                     ctx.font = '12px ' + getCssVar('--font-family');
                     ctx.textAlign = 'center';
                     ctx.fillText(isSelf ? 'You' : `Player ${id.substring(0,4)}`, player.position.x + PLAYER_WIDTH / 2, player.position.y + PLAYER_HEIGHT + 12);
                     ctx.textAlign = 'left';
                 });
             }

             // Optional: Add some text
             ctx.fillStyle = COLOR_TEXT;
             ctx.font = '18px ' + getCssVar('--font-family');
             ctx.textAlign = 'center';
             ctx.fillText("Waiting for opponent...", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 30);
             ctx.fillText(`Game Code: ${currentGameId || '???'}`, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
             ctx.textAlign = 'left';
        }

        // --- Initialization ---
        window.onload = () => { /* Keep existing - show mode selection, connect */ };

    </script>
</body>
</html>

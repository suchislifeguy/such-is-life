<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>SUCH IS LIFE - Kelly Gang Survival</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        /* --- Base Styles & Variables --- */
        :root {
            --bg-color: #3E2723; --primary-color: #D2691E; --secondary-color: #8B4513;
            --accent-color: #FFD700; --text-color: #FFF8DC; --player-color: #DC143C;
            --other-player-color: #4682B4; --enemy-color: #2E8B57; --bullet-player-color: #FFEB3B;
            --bullet-enemy-color: #FFFFFF; --health-bar-bg: #555; --health-bar-high: #4CAF50;
            --health-bar-medium: #FFC107; --health-bar-low: #F44336; --powerup-health: #00FF00;
            --powerup-gun: #FF00FF; --powerup-speed: #00FFFF; --powerup-armor: #C0C0C0;
            --night-overlay: rgba(0, 0, 50, 0.4); --font-family: 'Courier New', monospace;
            --reconciliation-threshold: 15; /* Pixels difference before snapping */
            --lerp-factor: 0.1; /* Smoothing factor for reconciliation/interpolation */
        }
        /* --- General Body/Container --- */
        body {
            margin: 0; display: flex; flex-direction: column; justify-content: center;
            align-items: center; min-height: 100vh; background-color: var(--bg-color);
            font-family: var(--font-family); color: var(--text-color);
        }
        #game-container {
            background-color: var(--secondary-color); border: 5px solid var(--primary-color);
            border-radius: 15px; padding: 20px; padding-top: 15px; /* Adjust top padding */
            text-align: center; max-width: 900px;
            width: calc(100% - 40px); position: relative; box-shadow: 0 0 20px rgba(0,0,0,0.5);
            overflow: hidden; /* Prevent content spillover */
        }

        /* --- Top Bar Styling --- */
        #top-bar {
            display: flex; justify-content: space-between; align-items: flex-start; /* Align items to top */
            padding: 0 5px 10px 5px; /* Reduced horizontal padding */
            margin-bottom: 10px;
            border-bottom: 2px solid var(--primary-color); flex-wrap: wrap;
        }
        #top-bar h1 { /* Combined H1 styles */
            color: var(--player-color); margin: 0 15px 0 0; padding: 0;
            line-height: 1.2; flex-shrink: 0; text-shadow: 2px 2px 4px black;
            font-size: 1.8em; /* Adjust size if needed */
        }
        #player-stats-container {
            flex-grow: 1;
            margin-right: 10px;
            /* Add min-width if needed to prevent excessive shrinking */
            /* min-width: 360px; */
        }

        #mp-stats-display { /* The flex container for the two boxes */
            display: flex;
            justify-content: flex-start; /* Align boxes to the start */
            gap: 10px; /* Space between the two stat boxes */
            flex-wrap: wrap; /* Allow wrapping on very small screens */
        }

        .player-stats-box { /* Style for each individual stats box */
            color: var(--text-color);
            font-size: 12px; /* Slightly smaller font */
            background: rgba(0, 0, 0, 0.5);
            padding: 4px 6px; /* Reduced padding */
            border-radius: 5px;
            text-align: left;
            border: 1px solid var(--accent-color);
            min-width: 160px; /* Adjust width as needed */
            box-sizing: border-box;
            margin-top: 4px;
        }

        .player-stats-box .stats-header {
            font-weight: bold;
            color: var(--accent-color);
            text-align: center;
            padding-bottom: 3px;
            margin-bottom: 3px;
            border-bottom: 1px dashed rgba(255, 255, 255, 0.2);
            font-size: 13px;
        }

        .player-stats-box .stats-content span { /* Labels inside stats */
            display: inline-block;
            min-width: 40px; /* Adjusted width */
            font-weight: bold;
        }

        /* Hide the old single #player-stats if it wasn't removed */
        #player-stats {
            display: none;
        }
        #day-night-indicator {
            /* No longer absolute positioned */
            font-size: 15px; color: var(--text-color); background: rgba(0,0,0,0.5);
            padding: 6px 10px; border-radius: 5px; z-index: 5;
            display: none; /* Start hidden, JS will show it */
        }

        /* --- Visibility Control --- */
        #main-menu-section,
        #multiplayer-menu-section,
        #host-wait-section,
        #join-code-section,
        #game-area,
        #game-over-screen {
            display: none; /* Hide all sections by default */
        }

        /* --- Common Elements --- */
        #game-status { min-height: 25px; color: var(--accent-color); font-weight: bold; margin-bottom: 15px; }
        /* --- Restored Common Element Styles --- */
        button {
            background-color: var(--primary-color); color: white; border: 2px solid var(--bg-color);
            padding: 10px 20px; margin: 10px 5px; cursor: pointer; font-family: var(--font-family);
            font-size: 1rem; transition: background-color 0.2s ease; border-radius: 5px;
        }
        button:hover:not(:disabled) { background-color: #FF4500; }
        button:disabled { background-color: #777; cursor: not-allowed; }
        input[type="text"] {
            padding: 10px; margin: 10px 5px; width: 180px; font-family: var(--font-family); font-size: 1rem;
            border: 2px solid var(--primary-color); border-radius: 5px; background-color: var(--text-color);
            color: var(--bg-color); text-transform: uppercase;
        }

        /* --- Menu Sections --- */
        /* --- Restored Menu Section Styles --- */
        .menu-section {
             padding: 30px; text-align: center;
             box-sizing: border-box;
             width: 100%;
        }
        .menu-section h2 { color: var(--accent-color); margin-bottom: 20px; }
        .menu-section button {
            display: block; width: 80%; max-width: 300px;
            margin: 15px auto; padding: 15px 20px; font-size: 1.2rem;
        }
        .menu-section input[type="text"] { display: inline-block; width: auto; min-width: 180px; }

        /* --- Host/Join Specific --- */
        /* --- Restored Host/Join Styles --- */
         #host-wait-section p, #join-code-section p { font-size: 1.1rem; margin-bottom: 10px; }
         #game-code-display { font-size: 1.8rem; font-weight: bold; color: var(--accent-color); background-color: var(--bg-color); padding: 5px 15px; border-radius: 5px; display: inline-block; margin: 10px 0; user-select: all; }
         #waiting-message { margin-top: 15px; font-style: italic;}

        /* --- Game Area Elements --- */
        /* REMOVED empty #game-area {} rule */
        #gameCanvas {
            border: 3px solid var(--primary-color); background-color: #A0522D; /* Default day background */
            display: block; margin: 10px auto 0px; /* Reduced bottom margin */
            max-width: 100%; height: auto;
        }
        #countdown { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 72px; color: var(--player-color); text-shadow: 3px 3px 6px black; z-index: 10; pointer-events: none; display: none; }

        /* --- Chat Section Styling --- */
        #chat-section {
            display: flex; margin-top: 10px; /* Space above chat */
            align-items: center; flex-wrap: wrap; width: 100%;
            padding: 0 5px; /* Align chat input/log slightly inside canvas border */
            box-sizing: border-box;
        }
        #chatInput {
             flex-grow: 1; margin-right: 5px; min-width: 200px;
             /* Specific adjustments - uses base input styles */
             padding: 8px; font-size: 0.9rem; margin-bottom: 5px;
        }
        #sendChatBtn {
             /* Specific adjustments - uses base button styles */
             margin-left: 5px; padding: 8px 15px; font-size: 0.9rem; margin-bottom: 5px;
        }
        #chat-log {
            height: 80px; overflow-y: scroll; border: 1px solid var(--primary-color);
            margin-top: 0; /* Removed top margin */
            padding: 5px; text-align: left; background: rgba(0,0,0,0.3);
            font-size: 13px; border-radius: 5px; flex-basis: 100%; order: 3; /* Ensures log is below input/button */
            transition: background-color 0.5s ease, border-color 0.5s ease; /* Smooth transition */
        }
        #chat-log div { margin-bottom: 3px; word-wrap: break-word; }
        #chat-log .my-message { color: var(--bullet-player-color); }
        #chat-log .other-message { color: var(--text-color); }
        #chat-log .system-message { color: var(--accent-color); font-style: italic; }

        /* --- Night Mode Chat Styling --- */
        #game-container.night-mode #chat-log {
            background-color: rgba(15, 20, 50, 0.7); border-color: var(--accent-color);
        }
        #game-container.night-mode #chat-log .my-message { color: #FFFF99; }
        #game-container.night-mode #chat-log .other-message { color: #C0C0FF; }
        #game-container.night-mode #chat-log .system-message { color: #FFB050; }

        /* --- Game Over Screen --- */
        /* --- Restored Game Over Styles --- */
        #game-over-screen {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85); padding: 30px; border: 3px solid var(--player-color);
            border-radius: 10px; color: var(--accent-color); text-align: center; z-index: 20;
            width: 80%; max-width: 500px; display: none; /* Start hidden */
            box-sizing: border-box;
        }
        #game-over-screen h2 { color: var(--player-color); margin-top: 0;}
        #final-stats { margin-bottom: 20px; text-align: left; color: var(--text-color); }
        #final-stats strong { color: white; }
        #game-over-screen button { margin-top: 10px; }

    </style>
</head>
<body>
    <div id="game-container">
        <!-- Top Bar -->
        <div id="top-bar">
            <h1>SUCH IS LIFE</h1>
            <div id="player-stats-container">
    <!-- Container for BOTH player stats displays -->
    <div id="mp-stats-display" style="display: flex; justify-content: flex-start; gap: 15px;">
        <!-- Stats for Local Player -->
        <div id="local-player-stats" class="player-stats-box">
            <div class="stats-header">YOU</div>
            <div class="stats-content">Loading...</div>
        </div>
        <!-- Stats for Teammate -->
        <div id="mate-player-stats" class="player-stats-box" style="display: none;"> <!-- Start hidden -->
            <div class="stats-header">MATE</div>
            <div class="stats-content">Waiting...</div>
        </div>
    </div>
</div>
<!-- Game Info Container remains the same -->
<div id="game-info-container">
    <div id="game-info">Score: 0 | Level: 1</div>
    <div id="day-night-indicator">Day</div>
</div>
        </div>

        <div id="game-status">Initializing...</div>

        <!-- Menu Sections -->
        <div id="main-menu-section" class="menu-section">
            <h2>Main Menu</h2>
            <button id="singlePlayerBtn">Single Player</button>
            <button id="multiplayerBtn">Multiplayer</button>
        </div>
        <div id="multiplayer-menu-section" class="menu-section">
             <h2>Multiplayer</h2>
             <button id="hostGameBtn">Host Game (Get Code)</button>
             <button id="showJoinUIBtn">Join Game (Enter Code)</button>
             <button class="back-button" onclick="showSection('main-menu-section')">Back</button>
        </div>
        <div id="host-wait-section" class="menu-section">
             <h2>Hosting Game</h2>
             <p>Share this code with your mate:</p>
             <div id="game-code-display">------</div>
             <p id="waiting-message">Waiting for opponent to connect...</p>
             <button id="cancelHostBtn">Cancel Hosting</button>
        </div>
        <div id="join-code-section" class="menu-section">
             <h2>Join Game</h2>
             <p>Enter the 6-character game code:</p>
             <input type="text" id="gameIdInput" placeholder="ABCDEF" maxlength="6">
             <button id="joinGameSubmitBtn">Join Game</button>
             <button class="back-button" onclick="showSection('multiplayer-menu-section')">Back</button>
        </div>

        <!-- Game Area -->
        <div id="game-area">
            <div style="position: relative;">
                <canvas id="gameCanvas" width="800" height="600"></canvas>
                <div id="countdown"></div>
            </div>
            <div id="chat-section">
                 <input type="text" id="chatInput" placeholder="Say somethin', mate..." maxlength="50">
                 <button id="sendChatBtn">Send</button>
                 <div id="chat-log"></div>
            </div>
             <button id="leaveGameBtn">Leave Game</button>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen">
            <h2>Game Over, Mate!</h2>
            <div id="final-stats"></div>
            <button id="gameOverBackBtn">Back to Menu</button>
        </div>

    </div>

    <script>
        // --- Constants (Defined First) ---
        const WEBSOCKET_URL = 'wss://such-is-life.glitch.me/ws'; // UPDATE IF YOUR GLITCH URL CHANGES
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 600;
        const PLAYER_WIDTH = 20; const PLAYER_HEIGHT = 20;
        const ENEMY_WIDTH = 25; const ENEMY_HEIGHT = 25; const BULLET_RADIUS = 4; const POWERUP_SIZE = 12;
        const SHOOT_COOLDOWN = 200; // ms
        const INPUT_SEND_INTERVAL = 50; // ms
        const MAX_PLAYERS = 2;
        const RECONNECT_DELAY = 3000; // ms
        // Default player state values needed for rendering/prediction before server state arrives
        const PLAYER_DEFAULTS = { width: 20, height: 20, max_health: 100 };
        const ENEMY_DEFAULTS = { width: 25, height: 25, max_health: 50 };
        const BULLET_DEFAULTS = { radius: 4 };
        // --- End Constants ---

        // --- Utility Functions ---
        function getCssVar(varName) { return getComputedStyle(document.documentElement).getPropertyValue(varName).trim() || ''; }
        function lerp(start, end, amount) { return start + (end - start) * amount; }
        function distance(x1, y1, x2, y2) { const dx = x1 - x2; const dy = y1 - y2; return Math.sqrt(dx * dx + dy * dy); }

        // --- DOM Elements ---
        const DOM = {
            gameContainer: document.getElementById('game-container'),
            gameStatus: document.getElementById('game-status'),
            // Sections
            mainMenuSection: document.getElementById('main-menu-section'),
            multiplayerMenuSection: document.getElementById('multiplayer-menu-section'),
            hostWaitSection: document.getElementById('host-wait-section'),
            joinCodeSection: document.getElementById('join-code-section'),
            gameArea: document.getElementById('game-area'),
            gameOverScreen: document.getElementById('game-over-screen'),
            // Specific elements
            gameCodeDisplay: document.getElementById('game-code-display'),
            waitingMessage: document.getElementById('waiting-message'),
            gameIdInput: document.getElementById('gameIdInput'),
            canvas: document.getElementById('gameCanvas'),
            ctx: document.getElementById('gameCanvas').getContext('2d'),
            // playerStatsDiv: document.getElementById('player-stats'), // REMOVED OLD
            localPlayerStatsBoxContent: document.querySelector('#local-player-stats .stats-content'), // NEW LOCAL CONTENT
            matePlayerStatsBox: document.getElementById('mate-player-stats'),               // NEW MATE CONTAINER
            matePlayerStatsBoxContent: document.querySelector('#mate-player-stats .stats-content'), // NEW MATE CONTENT
            gameInfoDiv: document.getElementById('game-info'),
            countdownDiv: document.getElementById('countdown'),
            dayNightIndicator: document.getElementById('day-night-indicator'),
            finalStatsDiv: document.getElementById('final-stats'),
            chatInput: document.getElementById('chatInput'),
            chatLog: document.getElementById('chat-log'),
            // Buttons (listeners assigned in Game.initListeners)
            singlePlayerBtn: document.getElementById('singlePlayerBtn'),
            multiplayerBtn: document.getElementById('multiplayerBtn'),
            hostGameBtn: document.getElementById('hostGameBtn'),
            showJoinUIBtn: document.getElementById('showJoinUIBtn'),
            cancelHostBtn: document.getElementById('cancelHostBtn'),
            joinGameSubmitBtn: document.getElementById('joinGameSubmitBtn'),
            sendChatBtn: document.getElementById('sendChatBtn'),
            leaveGameBtn: document.getElementById('leaveGameBtn'),
            gameOverBackBtn: document.getElementById('gameOverBackBtn'),
        };

        // --- Global Client State ---
        let appState = {
            mode: 'menu', // Start in menu
            localPlayerId: null,
            currentGameId: null,
            serverState: null, // Latest authoritative state from server
            animationFrameId: null,
            isConnected: false,
            // Interpolation/Prediction State
            renderedPlayerPos: { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 },
            predictedPlayerPos: { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 },
            lastServerState: null,     // State before latest
            previousServerState: null, // State before that
            lastLoopTime: performance.now(),
            lastStateReceiveTime: performance.now(), // Initialize with current time

        };
        let socket = null; // Single WebSocket connection reference

        // --- Logging Wrapper ---
        function log(...args) { console.log("[Client]", ...args); }
        function error(...args) { console.error("[Client]", ...args); }

        // --- UI Management "Module" ---
        const UI = (() => {
            const allSections = [
                DOM.mainMenuSection, DOM.multiplayerMenuSection, DOM.hostWaitSection,
                DOM.joinCodeSection, DOM.gameArea, DOM.gameOverScreen
            ];

            function showSection(sectionId) {
                // Ensure allSections includes valid DOM elements before hiding
                allSections.forEach(s => { if(s) s.style.display = 'none'; });
                const sectionToShow = DOM[sectionId] || document.getElementById(sectionId);
                if (sectionToShow) {
                    sectionToShow.style.display = 'block';
                    log(`UI: Showing section: ${sectionId}`);
                } else {
                     error(`UI: Section not found: ${sectionId}`);
                }
            }

            function updateStatus(message, isError = false) {
                 if (DOM.gameStatus) { // Add check for existence
                     DOM.gameStatus.textContent = message;
                     DOM.gameStatus.style.color = isError ? (getCssVar('--player-color') || 'red') : (getCssVar('--accent-color') || 'yellow');
                     if(isError) console.error("Status Update:", message);
                     else console.log("Status Update:", message);
                 } else {
                     error("DOM.gameStatus not found for update:", message);
                 }
            }

            // UPDATED updateHUD function for Multiplayer Stats
            function updateHUD(player, serverState) {
                // Find local player and teammate
                const localPlayer = player; // 'player' passed in is assumed to be local
                let matePlayer = null;
                let mateId = null;

                // Find the teammate ID (only works robustly if exactly 2 players expected)
                if (serverState?.players && Object.keys(serverState.players).length > 1 && appState.localPlayerId) {
                     mateId = Object.keys(serverState.players).find(id => id !== appState.localPlayerId);
                     if (mateId) {
                         matePlayer = serverState.players[mateId];
                     }
                }

                // --- Update Local Player Stats ---
                // Check if the specific DOM element exists before updating
                if (DOM.localPlayerStatsBoxContent) {
                     if (localPlayer) {
                        // Indicate if local player is dead
                        const healthDisplay = localPlayer.health <= 0 ? "<span style='color: var(--health-bar-low);'>DEAD</span>" : `${localPlayer.health ?? 0}/${localPlayer.max_health ?? 100}`;
                        DOM.localPlayerStatsBoxContent.innerHTML = `
                            <span>HP:</span> ${healthDisplay}<br>
                            <span>Armor:</span> ${localPlayer.armor ?? 0}<br>
                            <span>Gun:</span> ${localPlayer.gun ?? 1}<br>
                            <span>Speed:</span> ${localPlayer.speed ?? 150}<br>
                            <span>Kills:</span> ${localPlayer.kills ?? 0} | <span>Score:</span> ${localPlayer.score ?? 0}`;
                    } else {
                         DOM.localPlayerStatsBoxContent.textContent = "Waiting...";
                    }
                } else {
                    log("DOM.localPlayerStatsBoxContent not found"); // Log error if element missing
                }


                // --- Update Mate Player Stats ---
                // Check if the specific DOM elements exist before updating
                if (DOM.matePlayerStatsBox && DOM.matePlayerStatsBoxContent) {
                    if (matePlayer) {
                        DOM.matePlayerStatsBox.style.display = 'block'; // Show the mate's box
                        // Indicate if mate is dead
                        const mateHealthDisplay = matePlayer.health <= 0 ? "<span style='color: var(--health-bar-low);'>DEAD</span>" : `${matePlayer.health ?? 0}/${matePlayer.max_health ?? 100}`;
                        DOM.matePlayerStatsBoxContent.innerHTML = `
                            <span>HP:</span> ${mateHealthDisplay}<br>
                            <span>Armor:</span> ${matePlayer.armor ?? 0}<br>
                            <span>Gun:</span> ${matePlayer.gun ?? 1}<br>
                            <span>Speed:</span> ${matePlayer.speed ?? 150}<br>
                            <span>Kills:</span> ${matePlayer.kills ?? 0} | <span>Score:</span> ${matePlayer.score ?? 0}`;
                    } else {
                        // Hide mate's box if not present or only 1 player
                        DOM.matePlayerStatsBox.style.display = 'none';
                        DOM.matePlayerStatsBoxContent.textContent = "Waiting...";
                    }
                } else {
                     log("DOM.matePlayerStatsBox or DOM.matePlayerStatsBoxContent not found"); // Log error if elements missing
                }


                // --- Update General Game Info (Score/Level) ---
                if (DOM.gameInfoDiv) {
                     const totalScore = serverState?.score ?? 0; // Use game's total score from server
                     DOM.gameInfoDiv.innerHTML = `Score: ${totalScore} | Level: ${serverState?.level ?? 1}`;
                } else {
                     log("DOM.gameInfoDiv not found"); // Log error if element missing
                }

             } // End of updateHUD

            function addChatMessage(sender, message, isSelf, isSystem = false) {
                // Add check for DOM.chatLog existence
                if (!DOM.chatLog) { error("DOM.chatLog not found for chat message."); return; }
                const div = document.createElement('div');
                if (isSystem) {
                    div.className = 'system-message'; div.textContent = message;
                } else {
                    div.className = isSelf ? 'my-message' : 'other-message';
                    // Use player ID for now, could map to names later
                    div.textContent = `${sender ? `P:${sender.substring(0,4)}` : '???'}: ${message}`;
                }
                DOM.chatLog.appendChild(div);
                DOM.chatLog.scrollTop = DOM.chatLog.scrollHeight; // Scroll to bottom
            }

            function updateCountdown(serverState) {
                // Add checks for DOM elements
                 if (DOM.countdownDiv && DOM.dayNightIndicator) {
                    if (serverState?.status === 'countdown' && serverState?.countdown >= 0) {
                        DOM.countdownDiv.textContent = Math.ceil(serverState.countdown);
                        DOM.countdownDiv.style.display = 'block';
                        DOM.dayNightIndicator.style.display = 'none';
                    } else {
                        DOM.countdownDiv.style.display = 'none';
                        DOM.dayNightIndicator.style.display = (serverState?.status === 'active') ? 'inline-block' : 'none'; // Use inline-block for day/night
                    }
                } else {
                    error("DOM.countdownDiv or DOM.dayNightIndicator not found.");
                }
             }

            function updateDayNight(serverState) {
                 // Add checks for DOM elements
                 if (DOM.dayNightIndicator && DOM.canvas && DOM.gameContainer) {
                     if (serverState?.status === 'active') {
                        const isNight = serverState.is_night;
                        DOM.dayNightIndicator.textContent = isNight ? 'Night' : 'Day';
                        DOM.canvas.style.backgroundColor = isNight ? (getCssVar('--bg-color') || '#3E2723') : '#A0522D';
                        DOM.dayNightIndicator.style.display = 'inline-block'; // Use inline-block

                        if (isNight) {
                            DOM.gameContainer.classList.add('night-mode');
                        } else {
                            DOM.gameContainer.classList.remove('night-mode');
                        }
                     } else {
                        DOM.dayNightIndicator.style.display = 'none';
                        DOM.gameContainer.classList.remove('night-mode');
                     }
                 } else {
                      error("DOM.dayNightIndicator, DOM.canvas, or DOM.gameContainer not found for day/night update.");
                 }
             }

            function showGameOver(finalState) {
                // Add checks for DOM elements
                if (!DOM.finalStatsDiv || !DOM.gameOverScreen) {
                     error("DOM.finalStatsDiv or DOM.gameOverScreen not found."); return;
                }

                const player = finalState?.players[appState.localPlayerId];
                let statsHtml = "Could not load final stats.";
                if (player) {
                     statsHtml = `<strong>Score:</strong> ${player.score ?? 0}<br>
                                  <strong>Kills:</strong> ${player.kills ?? 0}<br>
                                  <strong>Level:</strong> ${finalState?.level ?? 1}`;
                     // Find teammate only if players object exists
                     const players = finalState?.players ?? {};
                     const teammateId = Object.keys(players).find(id => id !== appState.localPlayerId);
                     if (teammateId && players[teammateId]) {
                          const teammate = players[teammateId];
                          statsHtml += `<br><br><strong>Teammate Score:</strong> ${teammate.score ?? 0}<br>
                                        <strong>Teammate Kills:</strong> ${teammate.kills ?? 0}`;
                     }
                }
                DOM.finalStatsDiv.innerHTML = statsHtml;

                log("UI: Attempting to show game over screen (if enabled).");
                 // Hide other sections - ensure they exist first
                 [DOM.mainMenuSection, DOM.multiplayerMenuSection, DOM.hostWaitSection,
                  DOM.joinCodeSection, DOM.gameArea].forEach(s => { if (s) s.style.display = 'none'; });

                DOM.gameOverScreen.style.display = 'block'; // Show game over
            } // End showGameOver

            // Expose necessary UI functions
            return {
                showSection,
                updateStatus,
                updateHUD, // Now updated
                addChatMessage,
                updateCountdown,
                updateDayNight,
                showGameOver
            };
        })(); // <-- This closes the UI IIFE


        // --- Network "Module" ---
        const Network = (() => {
            let reconnectTimer = null;

            function connect(onOpenCallback) {
                // Prevent multiple connections
                if (socket && socket.readyState !== WebSocket.CLOSED) {
                    log("Connect called but socket exists, state:", socket.readyState);
                    if (socket.readyState === WebSocket.OPEN && onOpenCallback) {
                        onOpenCallback(); // Call callback if already open
                    }
                    return;
                }
                clearTimeout(reconnectTimer); // Clear any pending reconnect attempts
                UI.updateStatus('Connecting...');
                log("Attempting WebSocket connection to:", WEBSOCKET_URL);

                try {
                    socket = new WebSocket(WEBSOCKET_URL);
                } catch (err) {
                    error("WebSocket creation failed:", err);
                    UI.updateStatus('Connection failed (WebSocket Error). Please refresh.', true);
                    return; // Stop connection attempt
                }


                socket.onopen = () => {
                    log('WebSocket connection established.');
                    appState.isConnected = true;
                    UI.updateStatus('Connected.');
                    // Ensure menu is shown only after connection
                    UI.showSection('main-menu-section');
                    if (onOpenCallback) onOpenCallback();
                };

                socket.onmessage = handleServerMessage; // Use the global handler

                socket.onerror = (event) => {
                    // Browsers often don't provide detailed error info here,
                    // rely on onclose for failure/reconnect logic.
                    error('WebSocket Error Event:', event);
                };

                socket.onclose = (event) => {
                    error(`WebSocket Closed: Code=${event.code}, Reason='${event.reason || 'N/A'}'`);
                    const wasConnected = appState.isConnected;
                    appState.isConnected = false;
                    socket = null; // Clear socket reference
                    // Reset game state but keep UI showing error/reconnecting message
                    Game.resetClientState(false);

                    if (event.code === 1000) { // Normal closure (e.g., user left game)
                        UI.updateStatus('Disconnected.');
                        UI.showSection('main-menu-section'); // Back to main menu
                    } else if (wasConnected) { // Abnormal closure after successful connection
                         UI.updateStatus('Connection lost. Reconnecting...', true);
                         scheduleReconnect();
                    } else { // Failed initial connection attempt
                         UI.updateStatus('Connection failed. Please check console and refresh.', true);
                         // Consider disabling buttons here?
                    }
                    // Stop game loop if it was running
                     if (appState.animationFrameId) {
                         cancelAnimationFrame(appState.animationFrameId);
                         appState.animationFrameId = null;
                         Input.cleanup(); // Clean input listeners if loop stops
                         log("Game loop stopped due to connection close.");
                     }
                };
            }

            function scheduleReconnect() {
                 clearTimeout(reconnectTimer);
                 log(`Scheduling reconnect in ${RECONNECT_DELAY}ms`);
                 reconnectTimer = setTimeout(() => {
                     log("Attempting reconnect...");
                     // Pass a callback to handle UI on successful reconnect
                     connect(() => {
                          UI.updateStatus('Reconnected.');
                          UI.showSection('main-menu-section'); // Go back to menu after reconnect
                     });
                 }, RECONNECT_DELAY);
            }

            function sendMessage(payload) {
                if (socket && socket.readyState === WebSocket.OPEN) {
                    try {
                        const msg = JSON.stringify(payload);
                        // log("Sending:", msg.substring(0, 150)); // Optional: Log sent message snippet
                        socket.send(msg);
                    } catch (err) {
                        error("Error sending message:", err, payload);
                    }
                } else {
                    error('Cannot send message, WebSocket not open or null.', payload);
                    // Maybe trigger reconnect attempt if socket is unexpectedly closed?
                    if (!socket || socket.readyState === WebSocket.CLOSED) {
                         // scheduleReconnect(); // Be careful not to spam reconnects
                    }
                }
            }

             function closeConnection(code = 1000, reason = "User action") {
                 clearTimeout(reconnectTimer); // Stop reconnect attempts on manual close
                 if (socket && socket.readyState === WebSocket.OPEN) {
                     log(`Closing WebSocket explicitly: ${reason} (Code: ${code})`);
                     socket.close(code, reason);
                 } else {
                    log("closeConnection called but socket not open or null.");
                 }
                 // Clear refs and state immediately, onclose handler will confirm
                 socket = null;
                 appState.isConnected = false;
             }

            return { connect, sendMessage, closeConnection };
        })();
        
        // --- Input Handling "Module" ---
        // --- Input Handling "Module" ---
        const Input = (() => {
             let keys = {};
             let lastShotTime = 0;
             let movementInterval = null;
             // Store mouse position relative to canvas
             let mouseCanvasPos = { x: 0, y: 0 };

             function setup() {
                cleanup(); // Ensure no duplicate listeners
                document.addEventListener('keydown', handleKeyDown);
                document.addEventListener('keyup', handleKeyUp);
                DOM.chatInput.addEventListener('keydown', handleChatEnter);

                // Add mouse listeners to the canvas
                if (DOM.canvas) { // Ensure canvas exists
                     DOM.canvas.addEventListener('mousemove', handleMouseMove);
                     DOM.canvas.addEventListener('mousedown', handleMouseDown); // Use mousedown for responsiveness
                } else {
                     error("Input setup failed: Canvas element not found.");
                }

                movementInterval = setInterval(sendMovementInput, INPUT_SEND_INTERVAL);
                log("Input listeners setup.");
             }

             function cleanup() {
                 document.removeEventListener('keydown', handleKeyDown);
                 document.removeEventListener('keyup', handleKeyUp);
                 DOM.chatInput.removeEventListener('keydown', handleChatEnter);

                 // Remove mouse listeners
                 if (DOM.canvas) { // Check if canvas exists before removing
                      DOM.canvas.removeEventListener('mousemove', handleMouseMove);
                      DOM.canvas.removeEventListener('mousedown', handleMouseDown);
                 }

                 clearInterval(movementInterval);
                 movementInterval = null;
                 keys = {}; // Reset keys state
                 mouseCanvasPos = { x: 0, y: 0 }; // Reset mouse pos state
                 log("Input listeners cleaned up.");
             }

             // Update mouse position relative to canvas
             function handleMouseMove(event) {
                 if (!DOM.canvas) return; // Should not happen if listener attached, but safety first
                 const rect = DOM.canvas.getBoundingClientRect();
                 mouseCanvasPos.x = event.clientX - rect.left;
                 mouseCanvasPos.y = event.clientY - rect.top;
             }

            // Trigger shooting on left mouse click
            function handleMouseDown(event) {
                if (document.activeElement === DOM.chatInput) return; // Ignore if typing chat
                // Check if left mouse button (button === 0)
                if (event.button === 0) {
                    handleShooting(); // Trigger shooting logic
                    event.preventDefault(); // Prevent text selection etc.
                }
            }

             // Handle keyboard presses
             function handleKeyDown(e) {
                 if (document.activeElement === DOM.chatInput) return; // Ignore if typing chat
                 const key = e.key.toLowerCase();
                 // Track movement keys & spacebar
                 if (['w','a','s','d','arrowup','arrowdown','arrowleft','arrowright',' '].includes(key)) {
                    keys[key] = true;
                 }
                 // Trigger shooting on spacebar press
                 if (key === ' ') {
                    handleShooting(); // Keep spacebar shooting
                 }
                 // Prevent default browser actions for game keys
                 if ([' ','w','a','s','d','arrowup','arrowdown','arrowleft','arrowright'].includes(key)) {
                    e.preventDefault();
                 }
             }

             // Handle keyboard releases
             function handleKeyUp(e) {
                 const key = e.key.toLowerCase();
                 if (key in keys) {
                     keys[key] = false;
                 }
             }

             // Handle sending chat on Enter
             function handleChatEnter(e) {
                 if (e.key === 'Enter') {
                     e.preventDefault(); // Prevent default form submission/newline
                     Game.sendChatMessage(); // Delegate sending to Game module
                 }
             }

             // Calculate current movement vector based on keys pressed
             function getMovementInputVector() {
                 let dx = 0, dy = 0;
                 if (keys['w'] || keys['arrowup']) dy -= 1;
                 if (keys['s'] || keys['arrowdown']) dy += 1;
                 if (keys['a'] || keys['arrowleft']) dx -= 1;
                 if (keys['d'] || keys['arrowright']) dx += 1;

                 // Normalize diagonal movement
                 if (dx !== 0 && dy !== 0) {
                     const factor = 1 / Math.sqrt(2);
                     dx *= factor;
                     dy *= factor;
                 }
                 return { dx, dy };
             }

             // Periodically send movement input to server if game is active
             function sendMovementInput() {
                 if (appState.serverState?.status === 'active') {
                    const moveVector = getMovementInputVector();
                    Network.sendMessage({ type: 'player_move', direction: moveVector });
                 }
             }

             // Handle shooting logic (triggered by space or mouse click)
             function handleShooting() {
                 // Check cooldown and game status
                 if (appState.serverState?.status !== 'active') return;
                 const now = Date.now();
                 if (now - lastShotTime < SHOOT_COOLDOWN) return; // Check cooldown early

                 lastShotTime = now;

                 // Calculate Aim Direction based on mouse position relative to player
                 // Use rendered position for immediate feedback, server validates later
                 const playerRenderX = appState.renderedPlayerPos.x;
                 const playerRenderY = appState.renderedPlayerPos.y;

                 let aimDx = mouseCanvasPos.x - playerRenderX;
                 let aimDy = mouseCanvasPos.y - playerRenderY;

                 // Normalize the direction vector
                 const magnitude = Math.sqrt(aimDx * aimDx + aimDy * aimDy);

                 let normalizedDx = 0;
                 let normalizedDy = -1; // Default to UP if magnitude is zero (mouse exactly on player center)

                 if (magnitude > 0.01) { // Avoid division by zero
                     normalizedDx = aimDx / magnitude;
                     normalizedDy = aimDy / magnitude;
                 }

                 const aimDirection = { dx: normalizedDx, dy: normalizedDy };

                 log("Sending shoot message. Dir:", aimDirection);
                 Network.sendMessage({ type: 'player_shoot', direction: aimDirection });
                 // Optional: Play shoot sound locally
                 // Game.playSound('shoot');
             }

             // Expose necessary functions
             return { setup, cleanup, getMovementInputVector };
        })();
        
        // --- Rendering "Module" ---
        const Renderer = (() => {
            const ctx = DOM.ctx;
            const lerpFactor = parseFloat(getCssVar('--lerp-factor')) || 0.2;

            function drawGame() {
                 // Background color is now set via CSS based on day/night state changes
                 ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                 const now = performance.now();

                 // Determine which state object to use for rendering
                 let stateToRender;
                 if (appState.mode === 'singleplayer') {
                     // Assuming SP uses server state for now
                     stateToRender = appState.serverState;
                     // If purely local SP, would be: stateToRender = Game.getLocalGameState();
                     // Adjust renderedPlayerPos directly if SP is local
                     const spPlayer = stateToRender?.players[appState.localPlayerId];
                     if (spPlayer) {
                         appState.renderedPlayerPos.x = spPlayer.x;
                         appState.renderedPlayerPos.y = spPlayer.y;
                     }
                 } else { // Multiplayer uses interpolated state
                     stateToRender = getInterpolatedState(now);
                 }

                 // Don't draw if state is missing or essential info isn't ready
                 if (!stateToRender || !appState.localPlayerId || !stateToRender.players) {
                    // log("Skipping draw: No state, localPlayerId, or players");
                    return;
                 }

                 // --- Draw Game Elements ---
                 drawPowerups(stateToRender.powerups);
                 drawBullets(stateToRender.bullets);
                 drawEnemies(stateToRender.enemies);
                 drawPlayers(stateToRender.players); // Handles local vs remote rendering inside
                 // drawMapObstacles(stateToRender.map); // Future enhancement
            }

            function getInterpolatedState(now) {
                const { serverState, lastServerState, previousServerState } = appState;
                // Need at least two distinct states for interpolation
                if (!serverState || !lastServerState || serverState.timestamp === lastServerState.timestamp) {
                    return serverState; // Use latest known state if no interpolation possible
                }
                // If previous is missing, can't interpolate, use latest
                if (!previousServerState) {
                    return serverState;
                }

                const timeBetweenUpdates = lastServerState.timestamp - previousServerState.timestamp;
                const timeSinceLastUpdate = (now / 1000) - lastServerState.timestamp; // Client time (ms) vs Server time (s)

                // Prevent division by zero and handle potential timing issues
                let factor = 0;
                if (timeBetweenUpdates > 0.001) { // Avoid division by zero or tiny intervals
                    factor = timeSinceLastUpdate / timeBetweenUpdates;
                }

                // Clamp factor: Usually 0-1, allow slight extrapolation (e.g., up to 1.5) if needed for smoothness
                factor = Math.max(0, Math.min(factor, 1.5));

                // Create a deep copy to avoid modifying original states
                let iState = JSON.parse(JSON.stringify(serverState)); // Start with latest as base

                // Interpolate entities present in both last two states
                ['players', 'enemies', 'bullets', 'powerups'].forEach(key => {
                    if (!iState[key] || !lastServerState[key] || !previousServerState[key]) return;

                    Object.keys(iState[key]).forEach(id => {
                        const current = iState[key][id]; // Entity in the latest state
                        const previous = previousServerState[key]?.[id]; // Entity in the state before last
                        const last = lastServerState[key]?.[id]; // Entity in the last state

                        // Check if entity exists in the necessary states for interpolation
                        if (previous && last && current) {
                            // Don't interpolate the local player - use reconciled render position
                            if (id === appState.localPlayerId) {
                                current.x = appState.renderedPlayerPos.x;
                                current.y = appState.renderedPlayerPos.y;
                            }
                            // Interpolate other entities based on *previous* and *last* states
                            else if (current.x !== undefined && previous.x !== undefined && last.x !== undefined) {
                                // Lerp between the position in the previous state and the last state
                                current.x = lerp(previous.x, last.x, factor);
                                current.y = lerp(previous.y, last.y, factor);
                            }
                        }
                        // If entity wasn't in previous states, just use its current position from serverState
                    });
                });
                return iState; // Return the interpolated state object
            }

            // --- Specific Drawing Functions ---
            function drawPlayers(players) {
                if (!players) return;
                Object.values(players).forEach(player => {
                    // Only draw players with positive health
                    if (!player || player.health <= 0) return;
                    const isSelf = player.id === appState.localPlayerId;
                    // Use dedicated render position for local player, interpolated/latest for others
                    const drawX = isSelf ? appState.renderedPlayerPos.x : player.x;
                    const drawY = isSelf ? appState.renderedPlayerPos.y : player.y;
                    // Use defaults if dimensions/max_health aren't available yet
                    const width = player.width ?? PLAYER_DEFAULTS.width;
                    const height = player.height ?? PLAYER_DEFAULTS.height;
                    const maxHealth = player.max_health ?? PLAYER_DEFAULTS.max_health;

                    drawPlayerRect(drawX, drawY, width, height, isSelf); // Pass dimensions
                    drawHealthBar(drawX, drawY, width, player.health, maxHealth); // Use actual width
                    // Draw player chat message if active (logic needed)
                });
            }

            function drawPlayerRect(x, y, w, h, isSelf) {
                 // Placeholder: Replace with sprite drawing logic
                 ctx.fillStyle = isSelf ? (getCssVar('--player-color') || 'red') : (getCssVar('--other-player-color') || 'blue');
                 ctx.fillRect(x - w / 2, y - h / 2, w, h);
                 // Example direction indicator (replace with sprite rotation)
                 // ctx.fillStyle = '#FFF'; ctx.beginPath(); ctx.moveTo(x, y - h / 2 - 2); ctx.lineTo(x - 3, y - h / 2 + 2); ctx.lineTo(x + 3, y - h / 2 + 2); ctx.fill();
            }

            function drawEnemies(enemies) {
                if (!enemies) return;
                Object.values(enemies).forEach(enemy => {
                    if (!enemy || enemy.health <= 0) return;
                    const width = enemy.width ?? ENEMY_DEFAULTS.width;
                    const height = enemy.height ?? ENEMY_DEFAULTS.height;
                    const maxHealth = enemy.max_health ?? ENEMY_DEFAULTS.max_health;
                    drawEnemyRect(enemy.x, enemy.y, width, height);
                    drawHealthBar(enemy.x, enemy.y, width, enemy.health, maxHealth);
                });
            }

            function drawEnemyRect(x, y, w, h) {
                 // Placeholder: Replace with sprite drawing logic
                 ctx.fillStyle = getCssVar('--enemy-color') || 'green';
                 ctx.fillRect(x - w / 2, y - h / 2, w, h);
            }

            function drawBullets(bullets) {
                if (!bullets) return;
                Object.values(bullets).forEach(bullet => {
                     if (!bullet) return;
                     const radius = bullet.radius ?? BULLET_DEFAULTS.radius;
                     drawBulletCircle(bullet.x, bullet.y, radius, bullet.owner_type === 'player');
                });
            }

            function drawBulletCircle(x, y, r, isPlayerBullet) {
                // Placeholder: Replace with sprite/effect
                ctx.fillStyle = isPlayerBullet ? (getCssVar('--bullet-player-color') || 'yellow') : (getCssVar('--bullet-enemy-color') || 'white');
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fill();
             }

            function drawPowerups(powerups) {
                if (!powerups) return;
                Object.values(powerups).forEach(powerup => {
                    if (!powerup) return;
                    const size = powerup.size ?? POWERUP_SIZE;
                    drawPowerupSquare(powerup.x, powerup.y, size, powerup.type);
                });
            }

            function drawPowerupSquare(x, y, size, type) {
                 // Placeholder: Replace with sprite
                 const colors = { /* Fetch from CSS vars */
                     'health': getCssVar('--powerup-health') || 'lime','gun_upgrade': getCssVar('--powerup-gun') || 'fuchsia',
                     'speed_boost': getCssVar('--powerup-speed') || 'aqua','armor': getCssVar('--powerup-armor') || 'silver',
                 };
                 ctx.fillStyle = colors[type] || '#CCC'; // Default color
                 ctx.fillRect(x - size / 2, y - size / 2, size, size);
                 // Optional: Draw letter indication
                 ctx.fillStyle = '#000'; ctx.font = `bold ${size * 0.7}px monospace`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                 ctx.fillText((type?.[0] ?? '?').toUpperCase(), x, y + 1);
            }
            function drawHealthBar(x, y, width, currentHealth, maxHealth) {
                if (maxHealth <= 0) return; // Avoid division by zero
                const barHeight = 5;
                const yOffset = -10; // Position above the entity center
                const barWidth = Math.max(20, width * 0.8); // Make bar slightly smaller than entity, min width
                const currentWidth = Math.max(0, (currentHealth / maxHealth) * barWidth);
                const healthPercentage = currentHealth / maxHealth;
                const barX = x - barWidth / 2; // Center the bar
                const barY = y + yOffset - barHeight / 2; // Center vertically

                // Background
                ctx.fillStyle = getCssVar('--health-bar-bg') || '#555';
                ctx.fillRect(barX, barY, barWidth, barHeight);

                // Health fill based on percentage
                let barColor = getCssVar('--health-bar-low') || '#F44336';
                if (healthPercentage > 0.66) barColor = getCssVar('--health-bar-high') || '#4CAF50';
                else if (healthPercentage > 0.33) barColor = getCssVar('--health-bar-medium') || '#FFC107';
                ctx.fillStyle = barColor;
                ctx.fillRect(barX, barY, currentWidth, barHeight);
            }

            // Expose only the main drawing function from the Renderer module
            return { drawGame };
        })(); // End Renderer module IIFE


        // --- Core Game Flow & State "Module" ---
        // Assumes appState is declared *before* this module definition
        const Game = (() => {

            // --- Game Actions ---
            function startSinglePlayer() {
                log("Requesting Single Player game...");
                appState.mode = 'singleplayer';
                resetClientState(false);
                UI.updateStatus("Starting Single Player...");
                Network.sendMessage({ type: 'start_single_player' });
                // Loop starts on server confirmation ('sp_game_started')
            }

            function hostMultiplayer() {
                log("Requesting to Host Multiplayer game...");
                appState.mode = 'multiplayer-host';
                resetClientState(false);
                UI.updateStatus("Creating game...");
                Network.sendMessage({ type: 'create_game' });
                // Loop starts on server confirmation ('game_created')
            }

            function joinMultiplayer() {
                const gameId = DOM.gameIdInput.value.trim().toUpperCase();
                if (!gameId || gameId.length !== 6) {
                    UI.updateStatus('Invalid Game ID format.', true); return;
                 }
                log(`Attempting to join game: ${gameId}`);
                appState.mode = 'multiplayer-client';
                resetClientState(false);
                UI.updateStatus(`Joining game ${gameId}...`);
                Network.sendMessage({ type: 'join_game', game_id: gameId });
                 // Loop starts on server confirmation ('game_joined')
            }

            function leaveGame() {
                log("Leaving current game / Cancelling host...");
                Network.closeConnection(1000, "User action (leave/cancel)");
                resetClientState(true); // Show menu immediately
            }

            function sendChatMessage() {
                const message = DOM.chatInput.value.trim();
                if (message && appState.isConnected && appState.currentGameId && appState.localPlayerId) {
                    Network.sendMessage({ type: 'player_chat', message: message });
                    DOM.chatInput.value = '';
                } else {
                    log("Cannot send chat: Not connected or not in a game.");
                }
            }

            function resetClientState(showMenu = true) {
                 log(`Resetting client state. Show Menu: ${showMenu}`);
                 cleanupLoop(); // Stop game loop if running first

                 // --- DO NOT RESET appState.mode here ---
                 // Mode is set by the initiating action (startSP, hostMP, joinMP)
                 // or when explicitly returning to menu.

                 appState.localPlayerId = null;
                 appState.currentGameId = null;
                 appState.serverState = null;
                 appState.lastServerState = null;
                 appState.previousServerState = null;
                 appState.predictedPlayerPos = { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 };
                 appState.renderedPlayerPos = { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 };
                 appState.lastLoopTime = null; // Reset timer

                 // Clear UI elements related to game state
                 DOM.chatLog.innerHTML = '';
                 DOM.gameCodeDisplay.textContent = '------';
                 DOM.gameIdInput.value = '';
                 DOM.countdownDiv.style.display = 'none';
                 DOM.dayNightIndicator.style.display = 'none';
                 DOM.gameOverScreen.style.display = 'none';
                 // Optional: Clear HUD?
                 // DOM.playerStatsDiv.textContent = 'Loading...';
                 // DOM.gameInfoDiv.textContent = 'Score: 0 | Level: 1';


                 // Update UI section and mode only if explicitly returning to menu
                 if (showMenu) {
                     appState.mode = 'menu'; // Set mode to 'menu' ONLY when showing the menu
                     UI.showSection('main-menu-section');
                     UI.updateStatus(appState.isConnected ? "Connected. Select Mode." : "Disconnected.");
                 }
                 // If showMenu is false, we assume we are resetting state *before*
                 // entering a game, and the correct mode ('singleplayer', 'multiplayer-host', etc.)
                 // has already been set by the function that called resetClientState(false).
             }

             // --- Game Loop Management ---

             // Define the main loop function at this scope level
            function gameLoop(currentTime) {
             // --- Game Over Check ---
             if (appState.mode === 'menu' || !appState.isConnected || appState.serverState?.game_over) {
                 log(`Stopping game loop. Mode: ${appState.mode}, Connected: ${appState.isConnected}, Game Over: ${appState.serverState?.game_over}`);
                 const finalStateForDisplay = appState.serverState; // Capture state before cleanup

                 // *** ADD STATUS UPDATE HERE ***
                 if (finalStateForDisplay?.game_over) {
                     UI.updateStatus("Game Over!"); // Or "Round Over!", "Defeated!", etc.
                     log("Game loop stopping due to game over, showing screen.");
                     // UI.showGameOver(finalStateForDisplay); // We decided to skip this for now
                 } else if (appState.mode === 'menu') {
                      UI.updateStatus(appState.isConnected ? "Connected. Select Mode." : "Disconnected."); // Reset status if returning to menu normally
                 }
                 // *** END STATUS UPDATE ***

                 cleanupLoop(); // Stop input, clear animation frame
                 // Don't call UI.showGameOver if we decided against it
                 // if (finalStateForDisplay?.game_over) {
                 //     UI.showGameOver(finalStateForDisplay);
                 // }
                 return;
             }
                 // ... (rest of gameLoop logic: state check, delta time, prediction, rendering, requestAnimationFrame) ...

                 if (!appState.serverState && appState.mode !== 'singleplayer') {
                     log("Loop: Waiting for server state update...");
                     appState.animationFrameId = requestAnimationFrame(gameLoop);
                     return;
                 }

                 if (appState.lastLoopTime === null) { appState.lastLoopTime = currentTime; }
                 const deltaTime = Math.min(0.1, (currentTime - appState.lastLoopTime) / 1000);
                 appState.lastLoopTime = currentTime;

                 if (appState.mode !== 'singleplayer' && appState.serverState?.status === 'active') {
                      updatePredictedPosition(deltaTime);
                      reconcileWithServer();
                 }

                 Renderer.drawGame();

                  // --- Continue the Loop ---
                  // Ensure we don't double-request if already stopping
                  if (appState.mode !== 'menu' && appState.isConnected && !appState.serverState?.game_over) {
                     appState.animationFrameId = requestAnimationFrame(gameLoop);
                  } else {
                     // If state changed mid-frame to stop, ensure animationFrameId is cleared
                     if(appState.animationFrameId) cleanupLoop();
                  }
             }


            function startGameLoop() {
                // --- Initial Checks ---
                // Don't start if explicitly in menu mode
                if (appState.mode === 'menu') {
                    log("StartGameLoop called but client is in menu mode.");
                    return;
                }
                // Don't start if loop is already running
                if (appState.animationFrameId) {
                    log("StartGameLoop called but loop already running.");
                    return;
                }
                // Don't start multiplayer if initial state hasn't arrived
                // (SP gets state immediately with sp_game_started)
                if (!appState.serverState && appState.mode !== 'singleplayer') {
                     log("StartGameLoop: Waiting for initial server state in multiplayer... (Loop will start via state update)");
                     return;
                }

                // --- Setup & Start ---
                Input.setup(); // <<< SETUP INPUT LISTENERS FIRST
                log("Starting game loop..."); // <<< THEN LOG
                appState.lastLoopTime = null; // Reset last time for accurate delta calculation on the first frame

                // Make the initial call to request the first frame of the game loop
                appState.animationFrameId = requestAnimationFrame(gameLoop);
            }

            function cleanupLoop() {
                 if (appState.animationFrameId) {
                     cancelAnimationFrame(appState.animationFrameId);
                     appState.animationFrameId = null;
                     log("Game loop stopped and cleaned up.");
                 } else {
                     // log("CleanupLoop called but no active loop found."); // Can be noisy
                 }
                 Input.cleanup(); // Deactivate input listeners
                 appState.lastLoopTime = null; // Reset timer
             }

             // --- Prediction & Reconciliation Functions ---
             function updatePredictedPosition(deltaTime) {
                if (!appState.localPlayerId || !appState.serverState?.players?.[appState.localPlayerId]) return; // Safety check

                const moveVector = Input.getMovementInputVector();
                const playerState = appState.serverState.players[appState.localPlayerId];
                // Use default speed if player state or speed property is missing
                const playerSpeed = playerState?.speed ?? PLAYER_DEFAULTS.base_speed;

                // Only update prediction if moving
                if (moveVector.dx === 0 && moveVector.dy === 0) return;

                appState.predictedPlayerPos.x += moveVector.dx * playerSpeed * deltaTime;
                appState.predictedPlayerPos.y += moveVector.dy * playerSpeed * deltaTime;

                // Use default dimensions if player state or dimensions are missing
                const w_half = (playerState?.width ?? PLAYER_DEFAULTS.width) / 2;
                const h_half = (playerState?.height ?? PLAYER_DEFAULTS.height) / 2;

                // Clamp prediction to canvas bounds
                appState.predictedPlayerPos.x = Math.max(w_half, Math.min(CANVAS_WIDTH - w_half, appState.predictedPlayerPos.x));
                appState.predictedPlayerPos.y = Math.max(h_half, Math.min(CANVAS_HEIGHT - h_half, appState.predictedPlayerPos.y));
             }

             function reconcileWithServer() {
                // 1. Safety Checks: Ensure necessary data exists
                if (!appState.localPlayerId || !appState.serverState?.players?.[appState.localPlayerId]) return;

                const serverPos = appState.serverState.players[appState.localPlayerId];
                if (typeof serverPos.x !== 'number' || typeof serverPos.y !== 'number') {
                    log("Reconciliation skipped: Invalid server position data.");
                    return;
                }

                // 2. Get References & Calculate Difference
                const predictedPos = appState.predictedPlayerPos;
                const renderedPos = appState.renderedPlayerPos;
                const dist = distance(predictedPos.x, predictedPos.y, serverPos.x, serverPos.y);

                // 3. Get Tuning Parameters (from CSS Vars or defaults)
                const threshold = parseFloat(getCssVar('--reconciliation-threshold')) || 5;
                const lerpFactor = parseFloat(getCssVar('--lerp-factor')) || 0.2;

                // 4. Snapping Logic: If prediction is WAY off server position...
                if (dist > threshold * 2) { // Note the '* 2' makes this a large distance snap
                    // log(`Reconciliation SNAP! Dist: ${dist.toFixed(1)}`); // Uncomment for debugging snaps
                    // Force both predicted and rendered position to match the server immediately
                    predictedPos.x = serverPos.x;
                    predictedPos.y = serverPos.y;
                    renderedPos.x = serverPos.x;
                    renderedPos.y = serverPos.y;
                } else {
                    // 5. Smoothing Logic: If prediction is reasonably close...
                    // Smoothly move the VISIBLE (rendered) position towards the PREDICTED position
                    renderedPos.x = lerp(renderedPos.x, predictedPos.x, lerpFactor);
                    renderedPos.y = lerp(renderedPos.y, predictedPos.y, lerpFactor);

                    // 6. Gentle Nudge (Subtle Correction): If prediction is slightly off (but not snapping)...
                    if (dist > 2.0) { // Hardcoded small distance check
                         // Gently pull the PREDICTED position towards the SERVER position
                         // This uses a very small factor (lerpFactor * 0.1)
                         predictedPos.x = lerp(predictedPos.x, serverPos.x, lerpFactor * 0.1);
                         predictedPos.y = lerp(predictedPos.y, serverPos.y, lerpFactor * 0.1);
                    }
                }
             }

             // Accessor not strictly needed if SP uses server state directly
             function getLocalGameState() { return appState.serverState; }

             // Setup button listeners (called once on load)
             function initListeners() {
                 log("Initializing button listeners...");
                 DOM.singlePlayerBtn.onclick = startSinglePlayer;
                 DOM.multiplayerBtn.onclick = () => UI.showSection('multiplayer-menu-section');
                 DOM.hostGameBtn.onclick = hostMultiplayer;
                 DOM.showJoinUIBtn.onclick = () => UI.showSection('join-code-section');
                 DOM.cancelHostBtn.onclick = leaveGame;
                 DOM.joinGameSubmitBtn.onclick = joinMultiplayer;
                 DOM.sendChatBtn.onclick = sendChatMessage;
                 DOM.leaveGameBtn.onclick = leaveGame;
                 DOM.gameOverBackBtn.onclick = () => resetClientState(true);

                 // Back buttons using class
                 DOM.gameContainer.querySelectorAll('.back-button').forEach(btn => {
                     const targetSectionMatch = btn.getAttribute('onclick')?.match(/'([^']+)'/);
                     if (targetSectionMatch && targetSectionMatch[1]) {
                         const targetSectionId = targetSectionMatch[1];
                         // Ensure valid section ID before overriding
                         if (DOM[targetSectionId] || document.getElementById(targetSectionId)) {
                              btn.onclick = (e) => { e.preventDefault(); UI.showSection(targetSectionId); }; // Override inline
                         } else {
                              log(`Warning: Back button target section invalid: ${targetSectionId}`);
                         }
                     } else {
                         log("Warning: Back button found without valid target in onclick:", btn);
                     }
                 });
             }

            // --- Expose necessary functions from Game module ---
            return {
                 resetClientState,
                 startGameLoop,
                 cleanupLoop,
                 sendChatMessage,
                 getLocalGameState,
                 initListeners // Expose initListeners to be called on load
            };
        })(); // End Game module IIFE


        // --- Global Server Message Handler ---
        // (Using the cleaned-up version from previous steps)
        function handleServerMessage(event) {
            let data;
            try {
                data = JSON.parse(event.data);
                log("Received:", data.type);

            } catch (err) {
                console.error("[Client] Failed to parse server message:", err, event.data);
                UI.updateStatus("Received invalid data from server.", true);
                return;
            }

            try {
                switch (data.type) {
                    case 'game_created':
                        appState.localPlayerId = data.player_id;
                        appState.currentGameId = data.game_id;
                        appState.serverState = data.initial_state;
                        const hostPlayer = appState.serverState?.players[appState.localPlayerId];
                        if (hostPlayer) {
                            appState.predictedPlayerPos = { x: hostPlayer.x, y: hostPlayer.y };
                            appState.renderedPlayerPos = { x: hostPlayer.x, y: hostPlayer.y };
                        }

                        DOM.gameCodeDisplay.textContent = appState.currentGameId || 'ERROR';
                        DOM.waitingMessage.textContent = `Waiting for Team Mate... (1/${MAX_PLAYERS})`; // Updated text
                        UI.updateStatus(`Game hosted. Code: ${appState.currentGameId}`);
                        UI.showSection('host-wait-section');
                        Game.startGameLoop(); // Start loop AFTER confirmation
                        break;

                    case 'game_joined':
                        appState.localPlayerId = data.player_id;
                        appState.currentGameId = data.game_id;
                        appState.serverState = data.initial_state;
                        const joinedPlayer = appState.serverState?.players[appState.localPlayerId];
                        if (joinedPlayer) {
                            appState.predictedPlayerPos = { x: joinedPlayer.x, y: joinedPlayer.y };
                            appState.renderedPlayerPos = { x: joinedPlayer.x, y: joinedPlayer.y };
                        }

                        UI.updateStatus(`Joined game ${appState.currentGameId}. Get ready!`);
                        UI.showSection('game-area');
                        Game.startGameLoop(); // Start loop AFTER confirmation
                        break;

                    case 'sp_game_started':
                        appState.localPlayerId = data.player_id;
                        appState.currentGameId = data.game_id;
                        appState.serverState = data.initial_state;
                        const spPlayer = appState.serverState?.players[appState.localPlayerId];
                        if (spPlayer) {
                            appState.predictedPlayerPos = { x: spPlayer.x, y: spPlayer.y };
                            appState.renderedPlayerPos = { x: spPlayer.x, y: spPlayer.y };
                        }

                        UI.updateStatus("Single Player Game Started!");
                        UI.showSection('game-area');
                        Game.startGameLoop(); // Start loop AFTER confirmation
                        break;

                    case 'game_state':
                        const previousStatus = appState.serverState?.status;
                        const wasGameOver = appState.serverState?.game_over;

                        appState.previousServerState = appState.lastServerState;
                        appState.lastServerState = appState.serverState;
                        appState.serverState = data.state;

                        if (appState.serverState.status !== previousStatus) {
                            log(`Game state changed from ${previousStatus} to ${appState.serverState.status}`);
                            if (appState.serverState.status === 'waiting' && appState.mode === 'multiplayer-host') {
                                UI.updateStatus("Teammate left. Waiting...", true); // Changed text
                                UI.showSection('host-wait-section');
                                // Update player count on wait screen when someone leaves
                                const hostPlayerCount = Object.keys(appState.serverState.players || {}).length;
                                DOM.waitingMessage.textContent = `Waiting for Team Mate... (${hostPlayerCount}/${MAX_PLAYERS})`;

                            } else if (appState.serverState.status === 'countdown') {
                                UI.updateStatus("Countdown starting...");
                                UI.showSection('game-area');
                                if (!appState.animationFrameId) Game.startGameLoop(); // Start loop if not running
                            } else if (appState.serverState.status === 'active') {
                                UI.updateStatus("Game active!");
                                UI.showSection('game-area');
                                if (!appState.animationFrameId) Game.startGameLoop(); // Start loop if not running
                            }
                        }

                        // Update HUD etc. only if game is running (not finished/waiting)
                        if (appState.serverState.status === 'countdown' || appState.serverState.status === 'active') {
                             const player = appState.serverState.players?.[appState.localPlayerId];
                             UI.updateHUD(player, appState.serverState);
                             UI.updateCountdown(appState.serverState);
                             UI.updateDayNight(appState.serverState);
                        }
                         // Update waiting message player count even if status didn't change
                         else if (appState.serverState.status === 'waiting' && appState.mode === 'multiplayer-host') {
                             const playerCount = Object.keys(appState.serverState.players || {}).length;
                             DOM.waitingMessage.textContent = `Waiting for Team Mate... (${playerCount}/${MAX_PLAYERS})`;
                         }


                        if (appState.serverState.game_over && !wasGameOver) {
                            log("Game Over signal received from server.");
                            // Loop should stop itself, then show screen
                            // UI.showGameOver is called inside gameLoop's stop condition check
                        }
                        break;

                    case 'chat_message':
                        UI.addChatMessage(data.sender_id, data.message, data.sender_id === appState.localPlayerId);
                        break;

                    case 'error':
                        console.error("[Client] Server Error Message:", data.message);
                        UI.updateStatus(`Server Error: ${data.message}`, true);

                        // Add specific handling for join errors to stay on join screen
                        if (appState.mode === 'multiplayer-client' && (data.message.includes('not found') || data.message.includes('not waiting') || data.message.includes('full') || data.message.includes('finished'))) {
                            UI.showSection('join-code-section');
                            appState.mode = 'menu'; // Reset internal mode state
                            // No full resetClientState, just update status and stay on screen
                        } else if (appState.mode === 'multiplayer-host' && data.message.includes('Creation Error')) {
                            Game.resetClientState(true); // Back to main menu
                        } else if (data.message === 'Please create or join a game first.') {
                             log("Received 'join first' error unexpectedly, resetting state.");
                             Game.resetClientState(true);
                        }
                        // Other errors just display the message
                        break;

                    default:
                        log('Unknown message type received:', data.type);
                }
            } catch (handlerError) {
                console.error("[Client] Error inside handleServerMessage logic:", handlerError);
                UI.updateStatus("Client error processing message.", true);
            }
        }


        // --- Global Init ---
        // Wrapper for inline HTML button compatibility
        function showSection(sectionId) { UI.showSection(sectionId); }

        window.onload = () => {
            log("Window loaded.");
            log("Window loaded.");
            UI.updateStatus("Initializing...");

            // Define appState *before* initializing modules that might use it
             // --- Global Client State --- <<< IMPORTANT PLACEMENT
             appState = { // Use global scope assignment since it's used everywhere
                 mode: 'menu',
                 localPlayerId: null,
                 currentGameId: null,
                 serverState: null,
                 animationFrameId: null,
                 isConnected: false,
                 renderedPlayerPos: { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 },
                 predictedPlayerPos: { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 },
                 lastServerState: null,
                 previousServerState: null,
                 lastLoopTime: null, // Initialize as null
             };
             socket = null; // Also define socket globally

            // Now safe to initialize listeners and connect
            try {
                 Game.initListeners();
                 Network.connect(() => {
                     // This callback runs *after* WebSocket opens
                     UI.updateStatus("Connected. Select Mode.");
                     // Show main menu only *after* connection is confirmed open
                     UI.showSection('main-menu-section');
                 });
                 UI.updateStatus("Connecting..."); // Initial status while connecting
            } catch (initError) {
                 console.error("Initialization failed:", initError);
                 UI.updateStatus("Error initializing game. Please refresh.", true);
            }
        };

    </script>
</body>
</html>

import * as THREE from 'three';
import Renderer3D from './Renderer3D.js';

console.log("--- main.js (Corrected Original): Initializing ---");

const WEBSOCKET_URL = 'wss://such-is-life.glitch.me/ws';
const SHOOT_COOLDOWN = 750;
const RAPID_FIRE_COOLDOWN_MULTIPLIER = 0.4;
const INPUT_SEND_INTERVAL = 33;
const RECONNECT_DELAY = 3000;
const PLAYER_DEFAULTS = { width: 25, height: 48, max_health: 100, base_speed: 150 };
const PLAYER_STATUS_ALIVE = 'alive';
const PLAYER_STATUS_DOWN = 'down';
const PLAYER_STATUS_DEAD = 'dead';
const DEFAULT_CANVAS_WIDTH = 1600; // Match original default
const DEFAULT_CANVAS_HEIGHT = 900; // Match original default
const INTERPOLATION_BUFFER_MS = 100;
const SPEECH_BUBBLE_DURATION_MS = 4000;
const ENEMY_SPEECH_BUBBLE_DURATION_MS = 3000;
const PUSHBACK_ANIM_DURATION = 250;
const MUZZLE_FLASH_DURATION = 75;
const CASING_LIFETIME_BASE_MS = 500;
const CASING_LIFETIME_RANDOM_MS = 300;
const MAX_CASED_AMMO = 50;
const SPARK_DURATION_MS = 300;

function getCssVar(varName) { return getComputedStyle(document.documentElement).getPropertyValue(varName).trim() || ''; }
function lerp(start, end, amount) { return start + (end - start) * amount; }
function distance(x1, y1, x2, y2) { const dx = x1 - x2; const dy = y1 - y2; return Math.sqrt(dx * dx + dy * dy); }

const DOM = {
    loadingScreen: document.getElementById('loading-screen'),
    gameContainer: document.getElementById('game-container'),
    topBar: document.getElementById('top-bar'),
    gameStatus: document.getElementById('game-status'),
    menuContainer: document.getElementById('menu-container'), // Container for menus
    mainMenuSection: document.getElementById('main-menu-section'),
    multiplayerMenuSection: document.getElementById('multiplayer-menu-section'),
    hostWaitSection: document.getElementById('host-wait-section'),
    joinCodeSection: document.getElementById('join-code-section'),
    gameArea: document.getElementById('game-area'), // Container for panel + canvas
    leftPanel: document.getElementById('left-panel'),
    playerStatsGrid: document.getElementById('player-stats-grid'),
    dayNightIndicator: document.getElementById('day-night-indicator'),
    temperatureIndicator: document.getElementById('temperature-indicator'),
    chatLog: document.getElementById('chat-log'),
    chatInput: document.getElementById('chatInput'),
    sendChatBtn: document.getElementById('sendChatBtn'),
    muteBtn: document.getElementById('muteBtn'),
    leaveGameBtn: document.getElementById('leaveGameBtn'),
    canvasContainer: document.getElementById('canvas-container'), // Wrapper div for canvas
    countdownDiv: document.getElementById('countdown'),
    htmlOverlay: document.getElementById('html-overlay'),
    gameOverScreen: document.getElementById('game-over-screen'),
    finalStatsDiv: document.getElementById('final-stats'), // Renamed for consistency
    singlePlayerBtn: document.getElementById('singlePlayerBtn'),
    multiplayerBtn: document.getElementById('multiplayerBtn'),
    hostGameBtn2: document.getElementById('hostGameBtn2'),
    hostGameBtn3: document.getElementById('hostGameBtn3'),
    hostGameBtn4: document.getElementById('hostGameBtn4'),
    showJoinUIBtn: document.getElementById('showJoinUIBtn'),
    cancelHostBtn: document.getElementById('cancelHostBtn'),
    gameCodeDisplay: document.getElementById('game-code-display'),
    waitingMessage: document.getElementById('waiting-message'),
    gameIdInput: document.getElementById('gameIdInput'),
    joinGameSubmitBtn: document.getElementById('joinGameSubmitBtn'),
    gameOverBackBtn: document.getElementById('gameOverBackBtn'),
};

let appState = {
    mode: 'menu', localPlayerId: null, currentGameId: null, maxPlayersInGame: null,
    serverState: null, lastServerState: null, lastStateReceiveTime: performance.now(),
    animationFrameId: null, isConnected: false, isGameLoopRunning: false,
    renderedPlayerPos: { x: DEFAULT_CANVAS_WIDTH / 2, y: DEFAULT_CANVAS_HEIGHT / 2 },
    predictedPlayerPos: { x: DEFAULT_CANVAS_WIDTH / 2, y: DEFAULT_CANVAS_HEIGHT / 2 },
    canvasWidth: DEFAULT_CANVAS_WIDTH, canvasHeight: DEFAULT_CANVAS_HEIGHT,
    mouseWorldPosition: new THREE.Vector3(0, 0, 0),
    localPlayerAimState: { lastAimDx: 0, lastAimDy: -1 },
    uiPositions: {}, currentTemp: 18.0, isRaining: false, isDustStorm: false, isNight: false,
};

let localPlayerMuzzleFlash = { active: false, endTime: 0, aimDx: 0, aimDy: 0 };
let localPlayerPushbackAnim = { active: false, endTime: 0, duration: PUSHBACK_ANIM_DURATION };
let activeSpeechBubbles = {};
let activeEnemyBubbles = {};
let activeAmmoCasings = [];
let activeBloodSparkEffects = {};
let snake = { isActiveFromServer: false, segments: [], serverHeadX: 0, serverHeadY: 0, serverBaseY: 0, update: function() { if (!this.isActiveFromServer) this.segments = []; } };
let localEffects = { muzzleFlash: localPlayerMuzzleFlash, pushbackAnim: localPlayerPushbackAnim, activeBloodSparkEffects: activeBloodSparkEffects, activeAmmoCasings: activeAmmoCasings, snake: snake };

const damageTextPool = { elements: {}, inactive: [] };
const healthBarPool = { elements: {}, inactive: [] };
const speechBubblePool = { elements: {}, inactive: [] };

let socket = null;
let reconnectTimer = null;
let lastLoopTime = null;

function log(...args) { console.log("[Client]", ...args); }
function error(...args) { console.error("[Client]", ...args); }

const SoundManager = (() => {
    let audioContext = null; let loadedSounds = {}; let soundFiles = { 'shoot': 'assets/sounds/shoot.mp3', 'damage': 'assets/sounds/damage.mp3' };
    let soundsLoading = 0; let soundsLoaded = 0; let isInitialized = false; let canPlaySound = false; let isMuted = false;
    function init() { if (isInitialized) return canPlaySound; isInitialized = true; try { const AC = window.AudioContext || window.webkitAudioContext; if (!AC) return false; audioContext = new AC(); const r = () => { audioContext.resume().then(() => { log("[SM] Audio Resumed."); canPlaySound = true; loadSounds(); }).catch(e => error("[SM] Resume failed:", e)); document.removeEventListener('click', r); document.removeEventListener('keydown', r); }; if (audioContext.state === 'suspended') { document.addEventListener('click', r, { once: true }); document.addEventListener('keydown', r, { once: true }); } else if (audioContext.state === 'running') { canPlaySound = true; loadSounds(); } } catch (e) { error("[SM] Init error:", e); return false; } return canPlaySound; }
    function loadSounds() { if (!audioContext || !canPlaySound) return; soundsLoading = Object.keys(soundFiles).length; soundsLoaded = 0; loadedSounds = {}; log(`[SM] Loading ${soundsLoading} sounds...`); Object.entries(soundFiles).forEach(([n, p]) => { fetch(p).then(r => r.ok ? r.arrayBuffer() : Promise.reject(`HTTP ${r.status}`)).then(b => audioContext.decodeAudioData(b)).then(db => { loadedSounds[n] = db; soundsLoaded++; if (soundsLoaded === soundsLoading) log("[SM] Sounds loaded."); }).catch(e => { error(`[SM] Load/Decode '${n}' error:`, e); soundsLoaded++; if (soundsLoaded === soundsLoading) log("[SM] Sound loading ended (errors)."); }); }); }
    function playSound(name, volume = 1.0) { if (isMuted || !canPlaySound || !audioContext || audioContext.state !== 'running') return; const b = loadedSounds[name]; if (!b) return; try { const s = audioContext.createBufferSource(); s.buffer = b; const g = audioContext.createGain(); g.gain.setValueAtTime(Math.max(0, Math.min(1, volume)), audioContext.currentTime); s.connect(g).connect(audioContext.destination); s.start(0); s.onended = () => { try { s.disconnect(); g.disconnect(); } catch(e){} }; } catch (e) { error(`[SM] Play '${name}' error:`, e); } }
    function toggleMute() { isMuted = !isMuted; log(`[SM] Sound ${isMuted ? 'Muted' : 'Unmuted'}`); if (DOM.muteBtn) { DOM.muteBtn.textContent = isMuted ? 'Unmute' : 'Mute'; DOM.muteBtn.classList.toggle('muted', isMuted); } return isMuted; }
    function getMuteState() { return isMuted; }
    return { init, playSound, toggleMute, getMuteState };
})();

const UIManager = (() => {
    const allMenuSections = [DOM.mainMenuSection, DOM.multiplayerMenuSection, DOM.hostWaitSection, DOM.joinCodeSection];
    function showSection(sectionId) {
        allMenuSections.forEach(s => s?.classList.remove('active'));
        DOM.gameArea?.classList.remove('active');
        DOM.gameOverScreen?.classList.remove('active');
        DOM.menuContainer?.classList.remove('active'); // Hide menu container explicitly

        const sectionToShow = document.getElementById(sectionId);
        if (sectionToShow) {
            sectionToShow.classList.add('active');
            log(`UI: Showing section: ${sectionId}`);
            if (sectionToShow.closest('#menu-container')) {
                 DOM.menuContainer?.classList.add('active'); // Show menu container
            } else if (sectionToShow === DOM.gameArea) {
                 DOM.gameArea?.classList.add('active'); // Show game area
            } else if (sectionToShow === DOM.gameOverScreen) {
                 DOM.gameOverScreen?.classList.add('active'); // Show game over
            }
        } else { error(`UI: Section not found: ${sectionId}`); }
    }
    function updateStatus(message, isError = false) { if (!DOM.gameStatus) return; DOM.gameStatus.textContent = message; DOM.gameStatus.style.color = isError ? (getCssVar('--color-danger') || 'red') : (getCssVar('--color-accent') || 'yellow'); }
    function updateHUD(serverState) { if (!DOM.playerStatsGrid) return; const players = serverState?.players; const localId = appState.localPlayerId; DOM.playerStatsGrid.innerHTML = ''; if (!players || Object.keys(players).length === 0) { DOM.playerStatsGrid.innerHTML = '<div class="stats-box placeholder">Waiting...</div>'; return; } const sortedPlayerIds = Object.keys(players).sort((a, b) => { if (a === localId) return -1; if (b === localId) return 1; return a.localeCompare(b); }); sortedPlayerIds.forEach(pId => { const pData = players[pId]; if (!pData) return; const isSelf = (pId === localId); const header = isSelf ? "YOU" : `P:${pId.substring(0, 4)}`; const status = pData.player_status || PLAYER_STATUS_ALIVE; const health = pData.health ?? 0; const armor = pData.armor ?? 0; let healthDisplay; if (status === PLAYER_STATUS_DOWN) healthDisplay = `<span style='color: var(--color-health-medium);'>DOWN</span>`; else if (status === PLAYER_STATUS_DEAD || health <= 0) healthDisplay = `<span style='color: var(--color-health-low);'>DEAD</span>`; else healthDisplay = `${health.toFixed(1)}`; const box = document.createElement('div'); box.className = 'stats-box'; box.innerHTML = `<div class="stats-header">${header}</div><div class="stats-content"><span>HP:</span> ${healthDisplay}<br><span>Armor:</span> ${Math.round(armor)}<br><span>Gun:</span> ${pData.gun ?? 1}<br><span>Speed:</span> ${pData.speed ?? PLAYER_DEFAULTS.base_speed}<br><span>Kills:</span> ${pData.kills ?? 0}<br><span>Score:</span> ${pData.score ?? 0}</div>`; DOM.playerStatsGrid.appendChild(box); }); }
    function addChatMessage(sender, message, isSelf, isSystem = false) { if (!DOM.chatLog) return; const div = document.createElement('div'); div.classList.add(isSystem ? 'system-message' : (isSelf ? 'my-message' : 'other-message')); div.textContent = isSystem ? message : `${sender ? `P:${sender.substring(0,4)}` : '???'}: ${message}`; DOM.chatLog.appendChild(div); DOM.chatLog.scrollTop = DOM.chatLog.scrollHeight; }
    function updateCountdown(serverState) { if (!DOM.countdownDiv) return; const isCountdown = serverState?.status === 'countdown' && serverState?.countdown >= 0; if (isCountdown) { DOM.countdownDiv.textContent = Math.ceil(serverState.countdown); DOM.countdownDiv.classList.add('active'); } else { DOM.countdownDiv.classList.remove('active'); } }
    function updateDayNight(serverState) { if (!DOM.dayNightIndicator || !DOM.gameContainer) return; if (serverState?.status === 'active') { const isNight = serverState.is_night; appState.isNight = isNight; DOM.dayNightIndicator.textContent = isNight ? 'Night' : 'Day'; DOM.dayNightIndicator.style.display = 'block'; DOM.gameContainer.classList.toggle('night-mode', isNight); } else { DOM.dayNightIndicator.style.display = 'none'; DOM.gameContainer.classList.remove('night-mode'); appState.isNight = false; } }
    function updateEnvironmentDisplay(serverState) { if (!DOM.temperatureIndicator) return; if (serverState?.status === 'active') { appState.currentTemp = serverState.current_temperature ?? 18.0; appState.isRaining = serverState.is_raining ?? false; appState.isDustStorm = serverState.is_dust_storm ?? false; DOM.temperatureIndicator.textContent = `${appState.currentTemp.toFixed(0)}Â°C`; DOM.temperatureIndicator.style.display = 'block'; } else { DOM.temperatureIndicator.style.display = 'none'; } }
    function showGameOver(finalState) { if (!DOM.finalStatsDiv || !DOM.gameOverScreen) return; const player = finalState?.players?.[appState.localPlayerId]; let statsHtml = "Stats Unavailable"; if (player) { statsHtml = `<div class="final-stat-item"><strong>Score:</strong> ${player.score ?? 0}</div><div class="final-stat-item"><strong>Kills:</strong> ${player.kills ?? 0}</div>`; } DOM.finalStatsDiv.innerHTML = statsHtml; log("UI: Showing game over screen."); showSection('game-over-screen'); }
    return { showSection, updateStatus, updateHUD, addChatMessage, updateCountdown, updateDayNight, updateEnvironmentDisplay, showGameOver };
})();

const NetworkManager = (() => {
    function connect(onOpenCallback) { if (socket && socket.readyState !== WebSocket.CLOSED) { if (socket.readyState === WebSocket.OPEN && onOpenCallback) onOpenCallback(); return; } clearTimeout(reconnectTimer); UIManager.updateStatus('Connecting...'); log("WS connect:", WEBSOCKET_URL); try { socket = new WebSocket(WEBSOCKET_URL); } catch (err) { error("WS creation failed:", err); UIManager.updateStatus('Connection failed.', true); return; } socket.onopen = () => { log('WS open.'); appState.isConnected = true; DOM.loadingScreen?.classList.remove('active'); DOM.gameContainer?.classList.add('loaded'); UIManager.updateStatus('Connected.'); UIManager.showSection('main-menu-section'); if (onOpenCallback) onOpenCallback(); }; socket.onmessage = handleServerMessage; socket.onerror = (event) => { error('WS Error:', event); }; socket.onclose = (event) => { error(`WS Closed: Code=${event.code}, Reason='${event.reason || 'N/A'}'`); const wasConnected = appState.isConnected; appState.isConnected = false; socket = null; GameManager.resetClientState(false); if (event.code === 1000) { UIManager.updateStatus('Disconnected.'); UIManager.showSection('main-menu-section'); } else if (wasConnected) { UIManager.updateStatus('Connection lost. Reconnecting...', true); scheduleReconnect(); } else { UIManager.updateStatus('Connection failed.', true); UIManager.showSection('main-menu-section'); } GameManager.cleanupLoop(); }; }
    function scheduleReconnect() { clearTimeout(reconnectTimer); log(`Reconnect attempt in ${RECONNECT_DELAY}ms`); reconnectTimer = setTimeout(() => { log("Attempting reconnect..."); connect(() => { UIManager.updateStatus('Reconnected.'); GameManager.resetClientState(true); }); }, RECONNECT_DELAY); }
    function sendMessage(payload) { if (socket && socket.readyState === WebSocket.OPEN) { try { socket.send(JSON.stringify(payload)); } catch (err) { error("Send error:", err, payload); } } }
    function closeConnection(code = 1000, reason = "User action") { clearTimeout(reconnectTimer); if (socket && socket.readyState === WebSocket.OPEN) { log(`Closing WS connection: ${reason} (${code})`); socket.close(code, reason); } socket = null; appState.isConnected = false; }
    return { connect, sendMessage, closeConnection };
})();

const InputManager = (() => {
    let keys = {}; let lastShotTime = 0; let inputInterval = null; let mouseScreenPos = { x: 0, y: 0 }; let isMouseDown = false; const raycaster = new THREE.Raycaster(); const mouseNDC = new THREE.Vector2();
    function preventContextMenu(event) { if (DOM.canvasContainer?.contains(event.target)) event.preventDefault(); }
    function setup() { cleanup(); log("Input: Setting up..."); document.addEventListener('keydown', handleKeyDown); document.addEventListener('keyup', handleKeyUp); DOM.chatInput?.addEventListener('keydown', handleChatEnter); DOM.canvasContainer?.addEventListener('mousemove', handleMouseMove); DOM.canvasContainer?.addEventListener('mousedown', handleMouseDown); DOM.canvasContainer?.addEventListener('contextmenu', preventContextMenu); document.addEventListener('mouseup', handleMouseUp); inputInterval = setInterval(sendMovementInput, INPUT_SEND_INTERVAL); }
    function cleanup() { log("Input: Cleaning up..."); document.removeEventListener('keydown', handleKeyDown); document.removeEventListener('keyup', handleKeyUp); DOM.chatInput?.removeEventListener('keydown', handleChatEnter); DOM.canvasContainer?.removeEventListener('mousemove', handleMouseMove); DOM.canvasContainer?.removeEventListener('mousedown', handleMouseDown); DOM.canvasContainer?.removeEventListener('contextmenu', preventContextMenu); document.removeEventListener('mouseup', handleMouseUp); clearInterval(inputInterval); inputInterval = null; keys = {}; isMouseDown = false; mouseScreenPos = { x: 0, y: 0 }; }
    function handleMouseMove(event) { if (!DOM.canvasContainer || typeof Renderer3D === 'undefined' || !Renderer3D.getCamera || !Renderer3D.getGroundPlane || !appState.isGameLoopRunning) return; const rect = DOM.canvasContainer.getBoundingClientRect(); const canvasX = event.clientX - rect.left; const canvasY = event.clientY - rect.top; mouseScreenPos.x = canvasX; mouseScreenPos.y = canvasY; mouseNDC.x = (canvasX / rect.width) * 2 - 1; mouseNDC.y = -(canvasY / rect.height) * 2 + 1; const camera = Renderer3D.getCamera(); const groundPlane = Renderer3D.getGroundPlane(); if (camera && groundPlane) { try { raycaster.setFromCamera(mouseNDC, camera); const intersects = raycaster.intersectObject(groundPlane); if (intersects.length > 0) appState.mouseWorldPosition.copy(intersects[0].point); } catch (e) { error("Input: Raycasting error:", e); } } }
    function handleMouseDown(event) { if (document.activeElement === DOM.chatInput) return; if (event.button === 0) { isMouseDown = true; event.preventDefault(); } else if (event.button === 2) { event.preventDefault(); if (appState.serverState?.status === 'active' && appState.isConnected) GameManager.triggerLocalPushback(); } }
    function handleMouseUp(event) { if (event.button === 0) isMouseDown = false; }
    function handleKeyDown(event) { if (document.activeElement === DOM.chatInput) return; const key = event.key.toLowerCase(); if (['w', 'a', 's', 'd', 'arrowup', 'arrowdown', 'arrowleft', 'arrowright', ' '].includes(key)) { if (!keys[key]) keys[key] = true; event.preventDefault(); } if (key === 'e') { if (appState.serverState?.status === 'active' && appState.isConnected) { GameManager.triggerLocalPushback(); event.preventDefault(); } } }
    function handleKeyUp(event) { const key = event.key.toLowerCase(); if (['w', 'a', 's', 'd', 'arrowup', 'arrowdown', 'arrowleft', 'arrowright', ' '].includes(key)) keys[key] = false; }
    function handleChatEnter(event) { if (event.key === 'Enter') { event.preventDefault(); GameManager.sendChatMessage(); } }
    function getMovementInputVector() { let dx = 0, dy = 0; if (keys['w'] || keys['arrowup']) dy -= 1; if (keys['s'] || keys['arrowdown']) dy += 1; if (keys['a'] || keys['arrowleft']) dx -= 1; if (keys['d'] || keys['arrowright']) dx += 1; if (dx !== 0 && dy !== 0) { const factor = 1 / Math.sqrt(2); dx *= factor; dy *= factor; } return { dx, dy }; }
    function sendMovementInput() { if (appState.mode !== 'menu' && appState.serverState?.status === 'active' && appState.isConnected) NetworkManager.sendMessage({ type: 'player_move', direction: getMovementInputVector() }); }
    function isShootHeld() { return keys[' '] || isMouseDown; }
    function handleShooting() { if (appState.serverState?.status !== 'active') return; const playerState = appState.serverState?.players?.[appState.localPlayerId]; if (!playerState || playerState.player_status !== PLAYER_STATUS_ALIVE) return; const nowTimestamp = Date.now(); const currentAmmo = playerState?.active_ammo_type || 'standard'; const isRapidFire = currentAmmo === 'ammo_rapid_fire'; const cooldownMultiplier = isRapidFire ? RAPID_FIRE_COOLDOWN_MULTIPLIER : 1.0; const actualCooldown = SHOOT_COOLDOWN * cooldownMultiplier; if (nowTimestamp - lastShotTime < actualCooldown) return; lastShotTime = nowTimestamp; const playerRenderX = appState.renderedPlayerPos.x; const playerRenderZ = appState.renderedPlayerPos.y; let aimDx = 0, aimDy = -1; const targetWorldPos = appState.mouseWorldPosition; if (targetWorldPos && typeof playerRenderX === 'number' && typeof playerRenderZ === 'number') { aimDx = targetWorldPos.x - playerRenderX; aimDy = targetWorldPos.z - playerRenderZ; const magSq = aimDx * aimDx + aimDy * aimDy; if (magSq > 0.01) { const mag = Math.sqrt(magSq); aimDx /= mag; aimDy /= mag; } else { aimDx = 0; aimDy = -1; } } appState.localPlayerAimState.lastAimDx = aimDx; appState.localPlayerAimState.lastAimDy = aimDy; const nowPerf = performance.now(); localPlayerMuzzleFlash.active = true; localPlayerMuzzleFlash.endTime = nowPerf + MUZZLE_FLASH_DURATION; localPlayerMuzzleFlash.aimDx = aimDx; localPlayerMuzzleFlash.aimDy = aimDy; SoundManager.playSound('shoot'); GameManager.spawnLocalAmmoCasing(playerRenderX, playerRenderZ, aimDx, aimDy); NetworkManager.sendMessage({ type: 'player_shoot', target: { x: targetWorldPos.x, y: targetWorldPos.z } }); }
    return { setup, cleanup, isShootHeld, handleShooting, getMovementInputVector }; // Export getMovementInputVector
})();

const GameManager = (() => {
    function initListeners() { log("Game: Initializing listeners..."); DOM.singlePlayerBtn?.addEventListener('click', () => { SoundManager.init(); startSinglePlayer(); }); DOM.multiplayerBtn?.addEventListener('click', () => UIManager.showSection('multiplayer-menu-section')); const hostHandler = (maxP) => { SoundManager.init(); hostMultiplayer(maxP); }; DOM.hostGameBtn2?.addEventListener('click', () => hostHandler(2)); DOM.hostGameBtn3?.addEventListener('click', () => hostHandler(3)); DOM.hostGameBtn4?.addEventListener('click', () => hostHandler(4)); DOM.showJoinUIBtn?.addEventListener('click', () => UIManager.showSection('join-code-section')); DOM.joinGameSubmitBtn?.addEventListener('click', () => { SoundManager.init(); joinMultiplayer(); }); DOM.cancelHostBtn?.addEventListener('click', leaveGame); DOM.sendChatBtn?.addEventListener('click', sendChatMessage); DOM.leaveGameBtn?.addEventListener('click', leaveGame); DOM.gameOverBackBtn?.addEventListener('click', () => resetClientState(true)); DOM.muteBtn?.addEventListener('click', SoundManager.toggleMute); if(DOM.muteBtn) { DOM.muteBtn.textContent = SoundManager.getMuteState() ? 'Unmute' : 'Mute'; DOM.muteBtn.classList.toggle('muted', SoundManager.getMuteState()); } document.querySelectorAll('.back-button').forEach(btn => { const targetId = btn.dataset.target; if (targetId && document.getElementById(targetId)) { btn.addEventListener('click', (e) => { e.preventDefault(); UIManager.showSection(targetId); }); } else { log(`Warn: Back button missing/invalid target: ${targetId}`, btn); } }); log("Game: Listeners initialized."); }
    function startSinglePlayer() { log("Requesting Single Player game..."); appState.mode = 'singleplayer'; UIManager.updateStatus("Starting Single Player..."); NetworkManager.sendMessage({ type: 'start_single_player' }); }
    function joinMultiplayer() { const gameId = DOM.gameIdInput?.value.trim().toUpperCase(); if (!gameId || gameId.length !== 6) { UIManager.updateStatus('Invalid Game ID (6 chars).', true); return; } log(`Joining MP game: ${gameId}`); appState.mode = 'multiplayer-client'; UIManager.updateStatus(`Joining game ${gameId}...`); NetworkManager.sendMessage({ type: 'join_game', game_id: gameId }); }
    function hostMultiplayer(maxPlayers) { log(`Hosting MP game (${maxPlayers}p)...`); if (![2, 3, 4].includes(maxPlayers)) { error("Invalid max players:", maxPlayers); UIManager.updateStatus("Invalid player count.", true); return; } appState.mode = 'multiplayer-host'; UIManager.updateStatus(`Creating ${maxPlayers}p game...`); NetworkManager.sendMessage({ type: 'create_game', max_players: maxPlayers }); }
    function leaveGame() { log("Leaving game..."); if (appState.isConnected && appState.currentGameId && appState.localPlayerId) NetworkManager.sendMessage({ type: 'leave_game' }); resetClientState(true); }
    function sendChatMessage() { const message = DOM.chatInput?.value.trim(); if (message && appState.isConnected && appState.currentGameId && appState.localPlayerId) { NetworkManager.sendMessage({ type: 'player_chat', message: message }); if(DOM.chatInput) DOM.chatInput.value = ''; } }
    function triggerLocalPushback() { localPlayerPushbackAnim.active = true; localPlayerPushbackAnim.endTime = performance.now() + localPlayerPushbackAnim.duration; log("Input: Local pushback triggered."); NetworkManager.sendMessage({ type: 'player_pushback' }); }
    function spawnLocalAmmoCasing(playerX, playerZ, aimDx, aimDy) { if (!Array.isArray(activeAmmoCasings)) activeAmmoCasings = []; if (activeAmmoCasings.length >= MAX_CASED_AMMO) activeAmmoCasings.shift(); const nowPerf = performance.now(); const casingLifetime = CASING_LIFETIME_BASE_MS + Math.random() * CASING_LIFETIME_RANDOM_MS; const ejectAngleOffset = Math.PI / 2 + (Math.random() - 0.5) * 0.4; const ejectAngle = Math.atan2(aimDy, aimDx) + ejectAngleOffset; const ejectSpeed = 80 + Math.random() * 40; const gravity = 150; const casing = { id: `casing_${nowPerf}_${Math.random().toString(16).slice(2)}`, x: playerX + Math.cos(ejectAngle) * 15, y: playerZ + Math.sin(ejectAngle) * 15, vx: Math.cos(ejectAngle) * ejectSpeed, vy: Math.sin(ejectAngle) * ejectSpeed - 40, rotation: Math.random() * Math.PI * 2, rotationSpeed: (Math.random() - 0.5) * 10, spawnTime: nowPerf, lifetime: casingLifetime, gravity: gravity, width: 6, height: 3, color: "rgba(218, 165, 32, 0.9)" }; activeAmmoCasings.push(casing); }
    function resetClientState(showMenu = true) {
        log(`Resetting client state. Show Menu: ${showMenu}`); cleanupLoop();
        if (DOM.htmlOverlay) DOM.htmlOverlay.innerHTML = '';
        Object.keys(damageTextPool.elements).forEach(id => delete damageTextPool.elements[id]); damageTextPool.inactive.length = 0;
        Object.keys(healthBarPool.elements).forEach(id => delete healthBarPool.elements[id]); healthBarPool.inactive.length = 0;
        Object.keys(speechBubblePool.elements).forEach(id => delete speechBubblePool.elements[id]); speechBubblePool.inactive.length = 0;
        if (typeof Renderer3D !== 'undefined' && Renderer3D.cleanup) Renderer3D.cleanup();
        const currentIsConnected = appState.isConnected; const currentW = appState.canvasWidth; const currentH = appState.canvasHeight;
        appState = { mode: 'menu', localPlayerId: null, currentGameId: null, maxPlayersInGame: null, serverState: null, lastServerState: null, animationFrameId: null, isConnected: currentIsConnected, isGameLoopRunning: false, renderedPlayerPos: { x: currentW / 2, y: currentH / 2 }, predictedPlayerPos: { x: currentW / 2, y: currentH / 2 }, lastStateReceiveTime: performance.now(), canvasWidth: currentW, canvasHeight: currentH, mouseWorldPosition: new THREE.Vector3(0,0,0), localPlayerAimState: { lastAimDx: 0, lastAimDy: -1 }, uiPositions: {}, currentTemp: 18.0, isRaining: false, isDustStorm: false, isNight: false, };
        localPlayerMuzzleFlash = { active: false, endTime: 0, aimDx: 0, aimDy: 0 }; localPlayerPushbackAnim = { active: false, endTime: 0, duration: PUSHBACK_ANIM_DURATION }; activeSpeechBubbles = {}; activeEnemyBubbles = {}; activeAmmoCasings = []; activeBloodSparkEffects = {}; if(typeof snake !== 'undefined'){ snake.isActiveFromServer = false; snake.segments = []; }
        DOM.chatLog.innerHTML = ''; DOM.gameCodeDisplay.textContent = '------'; DOM.gameIdInput.value = ''; DOM.countdownDiv?.classList.remove('active'); DOM.dayNightIndicator.style.display = 'none'; DOM.temperatureIndicator.style.display = 'none'; DOM.playerStatsGrid.innerHTML = '<div class="stats-box placeholder">Loading Stats...</div>';
        if (showMenu) { appState.mode = 'menu'; UIManager.updateStatus(appState.isConnected ? "Connected." : "Disconnected."); UIManager.showSection('main-menu-section'); }
    }
    function updateHtmlOverlays(stateToRender) {
        if (!DOM.htmlOverlay || !stateToRender || !appState.uiPositions) return; const overlay = DOM.htmlOverlay; const now = performance.now();
        const getElement = (pool, id, className, parent) => { let el = pool.elements[id]; if (!el) { el = pool.inactive.pop(); if (!el) { el = document.createElement('div'); el.className = className; parent.appendChild(el); } else { el.style.display = 'block'; } pool.elements[id] = el; } return el; };
        const releaseElement = (pool, id) => { const el = pool.elements[id]; if (el) { el.style.display = 'none'; pool.inactive.push(el); delete pool.elements[id]; } };
        const players = stateToRender.players || {}; const enemies = stateToRender.enemies || {}; const damageTexts = stateToRender.damage_texts || {}; const allBubbles = { ...activeSpeechBubbles, ...activeEnemyBubbles };
        const activeDamageIds = new Set(Object.keys(damageTexts)); const activeHealthBarIds = new Set(); const activeBubbleIds = new Set();
        for (const id in allBubbles) { if (now < allBubbles[id].endTime) activeBubbleIds.add(id); }
        for (const id in damageTexts) { const dtData = damageTexts[id]; const posData = appState.uiPositions[id]; if (!posData) continue; const element = getElement(damageTextPool, id, 'overlay-element damage-text-overlay', overlay); element.textContent = dtData.text; element.classList.toggle('crit', dtData.is_crit || false); const lifeTime = (dtData.lifetime || 0.75) * 1000; const spawnTime = dtData.spawn_time * 1000; const timeElapsed = now - spawnTime; const lifeProgress = Math.min(1, timeElapsed / lifeTime); const verticalOffset = -(lifeProgress * 50); element.style.left = `${posData.screenX}px`; element.style.top = `${posData.screenY + verticalOffset}px`; element.style.opacity = Math.max(0, 1.0 - (lifeProgress * 0.8)).toFixed(2); }
        for (const id in damageTextPool.elements) { if (!activeDamageIds.has(id)) releaseElement(damageTextPool, id); }
        const healthBarOffsetY = -35; const healthBarHeight = 7; const armorBarHeight = 4; const barSpacing = 2; const healthBarWidthFactor = 0.8; const minBarWidth = 30; const healthBarHighColor = getCssVar('--color-health-high'); const healthBarMediumColor = getCssVar('--color-health-medium'); const healthBarLowColor = getCssVar('--color-health-low'); const armorBarColor = getCssVar('--color-armor');
        const processEntityForHealthBar = (id, entityData) => { if (!entityData || entityData.health <= 0 || entityData.player_status === PLAYER_STATUS_DOWN || entityData.player_status === PLAYER_STATUS_DEAD) return; const posData = appState.uiPositions[id]; if (!posData) return; activeHealthBarIds.add(id); const entityWidth = entityData.width || (id in players ? PLAYER_DEFAULTS.width : 20); const barWidth = Math.max(minBarWidth, entityWidth * healthBarWidthFactor); const maxHealth = entityData.max_health || 100; const healthPercent = Math.max(0, Math.min(1, entityData.health / maxHealth)); const currentHealthWidth = barWidth * healthPercent; const armorPercent = Math.max(0, Math.min(1, (entityData.armor || 0) / 100)); const currentArmorWidth = barWidth * armorPercent; const showArmor = entityData.armor > 0; const barContainer = getElement(healthBarPool, id, 'overlay-element health-bar-container', overlay); if (barContainer.children.length === 0) { barContainer.innerHTML = `<div class="health-bar-bg" style="height: ${healthBarHeight}px;"><div class="health-bar-fg" style="height: ${healthBarHeight}px;"></div></div><div class="armor-bar-bg" style="height: ${armorBarHeight}px; top: ${healthBarHeight + barSpacing}px;"><div class="armor-bar-fg" style="height: ${armorBarHeight}px; top: 0; left: 0;"></div></div>`; barContainer.style.transform = 'translateX(-50%)'; } barContainer.style.left = `${posData.screenX}px`; barContainer.style.top = `${posData.screenY + healthBarOffsetY}px`; barContainer.style.width = `${barWidth}px`; const healthBgEl = barContainer.children[0]; const healthFgEl = healthBgEl.children[0]; const armorBgEl = barContainer.children[1]; const armorFgEl = armorBgEl.children[0]; healthBgEl.style.width = `${barWidth}px`; healthFgEl.style.width = `${currentHealthWidth}px`; if (healthPercent > 0.66) healthFgEl.style.backgroundColor = healthBarHighColor; else if (healthPercent > 0.33) healthFgEl.style.backgroundColor = healthBarMediumColor; else healthFgEl.style.backgroundColor = healthBarLowColor; const armorVisible = showArmor; armorBgEl.style.display = armorVisible ? 'block' : 'none'; if (armorVisible) { armorBgEl.style.width = `${barWidth}px`; armorFgEl.style.width = `${currentArmorWidth}px`; } };
        Object.entries(players).forEach(([id, data]) => processEntityForHealthBar(id, data)); Object.entries(enemies).forEach(([id, data]) => processEntityForHealthBar(id, data));
        for (const id in healthBarPool.elements) { if (!activeHealthBarIds.has(id)) releaseElement(healthBarPool, id); }
        for (const id in allBubbles) { if (!activeBubbleIds.has(id)) continue; const bubbleData = allBubbles[id]; const posData = appState.uiPositions[id]; if (!posData) continue; const element = getElement(speechBubblePool, id, 'overlay-element speech-bubble', overlay); element.textContent = bubbleData.text; const healthBarExists = activeHealthBarIds.has(id); const entityData = players[id] || enemies[id]; const armorVisible = healthBarExists && (entityData?.armor > 0); const baseOffsetY = -45; const healthBarTotalHeight = healthBarExists ? (healthBarHeight + (armorVisible ? armorBarHeight + barSpacing : 0) + barSpacing) : 0; const bubbleOffsetY = baseOffsetY - healthBarTotalHeight; element.style.left = `${posData.screenX}px`; element.style.top = `${posData.screenY + bubbleOffsetY}px`; }
        for (const id in speechBubblePool.elements) { if (!activeBubbleIds.has(id)) releaseElement(speechBubblePool, id); }
    }
    function gameLoop(currentTime) {
        if (!appState.isGameLoopRunning) { cleanupLoop(); return; }
        const now = performance.now(); if (lastLoopTime === null) lastLoopTime = now; const deltaTime = Math.min(0.1, (now - lastLoopTime) / 1000); lastLoopTime = now;
        if (localPlayerPushbackAnim.active && now >= localPlayerPushbackAnim.endTime) localPlayerPushbackAnim.active = false; if (localPlayerMuzzleFlash.active && now >= localPlayerMuzzleFlash.endTime) localPlayerMuzzleFlash.active = false;
        if (typeof snake?.update === 'function') snake.update(now); updateLocalAmmoCasings(deltaTime);
        if (appState.serverState?.status === 'active' && InputManager.isShootHeld()) InputManager.handleShooting();
        if (appState.serverState?.status === 'active') { updatePredictedPosition(deltaTime); reconcileWithServer(); } // Apply prediction/reconciliation ALWAYS if active (incl. SP)
        const stateToRender = getInterpolatedState(now);
        if (stateToRender && typeof Renderer3D !== 'undefined' && Renderer3D.renderScene) { Renderer3D.renderScene(stateToRender, appState, localEffects); } else if (appState.mode !== 'menu') { log("Skipping render..."); }
        if (stateToRender && appState.mode !== 'menu') { updateHtmlOverlays(stateToRender); }
        if (appState.isGameLoopRunning) { appState.animationFrameId = requestAnimationFrame(gameLoop); } else { cleanupLoop(); }
    }
    function startGameLoop() { if (appState.isGameLoopRunning || appState.mode === 'menu') return; if (!appState.serverState) { log("Delaying loop: Waiting for state."); return; } log("Starting game loop..."); InputManager.setup(); appState.isGameLoopRunning = true; lastLoopTime = null; appState.animationFrameId = requestAnimationFrame(gameLoop); }
    function cleanupLoop() { if (appState.animationFrameId) cancelAnimationFrame(appState.animationFrameId); appState.animationFrameId = null; InputManager.cleanup(); appState.isGameLoopRunning = false; lastLoopTime = null; log("Game loop stopped."); }
    function updateLocalAmmoCasings(deltaTime) { activeAmmoCasings = activeAmmoCasings.filter(c => (performance.now() - c.spawnTime) < c.lifetime); activeAmmoCasings.forEach(c => { c.vy += c.gravity * deltaTime; c.x += c.vx * deltaTime; c.y += c.vy * deltaTime; c.rotation += c.rotationSpeed * deltaTime; }); }
    function getInterpolatedState(renderTime) { const serverState = appState.serverState; const lastState = appState.lastServerState; if (!lastState || !serverState?.timestamp || !lastState?.timestamp || serverState.timestamp <= lastState.timestamp) { if (serverState?.players?.[appState.localPlayerId]) { let currentStateCopy = JSON.parse(JSON.stringify(serverState)); currentStateCopy.players[appState.localPlayerId].x = appState.renderedPlayerPos.x; currentStateCopy.players[appState.localPlayerId].y = appState.renderedPlayerPos.y; return currentStateCopy; } return serverState; } const serverTime = serverState.timestamp * 1000; const lastServerTime = lastState.timestamp * 1000; const timeBetweenStates = serverTime - lastServerTime; const renderTargetTime = renderTime - INTERPOLATION_BUFFER_MS; const timeSinceLastState = renderTargetTime - lastServerTime; let t = Math.max(0, Math.min(1, timeSinceLastState / timeBetweenStates)); let interpolatedState = JSON.parse(JSON.stringify(serverState)); if (interpolatedState.players) { for (const pId in interpolatedState.players) { const currentP = serverState.players[pId]; const lastP = lastState.players?.[pId]; if (pId === appState.localPlayerId) { interpolatedState.players[pId].x = appState.renderedPlayerPos.x; interpolatedState.players[pId].y = appState.renderedPlayerPos.y; } else if (lastP && typeof currentP.x === 'number' && typeof lastP.x === 'number' && typeof currentP.y === 'number' && typeof lastP.y === 'number') { interpolatedState.players[pId].x = lerp(lastP.x, currentP.x, t); interpolatedState.players[pId].y = lerp(lastP.y, currentP.y, t); } } } if (interpolatedState.enemies) { for (const eId in interpolatedState.enemies) { const currentE = serverState.enemies[eId]; const lastE = lastState.enemies?.[eId]; if (lastE && currentE.health > 0 && typeof currentE.x === 'number' && typeof lastE.x === 'number' && typeof currentE.y === 'number' && typeof lastE.y === 'number') { interpolatedState.enemies[eId].x = lerp(lastE.x, currentE.x, t); interpolatedState.enemies[eId].y = lerp(lastE.y, currentE.y, t); } } } if (interpolatedState.bullets) { for (const bId in interpolatedState.bullets) { const currentB = serverState.bullets[bId]; const lastB = lastState.bullets?.[bId]; if (lastB && typeof currentB.x === 'number' && typeof lastB.x === 'number' && typeof currentB.y === 'number' && typeof lastB.y === 'number') { interpolatedState.bullets[bId].x = lerp(lastB.x, currentB.x, t); interpolatedState.bullets[bId].y = lerp(lastB.y, currentB.y, t); } } } interpolatedState.powerups = serverState.powerups; interpolatedState.damage_texts = serverState.damage_texts; return interpolatedState; }
    function updatePredictedPosition(deltaTime) { if (!appState.localPlayerId || !appState.serverState?.players?.[appState.localPlayerId]) return; const playerState = appState.serverState.players[appState.localPlayerId]; if(playerState.player_status !== PLAYER_STATUS_ALIVE) return; const moveVector = InputManager.getMovementInputVector(); const playerSpeed = playerState?.speed ?? PLAYER_DEFAULTS.base_speed; if (moveVector.dx !== 0 || moveVector.dy !== 0) { appState.predictedPlayerPos.x += moveVector.dx * playerSpeed * deltaTime; appState.predictedPlayerPos.y += moveVector.dy * playerSpeed * deltaTime; } const w_half = (playerState?.width ?? PLAYER_DEFAULTS.width) / 2; const h_half = (playerState?.height ?? PLAYER_DEFAULTS.height) / 2; appState.predictedPlayerPos.x = Math.max(w_half, Math.min(appState.canvasWidth - w_half, appState.predictedPlayerPos.x)); appState.predictedPlayerPos.y = Math.max(h_half, Math.min(appState.canvasHeight - h_half, appState.predictedPlayerPos.y)); }
    function reconcileWithServer() { if (!appState.localPlayerId || !appState.serverState?.players?.[appState.localPlayerId]) return; const serverPos = appState.serverState.players[appState.localPlayerId]; if (typeof serverPos.x !== 'number' || typeof serverPos.y !== 'number') return; const predictedPos = appState.predictedPlayerPos; const renderedPos = appState.renderedPlayerPos; const dist = distance(predictedPos.x, predictedPos.y, serverPos.x, serverPos.y); const snapThreshold = parseFloat(getCssVar('--reconciliation-threshold')) || 35; const renderLerpFactor = parseFloat(getCssVar('--lerp-factor')) || 0.15; if (dist > snapThreshold) { predictedPos.x = serverPos.x; predictedPos.y = serverPos.y; renderedPos.x = serverPos.x; renderedPos.y = serverPos.y; } else { renderedPos.x = lerp(renderedPos.x, predictedPos.x, renderLerpFactor); renderedPos.y = lerp(renderedPos.y, predictedPos.y, renderLerpFactor); } }
    return { initListeners, startSinglePlayer, joinMultiplayer, hostMultiplayer, leaveGame, sendChatMessage, triggerLocalPushback, spawnLocalAmmoCasing, resetClientState, startGameLoop, cleanupLoop, setInitialGameState: (state, localId, gameId, maxPlayers) => { log("Game: Setting initial state."); appState.serverState = state; appState.localPlayerId = localId; appState.currentGameId = gameId; appState.maxPlayersInGame = maxPlayers; if (state?.canvas_width && state?.canvas_height) { appState.canvasWidth = state.canvas_width; appState.canvasHeight = state.canvas_height; } else { error("Initial state missing canvas dimensions!"); } const initialPlayer = state?.players[localId]; if (initialPlayer?.x && initialPlayer?.y) { appState.predictedPlayerPos = { x: initialPlayer.x, y: initialPlayer.y }; appState.renderedPlayerPos = { x: initialPlayer.x, y: initialPlayer.y }; } else { appState.predictedPlayerPos = { x: appState.canvasWidth / 2, y: appState.canvasHeight / 2 }; appState.renderedPlayerPos = { x: appState.canvasWidth / 2, y: appState.canvasHeight / 2 }; } appState.localPlayerAimState = { lastAimDx: 0, lastAimDy: -1 }; }, updateServerState: (newState) => { appState.lastServerState = appState.serverState; appState.serverState = newState; appState.lastStateReceiveTime = performance.now(); if (newState?.canvas_width && newState?.canvas_height && (appState.canvasWidth !== newState.canvas_width || appState.canvasHeight !== newState.canvas_height)) { appState.canvasWidth = newState.canvas_width; appState.canvasHeight = newState.canvas_height; log(`Canvas dimensions updated: ${appState.canvasWidth}x${appState.canvasHeight}`); } }, updateHostWaitUI: (state) => { const currentP = Object.keys(state?.players || {}).length; const maxP = appState.maxPlayersInGame || '?'; if (DOM.waitingMessage) DOM.waitingMessage.textContent = `Waiting... (${currentP}/${maxP})`; }, handlePlayerChat: (senderId, message) => { const isSelf = senderId === appState.localPlayerId; UIManager.addChatMessage(senderId, message, isSelf); if (appState.serverState?.players?.[senderId]) activeSpeechBubbles[senderId] = { text: message.substring(0, 50), endTime: performance.now() + SPEECH_BUBBLE_DURATION_MS }; }, handleEnemyChat: (speakerId, message) => { if (speakerId && message) activeEnemyBubbles[speakerId] = { text: message.substring(0, 50), endTime: performance.now() + ENEMY_SPEECH_BUBBLE_DURATION_MS }; }, handleDamageFeedback: (newState) => { const prevP = appState.lastServerState?.players?.[appState.localPlayerId]; const currP = newState?.players?.[appState.localPlayerId]; let damaged = false; if (prevP && currP && typeof currP.health === 'number' && typeof prevP.health === 'number' && currP.health < prevP.health) { const dmg = prevP.health - currP.health; const mag = Math.min(18, 5 + dmg * 0.18); if (Renderer3D?.triggerShake) Renderer3D.triggerShake(mag, 250); else warn("No triggerShake"); damaged = true; SoundManager.playSound('damage'); } if (currP?.trigger_snake_bite_shake_this_tick) { if(Renderer3D?.triggerShake) Renderer3D.triggerShake(15.0, 400.0); else warn("No triggerShake"); } if (newState.enemies) { const now = performance.now(); for (const eId in newState.enemies) { const enemy = newState.enemies[eId]; const prevE = appState.lastServerState?.enemies?.[eId]; if (enemy?.last_damage_time && (!prevE || enemy.last_damage_time > (prevE.last_damage_time || 0))) { if (now - (enemy.last_damage_time * 1000) < 250) activeBloodSparkEffects[eId] = now + SPARK_DURATION_MS; } } for (const eId in activeBloodSparkEffects) { if (now >= activeBloodSparkEffects[eId]) delete activeBloodSparkEffects[eId]; } } } };
})();

function handleServerMessage(event) {
    let data; try { data = JSON.parse(event.data); } catch (err) { error("Failed parse WS message:", err, event.data); return; }
    try {
        const rendererNeeded = ['sp_game_started', 'game_joined', 'game_state', 'game_created', 'game_over_notification'].includes(data.type);
        if (rendererNeeded && typeof Renderer3D === 'undefined') { error(`Received '${data.type}' before Renderer3D module!`); return; }
        switch (data.type) {
            case 'game_created': case 'game_joined': case 'sp_game_started': log(`Received '${data.type}'`); GameManager.setInitialGameState(data.initial_state, data.player_id, data.game_id, data.max_players || data.initial_state?.max_players || (data.type === 'sp_game_started' ? 1 : '?')); if (data.type === 'game_created') { if (DOM.gameCodeDisplay) DOM.gameCodeDisplay.textContent = appState.currentGameId || 'ERROR'; UIManager.updateStatus(`Hosted Game: ${appState.currentGameId}`); GameManager.updateHostWaitUI(appState.serverState); UIManager.showSection('host-wait-section'); } else { const joinMsg = data.type === 'game_joined' ? `Joined ${appState.currentGameId}` : "Single Player Started!"; UIManager.updateStatus(joinMsg); UIManager.showSection('game-area'); if (appState.serverState) { UIManager.updateHUD(appState.serverState); UIManager.updateCountdown(appState.serverState); UIManager.updateDayNight(appState.serverState); UIManager.updateEnvironmentDisplay(appState.serverState); } GameManager.startGameLoop(); } break;
            case 'game_state': if (appState.mode === 'menu' || !appState.localPlayerId) return; const previousStatus = appState.serverState?.status; GameManager.updateServerState(data.state); const newState = appState.serverState; if (newState.status !== previousStatus) { log(`[Client State Change] ${previousStatus || 'null'} -> ${newState.status}`); if ((newState.status === 'countdown' || newState.status === 'active') && previousStatus !== 'active' && previousStatus !== 'countdown') { UIManager.updateStatus(newState.status === 'countdown' ? "Get Ready..." : "Active!"); UIManager.showSection('game-area'); if (!appState.isGameLoopRunning) GameManager.startGameLoop(); } else if (newState.status === 'waiting' && appState.mode === 'multiplayer-host' && previousStatus !== 'waiting') { UIManager.updateStatus("Waiting for players..."); UIManager.showSection('host-wait-section'); GameManager.updateHostWaitUI(newState); GameManager.cleanupLoop(); } else if (newState.status === 'finished' && previousStatus !== 'finished') { log("-> Game Over via 'finished' status."); UIManager.updateStatus("Game Over!"); UIManager.showGameOver(newState); GameManager.cleanupLoop(); } } if (appState.isGameLoopRunning && (newState.status === 'countdown' || newState.status === 'active')) { UIManager.updateHUD(newState); UIManager.updateCountdown(newState); UIManager.updateDayNight(newState); UIManager.updateEnvironmentDisplay(newState); } else if (newState.status === 'waiting' && appState.mode === 'multiplayer-host') { GameManager.updateHostWaitUI(newState); } GameManager.handleEnemyChat(newState.enemy_speaker_id, newState.enemy_speech_text); GameManager.handleDamageFeedback(newState); if (newState.snake_state && typeof snake !== 'undefined') { snake.isActiveFromServer = newState.snake_state.active; snake.serverHeadX = newState.snake_state.head_x; snake.serverHeadY = newState.snake_state.head_y; snake.serverBaseY = newState.snake_state.base_y; } else if (typeof snake !== 'undefined') { snake.isActiveFromServer = false; } break;
            case 'game_over_notification': log("Received 'game_over_notification'"); if (data.final_state) { appState.serverState = data.final_state; UIManager.updateStatus("Game Over!"); UIManager.showGameOver(data.final_state); } else { error("Game over missing final_state."); UIManager.showGameOver(null); } GameManager.cleanupLoop(); break;
            case 'chat_message': GameManager.handlePlayerChat(data.sender_id, data.message); break;
            case 'error': error("[Client] Server Error:", data.message); UIManager.updateStatus(`Error: ${data.message}`, true); const isJoinError = appState.mode === 'multiplayer-client' && (data.message.includes('not found') || data.message.includes('not waiting') || data.message.includes('full') || data.message.includes('finished')); const isHostError = appState.mode === 'multiplayer-host' && data.message.includes('Creation Error'); if (isJoinError) { UIManager.showSection('join-code-section'); appState.mode = 'menu'; } else if (isHostError) { GameManager.resetClientState(true); } else if (data.message === 'Please create or join a game first.') { GameManager.resetClientState(true); } break;
            default: log(`Unknown message type: ${data.type}`);
        }
    } catch (handlerError) { error("Error in handleServerMessage:", handlerError, "Data:", data); }
}

document.addEventListener('DOMContentLoaded', () => {
    log("DOM loaded. Initializing...");
    if (!DOM.gameContainer || !DOM.loadingScreen || !DOM.canvasContainer || !DOM.htmlOverlay) { error("CRITICAL: Essential DOM elements missing!"); document.body.innerHTML = "<p style='color:red; text-align: center;'>Error: Critical UI elements missing.</p>"; return; }
    if (typeof Renderer3D === 'undefined' || !Renderer3D.init) { error("CRITICAL: Renderer3D missing!"); UIManager.updateStatus("Init Error: Renderer failed.", true); DOM.loadingScreen?.classList.remove('active'); DOM.gameContainer?.classList.add('loaded'); return; }
    // Note: Renderer now needs the container, not the canvas directly based on previous Renderer code structure
    if (!Renderer3D.init(DOM.canvasContainer, appState.canvasWidth, appState.canvasHeight)) { error("Renderer3D initialization failed!"); UIManager.updateStatus("Init Error: Graphics failed.", true); DOM.loadingScreen?.classList.remove('active'); DOM.gameContainer?.classList.add('loaded'); return; }
    log("Renderer3D initialized."); SoundManager.init(); try { GameManager.initListeners(); } catch(listenerError) { error("Error initializing listeners:", listenerError); UIManager.updateStatus("Init Error: Controls failed.", true); } UIManager.updateStatus("Initializing Connection..."); NetworkManager.connect(() => { log("Initial WebSocket connection successful."); });
});
